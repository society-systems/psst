
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                info.blocks[i] = null;
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.31.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.31.0 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (209:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(209:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (202:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(202:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap$1(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading");

    	return wrap({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    	try {
    		window.history.replaceState(undefined, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event("hashchange"));
    }

    function link(node, hrefVar) {
    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	updateLink(node, hrefVar || node.getAttribute("href"));

    	return {
    		update(updated) {
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, href) {
    	// Destination must start with '/'
    	if (!href || href.length < 1 || href.charAt(0) != "/") {
    		throw Error("Invalid value for \"href\" attribute: " + href);
    	}

    	// Add # to the href attribute
    	node.setAttribute("href", "#" + href);

    	node.addEventListener("click", scrollstateHistoryHandler);
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {HTMLElementEventMap} event - an onclick event attached to an anchor tag
     */
    function scrollstateHistoryHandler(event) {
    	// Prevent default anchor onclick behaviour
    	event.preventDefault();

    	const href = event.currentTarget.getAttribute("href");

    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument - strings must start with / or *");
    			}

    			const { pattern, keys } = regexparam(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == "string") {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || "/";
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || "/";
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {bool} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	if (restoreScrollState) {
    		window.addEventListener("popstate", event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		});

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.scrollX, previousScrollState.scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick("conditionsFailed", detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoading", Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == "object" && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    	});

    	const writable_props = ["routes", "prefix", "restoreScrollState"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble($$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		derived,
    		tick,
    		_wrap: wrap,
    		wrap: wrap$1,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		scrollstateHistoryHandler,
    		createEventDispatcher,
    		afterUpdate,
    		regexparam,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		lastLoc,
    		componentObj
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("previousScrollState" in $$props) previousScrollState = $$props.previousScrollState;
    		if ("lastLoc" in $$props) lastLoc = $$props.lastLoc;
    		if ("componentObj" in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			 history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init$1 () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init$1();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init$1();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    /*
     * Export kMaxLength after typed array support is determined.
     */
    var _kMaxLength = kMaxLength();

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }

    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0;
      }
      return Buffer.alloc(+length)
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    var bufferEs6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
        kMaxLength: _kMaxLength,
        Buffer: Buffer,
        SlowBuffer: SlowBuffer,
        isBuffer: isBuffer
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    function commonjsRequire (target) {
    	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
    }

    var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(bufferEs6);

    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

    var safeBuffer = createCommonjsModule(function (module, exports) {
    /* eslint-disable node/no-deprecated-api */

    var Buffer = require$$0.Buffer;

    // alternative to using Object.keys for old browsers
    function copyProps (src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = require$$0;
    } else {
      // Copy properties from require('buffer')
      copyProps(require$$0, exports);
      exports.Buffer = SafeBuffer;
    }

    function SafeBuffer (arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length)
    }

    SafeBuffer.prototype = Object.create(Buffer.prototype);

    // Copy static methods from Buffer
    copyProps(Buffer, SafeBuffer);

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number')
      }
      return Buffer(arg, encodingOrOffset, length)
    };

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      var buf = Buffer(size);
      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf
    };

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return Buffer(size)
    };

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return require$$0.SlowBuffer(size)
    };
    });

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$1() {}

    var on = noop$1;
    var addListener = noop$1;
    var once = noop$1;
    var off = noop$1;
    var removeListener = noop$1;
    var removeAllListeners = noop$1;
    var emit = noop$1;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var domain;

    // This constructor is used to store event handlers. Instantiating this is
    // faster than explicitly calling `Object.create(null)` to get a "clean" empty
    // object (tested with v8 v4.9).
    function EventHandlers() {}
    EventHandlers.prototype = Object.create(null);

    function EventEmitter() {
      EventEmitter.init.call(this);
    }

    // nodejs oddity
    // require('events') === require('events').EventEmitter
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.usingDomains = false;

    EventEmitter.prototype.domain = undefined;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        // if there is an active domain, then attach to it.
        if (domain.active ) ;
      }

      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };

    // These standalone emit* functions are used to optimize calling of event
    // handlers for fast cases because emit() itself often has a variable number of
    // arguments and can be deoptimized because of that. These functions always have
    // the same number of arguments and thus do not get deoptimized, so the code
    // inside them can execute faster.
    function emitNone(handler, isFn, self) {
      if (isFn)
        handler.call(self);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self);
      }
    }
    function emitOne(handler, isFn, self, arg1) {
      if (isFn)
        handler.call(self, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1);
      }
    }
    function emitTwo(handler, isFn, self, arg1, arg2) {
      if (isFn)
        handler.call(self, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2, arg3);
      }
    }

    function emitMany(handler, isFn, self, args) {
      if (isFn)
        handler.apply(self, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self, args);
      }
    }

    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain;
      var doError = (type === 'error');

      events = this._events;
      if (events)
        doError = (doError && events.error == null);
      else if (!doError)
        return false;

      domain = this.domain;

      // If there is no 'error' event listener then throw.
      if (doError) {
        er = arguments[1];
        if (domain) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain;
          er.domainThrown = false;
          domain.emit('error', er);
        } else if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }
        return false;
      }

      handler = events[type];

      if (!handler)
        return false;

      var isFn = typeof handler === 'function';
      len = arguments.length;
      switch (len) {
        // fast cases
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        // slower
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (!existing) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] :
                                              [existing, listener];
        } else {
          // If we've already got an array, just append.
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }

        // Check for listener leak
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                                existing.length + ' ' + type + ' listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }

      return target;
    }
    function emitWarning(e) {
      typeof console.warn === 'function' ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events)
            return this;

          list = events[type];
          if (!list)
            return this;

          if (list === listener || (list.listener && list.listener === listener)) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length; i-- > 0;) {
              if (list[i] === listener ||
                  (list[i].listener && list[i].listener === listener)) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (list.length === 1) {
              list[0] = undefined;
              if (--this._eventsCount === 0) {
                this._events = new EventHandlers();
                return this;
              } else {
                delete events[type];
              }
            } else {
              spliceOne(list, position);
            }

            if (events.removeListener)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events;

          events = this._events;
          if (!events)
            return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = new EventHandlers();
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = new EventHandlers();
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            for (var i = 0, key; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = new EventHandlers();
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            do {
              this.removeListener(type, listeners[listeners.length - 1]);
            } while (listeners[0]);
          }

          return this;
        };

    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;

      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === 'function')
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }

      return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;

      if (events) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };

    // About 1.5x faster than the two-arg version of Array#splice().
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }

    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    var events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': EventEmitter,
        EventEmitter: EventEmitter
    });

    var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(events);

    var streamBrowser = require$$0$1.EventEmitter;

    var inherits;
    if (typeof Object.create === 'function'){
      inherits = function inherits(ctor, superCtor) {
        // implementation from standard node.js 'util' module
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    var inherits$1 = inherits;

    var formatRegExp = /%[sdj%]/g;
    function format(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    }

    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    function deprecate(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined(global$1.process)) {
        return function() {
          return deprecate(fn, msg).apply(this, arguments);
        };
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    }

    var debugs = {};
    var debugEnviron;
    function debuglog(set) {
      if (isUndefined(debugEnviron))
        debugEnviron =  '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = 0;
          debugs[set] = function() {
            var msg = format.apply(null, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    }

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        _extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray$1(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray$1(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }

    function isBuffer$1(maybeBuf) {
      return isBuffer(maybeBuf);
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }


    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }


    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];

    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }


    // log is just a thin wrapper to console.log that prepends a timestamp
    function log() {
      console.log('%s - %s', timestamp(), format.apply(null, arguments));
    }

    function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var util = {
      inherits: inherits$1,
      _extend: _extend,
      log: log,
      isBuffer: isBuffer$1,
      isPrimitive: isPrimitive,
      isFunction: isFunction,
      isError: isError,
      isDate: isDate,
      isObject: isObject,
      isRegExp: isRegExp,
      isUndefined: isUndefined,
      isSymbol: isSymbol,
      isString: isString,
      isNumber: isNumber,
      isNullOrUndefined: isNullOrUndefined,
      isNull: isNull,
      isBoolean: isBoolean,
      isArray: isArray$1,
      inspect: inspect,
      deprecate: deprecate,
      format: format,
      debuglog: debuglog
    };

    var util$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        format: format,
        deprecate: deprecate,
        debuglog: debuglog,
        inspect: inspect,
        isArray: isArray$1,
        isBoolean: isBoolean,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isNumber: isNumber,
        isString: isString,
        isSymbol: isSymbol,
        isUndefined: isUndefined,
        isRegExp: isRegExp,
        isObject: isObject,
        isDate: isDate,
        isError: isError,
        isFunction: isFunction,
        isPrimitive: isPrimitive,
        isBuffer: isBuffer$1,
        log: log,
        inherits: inherits$1,
        _extend: _extend,
        'default': util
    });

    var debugUtil = /*@__PURE__*/getAugmentedNamespace(util$1);

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var Buffer$1 = require$$0.Buffer;

    var inspect$1 = debugUtil.inspect;

    var custom = inspect$1 && inspect$1.custom || 'inspect';

    function copyBuffer(src, target, offset) {
      Buffer$1.prototype.copy.call(src, target, offset);
    }

    var buffer_list =
    /*#__PURE__*/
    function () {
      function BufferList() {
        _classCallCheck(this, BufferList);

        this.head = null;
        this.tail = null;
        this.length = 0;
      }

      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return '';
          var p = this.head;
          var ret = '' + p.data;

          while (p = p.next) {
            ret += s + p.data;
          }

          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer$1.alloc(0);
          var ret = Buffer$1.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;

          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }

          return ret;
        } // Consumes a specified amount of bytes or characters from the buffered data.

      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;

          if (n < this.head.data.length) {
            // `slice` is the same for buffers and strings.
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            // First chunk is a perfect match.
            ret = this.shift();
          } else {
            // Result spans more than one buffer.
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }

          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        } // Consumes a specified amount of characters from the buffered data.

      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;

          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;else ret += str.slice(0, n);
            n -= nb;

            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }

              break;
            }

            ++c;
          }

          this.length -= c;
          return ret;
        } // Consumes a specified amount of bytes from the buffered data.

      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer$1.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;

          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;

            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }

              break;
            }

            ++c;
          }

          this.length -= c;
          return ret;
        } // Make sure the linked list only shows the minimal necessary information.

      }, {
        key: custom,
        value: function value(_, options) {
          return inspect$1(this, _objectSpread({}, options, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);

      return BufferList;
    }();

    function destroy(err, cb) {
      var _this = this;

      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;

      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            nextTick(emitErrorNT, this, err);
          }
        }

        return this;
      } // we set destroyed to true before firing error callbacks in order
      // to make it re-entrance safe in case destroy() is called within callbacks


      if (this._readableState) {
        this._readableState.destroyed = true;
      } // if this is a duplex stream mark the writable part as destroyed as well


      if (this._writableState) {
        this._writableState.destroyed = true;
      }

      this._destroy(err || null, function (err) {
        if (!cb && err) {
          if (!_this._writableState) {
            nextTick(emitErrorAndCloseNT, _this, err);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            nextTick(emitErrorAndCloseNT, _this, err);
          } else {
            nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          nextTick(emitCloseNT, _this);
          cb(err);
        } else {
          nextTick(emitCloseNT, _this);
        }
      });

      return this;
    }

    function emitErrorAndCloseNT(self, err) {
      emitErrorNT(self, err);
      emitCloseNT(self);
    }

    function emitCloseNT(self) {
      if (self._writableState && !self._writableState.emitClose) return;
      if (self._readableState && !self._readableState.emitClose) return;
      self.emit('close');
    }

    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }

      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }

    function emitErrorNT(self, err) {
      self.emit('error', err);
    }

    function errorOrDestroy(stream, err) {
      // We have tests that rely on errors being emitted
      // in the same tick, so changing this is semver major.
      // For now when you opt-in to autoDestroy we allow
      // the error to be emitted nextTick. In a future
      // semver major update we should change the default to this.
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
    }

    var destroy_1 = {
      destroy: destroy,
      undestroy: undestroy,
      errorOrDestroy: errorOrDestroy
    };

    function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

    var codes = {};

    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }

      function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }

      var NodeError =
      /*#__PURE__*/
      function (_Base) {
        _inheritsLoose(NodeError, _Base);

        function NodeError(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }

        return NodeError;
      }(Base);

      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function (i) {
          return String(i);
        });

        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


    function endsWith(str, search, this_len) {
      if (this_len === undefined || this_len > str.length) {
        this_len = str.length;
      }

      return str.substring(this_len - search.length, this_len) === search;
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


    function includes(str, search, start) {
      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }

    createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
      // determiner: 'must be' or 'must not be'
      var determiner;

      if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
      } else {
        determiner = 'must be';
      }

      var msg;

      if (endsWith(name, ' argument')) {
        // For cases like 'first argument'
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
      } else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
      }

      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
    createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
      return 'The ' + name + ' method is not implemented';
    });
    createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
    createErrorType('ERR_STREAM_DESTROYED', function (name) {
      return 'Cannot call ' + name + ' after a stream was destroyed';
    });
    createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
    createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
    createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
    createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
    createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
      return 'Unknown encoding: ' + arg;
    }, TypeError);
    createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
    var codes_1 = codes;

    var errorsBrowser = {
    	codes: codes_1
    };

    var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;

    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }

    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : 'highWaterMark';
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }

        return Math.floor(hwm);
      } // Default value


      return state.objectMode ? 16 : 16 * 1024;
    }

    var state = {
      getHighWaterMark: getHighWaterMark
    };

    /**
     * Module exports.
     */

    var browser$1 = deprecate$1;

    /**
     * Mark that a method should not be used.
     * Returns a modified function which warns once by default.
     *
     * If `localStorage.noDeprecation = true` is set, then it is a no-op.
     *
     * If `localStorage.throwDeprecation = true` is set, then deprecated functions
     * will throw an Error when invoked.
     *
     * If `localStorage.traceDeprecation = true` is set, then deprecated functions
     * will invoke `console.trace()` instead of `console.error()`.
     *
     * @param {Function} fn - the function to deprecate
     * @param {String} msg - the string to print to the console when `fn` is invoked
     * @returns {Function} a new "deprecated" version of `fn`
     * @api public
     */

    function deprecate$1 (fn, msg) {
      if (config$1('noDeprecation')) {
        return fn;
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config$1('throwDeprecation')) {
            throw new Error(msg);
          } else if (config$1('traceDeprecation')) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    }

    /**
     * Checks `localStorage` for boolean values for the given `name`.
     *
     * @param {String} name
     * @returns {Boolean}
     * @api private
     */

    function config$1 (name) {
      // accessing global.localStorage can trigger a DOMException in sandboxed iframes
      try {
        if (!commonjsGlobal.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = commonjsGlobal.localStorage[name];
      if (null == val) return false;
      return String(val).toLowerCase() === 'true';
    }

    var _stream_writable = Writable;
    // there will be only 2 of these for each stream


    function CorkedRequest(state) {
      var _this = this;

      this.next = null;
      this.entry = null;

      this.finish = function () {
        onCorkedFinish(_this, state);
      };
    }
    /* </replacement> */

    /*<replacement>*/


    var Duplex;
    /*</replacement>*/

    Writable.WritableState = WritableState;
    /*<replacement>*/

    var internalUtil = {
      deprecate: browser$1
    };
    /*</replacement>*/

    /*<replacement>*/


    /*</replacement>*/


    var Buffer$2 = require$$0.Buffer;

    var OurUint8Array = commonjsGlobal.Uint8Array || function () {};

    function _uint8ArrayToBuffer(chunk) {
      return Buffer$2.from(chunk);
    }

    function _isUint8Array(obj) {
      return Buffer$2.isBuffer(obj) || obj instanceof OurUint8Array;
    }



    var getHighWaterMark$1 = state.getHighWaterMark;

    var _require$codes = errorsBrowser.codes,
        ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
        ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
        ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
        ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
        ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
        ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

    var errorOrDestroy$1 = destroy_1.errorOrDestroy;

    inherits_browser(Writable, streamBrowser);

    function nop() {}

    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || _stream_duplex;
      options = options || {}; // Duplex streams are both readable and writable, but share
      // the same options object.
      // However, some cases require setting options to different
      // values for the readable and the writable sides of the duplex stream,
      // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

      if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
      // contains buffers or objects.

      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()

      this.highWaterMark = getHighWaterMark$1(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

      this.finalCalled = false; // drain event flag.

      this.needDrain = false; // at the start of calling end()

      this.ending = false; // when end() has been called, and returned

      this.ended = false; // when 'finish' is emitted

      this.finished = false; // has it been destroyed

      this.destroyed = false; // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.

      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.

      this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.

      this.length = 0; // a flag to see when we're in the middle of a write.

      this.writing = false; // when true all writes will be buffered until .uncork() call

      this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.

      this.sync = true; // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.

      this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

      this.onwrite = function (er) {
        onwrite(stream, er);
      }; // the callback that the user supplies to write(chunk,encoding,cb)


      this.writecb = null; // the amount that is being written when _write is called.

      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted

      this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams

      this.prefinished = false; // True if the error was already emitted and should not be thrown again

      this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

      this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

      this.autoDestroy = !!options.autoDestroy; // count buffered requests

      this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
      // one allocated and free to use, and we maintain at most two

      this.corkedRequestsFree = new CorkedRequest(this);
    }

    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];

      while (current) {
        out.push(current);
        current = current.next;
      }

      return out;
    };

    (function () {
      try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
        });
      } catch (_) {}
    })(); // Test _writableState for inheritance to account for Duplex streams,
    // whose prototype chain only points to Readable.


    var realHasInstance;

    if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance(object) {
        return object instanceof this;
      };
    }

    function Writable(options) {
      Duplex = Duplex || _stream_duplex; // Writable ctor is applied to Duplexes, too.
      // `realHasInstance` is necessary because using plain `instanceof`
      // would return false, as no `_writableState` property is attached.
      // Trying to use the custom `instanceof` for Writable here will also break the
      // Node.js LazyTransform implementation, which has a non-trivial getter for
      // `_writableState` that would lead to infinite recursion.
      // Checking for a Stream.Duplex instance is faster here instead of inside
      // the WritableState constructor, at least with V8 6.5

      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex); // legacy.

      this.writable = true;

      if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
        if (typeof options.final === 'function') this._final = options.final;
      }

      streamBrowser.call(this);
    } // Otherwise people can pipe Writable streams, which is just wrong.


    Writable.prototype.pipe = function () {
      errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
    };

    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

      errorOrDestroy$1(stream, er);
      nextTick(cb, er);
    } // Checks that a user-supplied chunk is valid, especially for the particular
    // mode the stream is in. Currently this means that `null` is never accepted
    // and undefined/non-string values are only allowed in object mode.


    function validChunk(stream, state, chunk, cb) {
      var er;

      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== 'string' && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
      }

      if (er) {
        errorOrDestroy$1(stream, er);
        nextTick(cb, er);
        return false;
      }

      return true;
    }

    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;

      var isBuf = !state.objectMode && _isUint8Array(chunk);

      if (isBuf && !Buffer$2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== 'function') cb = nop;
      if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };

    Writable.prototype.cork = function () {
      this._writableState.corked++;
    };

    Writable.prototype.uncork = function () {
      var state = this._writableState;

      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };

    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };

    Object.defineProperty(Writable.prototype, 'writableBuffer', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });

    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer$2.from(chunk, encoding);
      }

      return chunk;
    }

    Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    }); // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.

    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);

        if (chunk !== newChunk) {
          isBuf = true;
          encoding = 'buffer';
          chunk = newChunk;
        }
      }

      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

      if (!ret) state.needDrain = true;

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk: chunk,
          encoding: encoding,
          isBuf: isBuf,
          callback: cb,
          next: null
        };

        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }

        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }

      return ret;
    }

    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }

    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;

      if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        nextTick(cb, er); // this can emit finish, and it will always happen
        // after error

        nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy$1(stream, er);
      } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy$1(stream, er); // this can emit finish, but finish must
        // always follow error

        finishMaybe(stream, state);
      }
    }

    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }

    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }

        if (sync) {
          nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }

    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    } // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.


    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    } // if there's something in the buffer waiting, then process it


    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;

      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;

        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }

        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite

        state.pendingcb++;
        state.lastBufferedRequest = null;

        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }

        state.bufferedRequestCount = 0;
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.

          if (state.writing) {
            break;
          }
        }

        if (entry === null) state.lastBufferedRequest = null;
      }

      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }

    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
    };

    Writable.prototype._writev = null;

    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;

      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

      if (state.corked) {
        state.corked = 1;
        this.uncork();
      } // ignore unnecessary end() calls.


      if (!state.ending) endWritable(this, state, cb);
      return this;
    };

    Object.defineProperty(Writable.prototype, 'writableLength', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });

    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }

    function callFinal(stream, state) {
      stream._final(function (err) {
        state.pendingcb--;

        if (err) {
          errorOrDestroy$1(stream, err);
        }

        state.prefinished = true;
        stream.emit('prefinish');
        finishMaybe(stream, state);
      });
    }

    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === 'function' && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit('prefinish');
        }
      }
    }

    function finishMaybe(stream, state) {
      var need = needFinish(state);

      if (need) {
        prefinish(stream, state);

        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit('finish');

          if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the readable side is ready for autoDestroy as well
            var rState = stream._readableState;

            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }

      return need;
    }

    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);

      if (cb) {
        if (state.finished) nextTick(cb);else stream.once('finish', cb);
      }

      state.ended = true;
      stream.writable = false;
    }

    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;

      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      } // reuse the free corkReq.


      state.corkedRequestsFree.next = corkReq;
    }

    Object.defineProperty(Writable.prototype, 'destroyed', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === undefined) {
          return false;
        }

        return this._writableState.destroyed;
      },
      set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
          return;
        } // backward compatibility, the user is explicitly
        // managing destroyed


        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroy_1.destroy;
    Writable.prototype._undestroy = destroy_1.undestroy;

    Writable.prototype._destroy = function (err, cb) {
      cb(err);
    };

    /*<replacement>*/

    var objectKeys = Object.keys || function (obj) {
      var keys = [];

      for (var key in obj) {
        keys.push(key);
      }

      return keys;
    };
    /*</replacement>*/


    var _stream_duplex = Duplex$1;





    inherits_browser(Duplex$1, _stream_readable);

    {
      // Allow the keys array to be GC'ed.
      var keys = objectKeys(_stream_writable.prototype);

      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex$1.prototype[method]) Duplex$1.prototype[method] = _stream_writable.prototype[method];
      }
    }

    function Duplex$1(options) {
      if (!(this instanceof Duplex$1)) return new Duplex$1(options);
      _stream_readable.call(this, options);
      _stream_writable.call(this, options);
      this.allowHalfOpen = true;

      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;

        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once('end', onend);
        }
      }
    }

    Object.defineProperty(Duplex$1.prototype, 'writableHighWaterMark', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex$1.prototype, 'writableBuffer', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex$1.prototype, 'writableLength', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    }); // the no-half-open enforcer

    function onend() {
      // If the writable side ended, then we're ok.
      if (this._writableState.ended) return; // no more data can be written.
      // But allow more writes to happen in this tick.

      nextTick(onEndNT, this);
    }

    function onEndNT(self) {
      self.end();
    }

    Object.defineProperty(Duplex$1.prototype, 'destroyed', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) {
          return false;
        }

        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
          return;
        } // backward compatibility, the user is explicitly
        // managing destroyed


        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });

    /*<replacement>*/

    var Buffer$3 = safeBuffer.Buffer;
    /*</replacement>*/

    var isEncoding = Buffer$3.isEncoding || function (encoding) {
      encoding = '' + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
          return true;
        default:
          return false;
      }
    };

    function _normalizeEncoding(enc) {
      if (!enc) return 'utf8';
      var retried;
      while (true) {
        switch (enc) {
          case 'utf8':
          case 'utf-8':
            return 'utf8';
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return 'utf16le';
          case 'latin1':
          case 'binary':
            return 'latin1';
          case 'base64':
          case 'ascii':
          case 'hex':
            return enc;
          default:
            if (retried) return; // undefined
            enc = ('' + enc).toLowerCase();
            retried = true;
        }
      }
    }
    // Do not cache `Buffer.isEncoding` when checking encoding names as some
    // modules monkey-patch it to support additional encodings
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== 'string' && (Buffer$3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
      return nenc || enc;
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters.
    var StringDecoder_1 = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case 'utf16le':
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case 'utf8':
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case 'base64':
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer$3.allocUnsafe(nb);
    }

    StringDecoder.prototype.write = function (buf) {
      if (buf.length === 0) return '';
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || '';
    };

    StringDecoder.prototype.end = utf8End;

    // Returns only complete characters in a Buffer
    StringDecoder.prototype.text = utf8Text;

    // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
    StringDecoder.prototype.fillLast = function (buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };

    // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
    // continuation byte. If an invalid byte is detected, -2 is returned.
    function utf8CheckByte(byte) {
      if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
      return byte >> 6 === 0x02 ? -1 : -2;
    }

    // Checks at most 3 bytes at the end of a Buffer in order to detect an
    // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
    // needed to complete the UTF-8 character (if applicable) are returned.
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }

    // Validates as many continuation bytes for a multi-byte UTF-8 character as
    // needed or are available. If we see a non-continuation byte where we expect
    // one, we "replace" the validated continuation bytes we've seen so far with
    // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
    // behavior. The continuation byte check is included three times in the case
    // where all of the continuation bytes for a character exist in the same buffer.
    // It is also done this way as a slight performance increase instead of using a
    // loop.
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
          self.lastNeed = 1;
          return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 0xC0) !== 0x80) {
            self.lastNeed = 2;
            return '\ufffd';
          }
        }
      }
    }

    // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf);
      if (r !== undefined) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }

    // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
    // partial character, the character's bytes are buffered until the required
    // number of bytes are available.
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString('utf8', i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString('utf8', i, end);
    }

    // For UTF-8, a replacement character is added when ending on a partial
    // character.
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) return r + '\ufffd';
      return r;
    }

    // UTF-16LE typically needs two bytes per character, but even if we have an even
    // number of bytes available, we need to check if we end on a leading/high
    // surrogate. In that case, we need to wait for the next two bytes in order to
    // decode the last character properly.
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 0xD800 && c <= 0xDBFF) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString('utf16le', i, buf.length - 1);
    }

    // For UTF-16LE we do not explicitly append special replacement characters if we
    // end on a partial character, we simply let v8 handle that.
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
      }
      return r;
    }

    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString('base64', i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString('base64', i, buf.length - n);
    }

    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
      return r;
    }

    // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }

    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : '';
    }

    var string_decoder = {
    	StringDecoder: StringDecoder_1
    };

    var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;

    function once$1(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        callback.apply(this, args);
      };
    }

    function noop$2() {}

    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }

    function eos(stream, opts, callback) {
      if (typeof opts === 'function') return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once$1(callback || noop$2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;

      var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
      };

      var writableEnded = stream._writableState && stream._writableState.finished;

      var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };

      var readableEnded = stream._readableState && stream._readableState.endEmitted;

      var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };

      var onerror = function onerror(err) {
        callback.call(stream, err);
      };

      var onclose = function onclose() {
        var err;

        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }

        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };

      var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
      };

      if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();else stream.on('request', onrequest);
      } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
      }

      stream.on('end', onend);
      stream.on('finish', onfinish);
      if (opts.error !== false) stream.on('error', onerror);
      stream.on('close', onclose);
      return function () {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
      };
    }

    var endOfStream = eos;

    var _Object$setPrototypeO;

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



    var kLastResolve = Symbol('lastResolve');
    var kLastReject = Symbol('lastReject');
    var kError = Symbol('error');
    var kEnded = Symbol('ended');
    var kLastPromise = Symbol('lastPromise');
    var kHandlePromise = Symbol('handlePromise');
    var kStream = Symbol('stream');

    function createIterResult(value, done) {
      return {
        value: value,
        done: done
      };
    }

    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];

      if (resolve !== null) {
        var data = iter[kStream].read(); // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'

        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }

    function onReadable(iter) {
      // we wait for the next tick, because it might
      // emit an error with process.nextTick
      nextTick(readAndResolve, iter);
    }

    function wrapForNext(lastPromise, iter) {
      return function (resolve, reject) {
        lastPromise.then(function () {
          if (iter[kEnded]) {
            resolve(createIterResult(undefined, true));
            return;
          }

          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }

    var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },

      next: function next() {
        var _this = this;

        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];

        if (error !== null) {
          return Promise.reject(error);
        }

        if (this[kEnded]) {
          return Promise.resolve(createIterResult(undefined, true));
        }

        if (this[kStream].destroyed) {
          // We need to defer via nextTick because if .destroy(err) is
          // called, the error will be emitted via nextTick, and
          // we cannot guarantee that there is no error lingering around
          // waiting to be emitted.
          return new Promise(function (resolve, reject) {
            nextTick(function () {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(undefined, true));
              }
            });
          });
        } // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time


        var lastPromise = this[kLastPromise];
        var promise;

        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          // fast path needed to support multiple this.push()
          // without triggering the next() queue
          var data = this[kStream].read();

          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }

          promise = new Promise(this[kHandlePromise]);
        }

        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty$1(_Object$setPrototypeO, Symbol.asyncIterator, function () {
      return this;
    }), _defineProperty$1(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;

      // destroy(err, cb) is a private API
      // we can guarantee we have that here, because we control the
      // Readable class this is attached to
      return new Promise(function (resolve, reject) {
        _this2[kStream].destroy(null, function (err) {
          if (err) {
            reject(err);
            return;
          }

          resolve(createIterResult(undefined, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);

    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
      var _Object$create;

      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$1(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty$1(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty$1(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty$1(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty$1(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty$1(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();

          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      endOfStream(stream, function (err) {
        if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
          var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
          // returned by next() and store the error

          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }

          iterator[kError] = err;
          return;
        }

        var resolve = iterator[kLastResolve];

        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(undefined, true));
        }

        iterator[kEnded] = true;
      });
      stream.on('readable', onReadable.bind(null, iterator));
      return iterator;
    };

    var async_iterator = createReadableStreamAsyncIterator;

    var fromBrowser = function () {
      throw new Error('Readable.from is not available in the browser')
    };

    var _stream_readable = Readable;
    /*<replacement>*/

    var Duplex$2;
    /*</replacement>*/

    Readable.ReadableState = ReadableState;
    /*<replacement>*/

    var EE = require$$0$1.EventEmitter;

    var EElistenerCount = function EElistenerCount(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/

    /*<replacement>*/



    /*</replacement>*/


    var Buffer$4 = require$$0.Buffer;

    var OurUint8Array$1 = commonjsGlobal.Uint8Array || function () {};

    function _uint8ArrayToBuffer$1(chunk) {
      return Buffer$4.from(chunk);
    }

    function _isUint8Array$1(obj) {
      return Buffer$4.isBuffer(obj) || obj instanceof OurUint8Array$1;
    }
    /*<replacement>*/




    var debug;

    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog('stream');
    } else {
      debug = function debug() {};
    }
    /*</replacement>*/






    var getHighWaterMark$2 = state.getHighWaterMark;

    var _require$codes$1 = errorsBrowser.codes,
        ERR_INVALID_ARG_TYPE$1 = _require$codes$1.ERR_INVALID_ARG_TYPE,
        ERR_STREAM_PUSH_AFTER_EOF = _require$codes$1.ERR_STREAM_PUSH_AFTER_EOF,
        ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$1.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


    var StringDecoder$1;
    var createReadableStreamAsyncIterator$1;
    var from$1;

    inherits_browser(Readable, streamBrowser);

    var errorOrDestroy$2 = destroy_1.errorOrDestroy;
    var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

    function prependListener(emitter, event, fn) {
      // Sadly this is not cacheable as some libraries bundle their own
      // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
      // userland ones.  NEVER DO THIS. This is here only because this code needs
      // to continue to work with older versions of Node.js that do not include
      // the prependListener() method. The goal is to eventually remove this hack.

      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
    }

    function ReadableState(options, stream, isDuplex) {
      Duplex$2 = Duplex$2 || _stream_duplex;
      options = options || {}; // Duplex streams are both readable and writable, but share
      // the same options object.
      // However, some cases require setting options to different
      // values for the readable and the writable sides of the duplex stream.
      // These options can be provided separately as readableXXX and writableXXX.

      if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$2; // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away

      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"

      this.highWaterMark = getHighWaterMark$2(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
      // linked list can remove elements from the beginning faster than
      // array.shift()

      this.buffer = new buffer_list();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.

      this.sync = true; // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.

      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true; // Should close be emitted on destroy. Defaults to true.

      this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

      this.autoDestroy = !!options.autoDestroy; // has it been destroyed

      this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.

      this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

      this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;

      if (options.encoding) {
        if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
        this.decoder = new StringDecoder$1(options.encoding);
        this.encoding = options.encoding;
      }
    }

    function Readable(options) {
      Duplex$2 = Duplex$2 || _stream_duplex;
      if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
      // the ReadableState constructor, at least with V8 6.5

      var isDuplex = this instanceof Duplex$2;
      this._readableState = new ReadableState(options, this, isDuplex); // legacy

      this.readable = true;

      if (options) {
        if (typeof options.read === 'function') this._read = options.read;
        if (typeof options.destroy === 'function') this._destroy = options.destroy;
      }

      streamBrowser.call(this);
    }

    Object.defineProperty(Readable.prototype, 'destroyed', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === undefined) {
          return false;
        }

        return this._readableState.destroyed;
      },
      set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
          return;
        } // backward compatibility, the user is explicitly
        // managing destroyed


        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroy_1.destroy;
    Readable.prototype._undestroy = destroy_1.undestroy;

    Readable.prototype._destroy = function (err, cb) {
      cb(err);
    }; // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.


    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;

      if (!state.objectMode) {
        if (typeof chunk === 'string') {
          encoding = encoding || state.defaultEncoding;

          if (encoding !== state.encoding) {
            chunk = Buffer$4.from(chunk, encoding);
            encoding = '';
          }

          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }

      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    }; // Unshift should *always* be something directly out of read()


    Readable.prototype.unshift = function (chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };

    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug('readableAddChunk', chunk);
      var state = stream._readableState;

      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);

        if (er) {
          errorOrDestroy$2(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer$4.prototype) {
            chunk = _uint8ArrayToBuffer$1(chunk);
          }

          if (addToFront) {
            if (state.endEmitted) errorOrDestroy$2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy$2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;

            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      } // We can push more data if we are below the highWaterMark.
      // Also, if we have no data yet, we can stand some more bytes.
      // This is to work around cases where hwm=0, such as the repl.


      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }

    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit('data', chunk);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }

    function chunkInvalid(state, chunk) {
      var er;

      if (!_isUint8Array$1(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE$1('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
      }

      return er;
    }

    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    }; // backwards compatibility.


    Readable.prototype.setEncoding = function (enc) {
      if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
      var decoder = new StringDecoder$1(enc);
      this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

      this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

      var p = this._readableState.buffer.head;
      var content = '';

      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }

      this._readableState.buffer.clear();

      if (content !== '') this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    }; // Don't raise the hwm > 1GB


    var MAX_HWM = 0x40000000;

    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }

      return n;
    } // This function is designed to be inlinable, so please take care when making
    // changes to the function body.


    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;

      if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      } // If we're asking for more than the current hwm, then raise the hwm.


      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n; // Don't have enough

      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }

      return state.length;
    } // you can override either this method, or the async _read(n) below.


    Readable.prototype.read = function (n) {
      debug('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.

      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }

      n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      } // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
      // if we need a readable event, then we need to do some reading.


      var doRead = state.needReadable;
      debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      } // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.


      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true; // if the length is currently zero, then we *need* a readable event.

        if (state.length === 0) state.needReadable = true; // call internal read method

        this._read(state.highWaterMark);

        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.

        if (!state.reading) n = howMuchToRead(nOrig, state);
      }

      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;

      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }

      if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

        if (nOrig !== n && state.ended) endReadable(this);
      }

      if (ret !== null) this.emit('data', ret);
      return ret;
    };

    function onEofChunk(stream, state) {
      debug('onEofChunk');
      if (state.ended) return;

      if (state.decoder) {
        var chunk = state.decoder.end();

        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }

      state.ended = true;

      if (state.sync) {
        // if we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call
        emitReadable(stream);
      } else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;

        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    } // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.


    function emitReadable(stream) {
      var state = stream._readableState;
      debug('emitReadable', state.needReadable, state.emittedReadable);
      state.needReadable = false;

      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        nextTick(emitReadable_, stream);
      }
    }

    function emitReadable_(stream) {
      var state = stream._readableState;
      debug('emitReadable_', state.destroyed, state.length, state.ended);

      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit('readable');
        state.emittedReadable = false;
      } // The stream needs another readable event if
      // 1. It is not flowing, as the flow mechanism will take
      //    care of it.
      // 2. It is not ended.
      // 3. It is below the highWaterMark, so we can schedule
      //    another readable later.


      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    } // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.


    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
      }
    }

    function maybeReadMore_(stream, state) {
      // Attempt to read more data if we should.
      //
      // The conditions for reading more data are (one of):
      // - Not enough data buffered (state.length < state.highWaterMark). The loop
      //   is responsible for filling the buffer with enough data if such data
      //   is available. If highWaterMark is 0 and we are not in the flowing mode
      //   we should _not_ attempt to buffer any extra data. We'll get more data
      //   when the stream consumer calls read() instead.
      // - No data in the buffer, and the stream is in flowing mode. In this mode
      //   the loop below is responsible for ensuring read() is called. Failing to
      //   call read here would abort the flow and there's no other mechanism for
      //   continuing the flow if the stream consumer has just subscribed to the
      //   'data' event.
      //
      // In addition to the above conditions to keep reading data, the following
      // conditions prevent the data from being read:
      // - The stream has ended (state.ended).
      // - There is already a pending 'read' operation (state.reading). This is a
      //   case where the the stream has called the implementation defined _read()
      //   method, but they are processing the call asynchronously and have _not_
      //   called push() with new data. In this case we skip performing more
      //   read()s. The execution ends in this method again after the _read() ends
      //   up calling push() with more data.
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) // didn't get any data, stop spinning.
          break;
      }

      state.readingMore = false;
    } // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.


    Readable.prototype._read = function (n) {
      errorOrDestroy$2(this, new ERR_METHOD_NOT_IMPLEMENTED$1('_read()'));
    };

    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;

        case 1:
          state.pipes = [state.pipes, dest];
          break;

        default:
          state.pipes.push(dest);
          break;
      }

      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);
      dest.on('unpipe', onunpipe);

      function onunpipe(readable, unpipeInfo) {
        debug('onunpipe');

        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }

      function onend() {
        debug('onend');
        dest.end();
      } // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.


      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      var cleanedUp = false;

      function cleanup() {
        debug('cleanup'); // cleanup event handlers once the pipe is broken

        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', unpipe);
        src.removeListener('data', ondata);
        cleanedUp = true; // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.

        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }

      src.on('data', ondata);

      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        debug('dest.write', ret);

        if (ret === false) {
          // If the user unpiped during `dest.write()`, it is possible
          // to get stuck in a permanently paused state if that write
          // also returned false.
          // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug('false write response, pause', state.awaitDrain);
            state.awaitDrain++;
          }

          src.pause();
        }
      } // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.


      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0) errorOrDestroy$2(dest, er);
      } // Make sure our error handler is attached before userland ones.


      prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }

      dest.once('close', onclose);

      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }

      dest.once('finish', onfinish);

      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      } // tell the dest that it's being piped to


      dest.emit('pipe', src); // start the flow if it hasn't been started already.

      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }

      return dest;
    };

    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;

        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }

    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      }; // if we're not piping anywhere, then do nothing.

      if (state.pipesCount === 0) return this; // just one destination.  most common case.

      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes; // got a match.

        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this, unpipeInfo);
        return this;
      } // slow case. multiple pipe destinations.


      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;

        for (var i = 0; i < len; i++) {
          dests[i].emit('unpipe', this, {
            hasUnpiped: false
          });
        }

        return this;
      } // try to find the right one.


      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit('unpipe', this, unpipeInfo);
      return this;
    }; // set up data events if they are asked for
    // Ensure readable listeners eventually get something


    Readable.prototype.on = function (ev, fn) {
      var res = streamBrowser.prototype.on.call(this, ev, fn);
      var state = this._readableState;

      if (ev === 'data') {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

        if (state.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug('on readable', state.length, state.reading);

          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            nextTick(nReadingNextTick, this);
          }
        }
      }

      return res;
    };

    Readable.prototype.addListener = Readable.prototype.on;

    Readable.prototype.removeListener = function (ev, fn) {
      var res = streamBrowser.prototype.removeListener.call(this, ev, fn);

      if (ev === 'readable') {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        nextTick(updateReadableListening, this);
      }

      return res;
    };

    Readable.prototype.removeAllListeners = function (ev) {
      var res = streamBrowser.prototype.removeAllListeners.apply(this, arguments);

      if (ev === 'readable' || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        nextTick(updateReadableListening, this);
      }

      return res;
    };

    function updateReadableListening(self) {
      var state = self._readableState;
      state.readableListening = self.listenerCount('readable') > 0;

      if (state.resumeScheduled && !state.paused) {
        // flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true; // crude way to check if we should resume
      } else if (self.listenerCount('data') > 0) {
        self.resume();
      }
    }

    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    } // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.


    Readable.prototype.resume = function () {
      var state = this._readableState;

      if (!state.flowing) {
        debug('resume'); // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()

        state.flowing = !state.readableListening;
        resume(this, state);
      }

      state.paused = false;
      return this;
    };

    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
      }
    }

    function resume_(stream, state) {
      debug('resume', state.reading);

      if (!state.reading) {
        stream.read(0);
      }

      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }

    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing);

      if (this._readableState.flowing !== false) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }

      this._readableState.paused = true;
      return this;
    };

    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);

      while (state.flowing && stream.read() !== null) {
      }
    } // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.


    Readable.prototype.wrap = function (stream) {
      var _this = this;

      var state = this._readableState;
      var paused = false;
      stream.on('end', function () {
        debug('wrapped end');

        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }

        _this.push(null);
      });
      stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

        var ret = _this.push(chunk);

        if (!ret) {
          paused = true;
          stream.pause();
        }
      }); // proxy all the other methods.
      // important when wrapping filters and duplexes.

      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      } // proxy certain important events.


      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      } // when we try to consume some more bytes, simply unpause the
      // underlying stream.


      this._read = function (n) {
        debug('wrapped _read', n);

        if (paused) {
          paused = false;
          stream.resume();
        }
      };

      return this;
    };

    if (typeof Symbol === 'function') {
      Readable.prototype[Symbol.asyncIterator] = function () {
        if (createReadableStreamAsyncIterator$1 === undefined) {
          createReadableStreamAsyncIterator$1 = async_iterator;
        }

        return createReadableStreamAsyncIterator$1(this);
      };
    }

    Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, 'readableBuffer', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, 'readableFlowing', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    }); // exposed for testing purposes only.

    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, 'readableLength', {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    }); // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.

    function fromList(n, state) {
      // nothing buffered
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        // read part of list
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }

    function endReadable(stream) {
      var state = stream._readableState;
      debug('endReadable', state.endEmitted);

      if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
      }
    }

    function endReadableNT(state, stream) {
      debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');

        if (state.autoDestroy) {
          // In case of duplex streams we need a way to detect
          // if the writable side is ready for autoDestroy as well
          var wState = stream._writableState;

          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }

    if (typeof Symbol === 'function') {
      Readable.from = function (iterable, opts) {
        if (from$1 === undefined) {
          from$1 = fromBrowser;
        }

        return from$1(Readable, iterable, opts);
      };
    }

    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }

      return -1;
    }

    var _stream_transform = Transform;

    var _require$codes$2 = errorsBrowser.codes,
        ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK,
        ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$2.ERR_TRANSFORM_ALREADY_TRANSFORMING,
        ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$2.ERR_TRANSFORM_WITH_LENGTH_0;



    inherits_browser(Transform, _stream_duplex);

    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;

      if (cb === null) {
        return this.emit('error', new ERR_MULTIPLE_CALLBACK$1());
      }

      ts.writechunk = null;
      ts.writecb = null;
      if (data != null) // single equals check for both `null` and `undefined`
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;

      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }

    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      _stream_duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }; // start out asking for a readable event once data is transformed.

      this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.

      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
      } // When the writable side finishes, then flush out anything remaining.


      this.on('prefinish', prefinish$1);
    }

    function prefinish$1() {
      var _this = this;

      if (typeof this._flush === 'function' && !this._readableState.destroyed) {
        this._flush(function (er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }

    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return _stream_duplex.prototype.push.call(this, chunk, encoding);
    }; // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.


    Transform.prototype._transform = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED$2('_transform()'));
    };

    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;

      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    }; // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.


    Transform.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;

        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    Transform.prototype._destroy = function (err, cb) {
      _stream_duplex.prototype._destroy.call(this, err, function (err2) {
        cb(err2);
      });
    };

    function done(stream, er, data) {
      if (er) return stream.emit('error', er);
      if (data != null) // single equals check for both `null` and `undefined`
        stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided

      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }

    var _stream_passthrough = PassThrough;



    inherits_browser(PassThrough, _stream_transform);

    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      _stream_transform.call(this, options);
    }

    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };

    var eos$1;

    function once$2(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }

    var _require$codes$3 = errorsBrowser.codes,
        ERR_MISSING_ARGS = _require$codes$3.ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED;

    function noop$3(err) {
      // Rethrow the error if it exists to avoid swallowing it
      if (err) throw err;
    }

    function isRequest$1(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }

    function destroyer(stream, reading, writing, callback) {
      callback = once$2(callback);
      var closed = false;
      stream.on('close', function () {
        closed = true;
      });
      if (eos$1 === undefined) eos$1 = endOfStream;
      eos$1(stream, {
        readable: reading,
        writable: writing
      }, function (err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function (err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true; // request.destroy just do .end - .abort is what we want

        if (isRequest$1(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED$1('pipe'));
      };
    }

    function call(fn) {
      fn();
    }

    function pipe(from, to) {
      return from.pipe(to);
    }

    function popCallback(streams) {
      if (!streams.length) return noop$3;
      if (typeof streams[streams.length - 1] !== 'function') return noop$3;
      return streams.pop();
    }

    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }

      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];

      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS('streams');
      }

      var error;
      var destroys = streams.map(function (stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function (err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }

    var pipeline_1 = pipeline;

    var readableBrowser = createCommonjsModule(function (module, exports) {
    exports = module.exports = _stream_readable;
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = _stream_writable;
    exports.Duplex = _stream_duplex;
    exports.Transform = _stream_transform;
    exports.PassThrough = _stream_passthrough;
    exports.finished = endOfStream;
    exports.pipeline = pipeline_1;
    });

    var Buffer$5 = safeBuffer.Buffer;
    var Transform$1 = readableBrowser.Transform;


    function throwIfNotStringOrBuffer (val, prefix) {
      if (!Buffer$5.isBuffer(val) && typeof val !== 'string') {
        throw new TypeError(prefix + ' must be a string or a buffer')
      }
    }

    function HashBase (blockSize) {
      Transform$1.call(this);

      this._block = Buffer$5.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];

      this._finalized = false;
    }

    inherits_browser(HashBase, Transform$1);

    HashBase.prototype._transform = function (chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }

      callback(error);
    };

    HashBase.prototype._flush = function (callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }

      callback(error);
    };

    HashBase.prototype.update = function (data, encoding) {
      throwIfNotStringOrBuffer(data, 'Data');
      if (this._finalized) throw new Error('Digest already called')
      if (!Buffer$5.isBuffer(data)) data = Buffer$5.from(data, encoding);

      // consume data
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length) block[this._blockOffset++] = data[offset++];

      // update length
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = (this._length[j] / 0x0100000000) | 0;
        if (carry > 0) this._length[j] -= 0x0100000000 * carry;
      }

      return this
    };

    HashBase.prototype._update = function () {
      throw new Error('_update is not implemented')
    };

    HashBase.prototype.digest = function (encoding) {
      if (this._finalized) throw new Error('Digest already called')
      this._finalized = true;

      var digest = this._digest();
      if (encoding !== undefined) digest = digest.toString(encoding);

      // reset state
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i) this._length[i] = 0;

      return digest
    };

    HashBase.prototype._digest = function () {
      throw new Error('_digest is not implemented')
    };

    var hashBase = HashBase;

    var Buffer$6 = safeBuffer.Buffer;

    var ARRAY16 = new Array(16);

    function MD5 () {
      hashBase.call(this, 64);

      // state
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
    }

    inherits_browser(MD5, hashBase);

    MD5.prototype._update = function () {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;

      a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
      d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
      c = fnF(c, d, a, b, M[2], 0x242070db, 17);
      b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
      a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
      d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
      c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
      b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
      a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
      d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
      c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
      b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
      a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
      d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
      c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
      b = fnF(b, c, d, a, M[15], 0x49b40821, 22);

      a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
      d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
      c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
      b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
      a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
      d = fnG(d, a, b, c, M[10], 0x02441453, 9);
      c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
      b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
      a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
      d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
      c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
      b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
      a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
      d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
      c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
      b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);

      a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
      d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
      c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
      b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
      a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
      d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
      c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
      b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
      a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
      d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
      c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
      b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
      a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
      d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
      c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
      b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);

      a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
      d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
      c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
      b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
      a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
      d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
      c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
      b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
      a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
      d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
      c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
      b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
      a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
      d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
      c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
      b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);

      this._a = (this._a + a) | 0;
      this._b = (this._b + b) | 0;
      this._c = (this._c + c) | 0;
      this._d = (this._d + d) | 0;
    };

    MD5.prototype._digest = function () {
      // create padding and handle blocks
      this._block[this._blockOffset++] = 0x80;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }

      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();

      // produce result
      var buffer = Buffer$6.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer
    };

    function rotl (x, n) {
      return (x << n) | (x >>> (32 - n))
    }

    function fnF (a, b, c, d, m, k, s) {
      return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
    }

    function fnG (a, b, c, d, m, k, s) {
      return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
    }

    function fnH (a, b, c, d, m, k, s) {
      return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
    }

    function fnI (a, b, c, d, m, k, s) {
      return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
    }

    var md5_js = MD5;

    var Buffer$7 = require$$0.Buffer;



    var ARRAY16$1 = new Array(16);

    var zl = [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
      7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
      3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
      1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
      4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
    ];

    var zr = [
      5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
      6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
      15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
      8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
      12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
    ];

    var sl = [
      11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
      7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
      11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
      11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
      9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
    ];

    var sr = [
      8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
      9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
      9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
      15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
      8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
    ];

    var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
    var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

    function RIPEMD160 () {
      hashBase.call(this, 64);

      // state
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;
    }

    inherits_browser(RIPEMD160, hashBase);

    RIPEMD160.prototype._update = function () {
      var words = ARRAY16$1;
      for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;

      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;

      // computation
      for (var i = 0; i < 80; i += 1) {
        var tl;
        var tr;
        if (i < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
          tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
          tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
          tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
          tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else { // if (i<80) {
          tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
          tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }

        al = el;
        el = dl;
        dl = rotl$1(cl, 10);
        cl = bl;
        bl = tl;

        ar = er;
        er = dr;
        dr = rotl$1(cr, 10);
        cr = br;
        br = tr;
      }

      // update state
      var t = (this._b + cl + dr) | 0;
      this._b = (this._c + dl + er) | 0;
      this._c = (this._d + el + ar) | 0;
      this._d = (this._e + al + br) | 0;
      this._e = (this._a + bl + cr) | 0;
      this._a = t;
    };

    RIPEMD160.prototype._digest = function () {
      // create padding and handle blocks
      this._block[this._blockOffset++] = 0x80;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }

      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();

      // produce result
      var buffer = Buffer$7.alloc ? Buffer$7.alloc(20) : new Buffer$7(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer
    };

    function rotl$1 (x, n) {
      return (x << n) | (x >>> (32 - n))
    }

    function fn1 (a, b, c, d, e, m, k, s) {
      return (rotl$1((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
    }

    function fn2 (a, b, c, d, e, m, k, s) {
      return (rotl$1((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
    }

    function fn3 (a, b, c, d, e, m, k, s) {
      return (rotl$1((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
    }

    function fn4 (a, b, c, d, e, m, k, s) {
      return (rotl$1((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
    }

    function fn5 (a, b, c, d, e, m, k, s) {
      return (rotl$1((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
    }

    var ripemd160 = RIPEMD160;

    var Buffer$8 = safeBuffer.Buffer;

    // prototype class for hash functions
    function Hash (blockSize, finalSize) {
      this._block = Buffer$8.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }

    Hash.prototype.update = function (data, enc) {
      if (typeof data === 'string') {
        enc = enc || 'utf8';
        data = Buffer$8.from(data, enc);
      }

      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;

      for (var offset = 0; offset < length;) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);

        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }

        accum += remainder;
        offset += remainder;

        if ((accum % blockSize) === 0) {
          this._update(block);
        }
      }

      this._len += length;
      return this
    };

    Hash.prototype.digest = function (enc) {
      var rem = this._len % this._blockSize;

      this._block[rem] = 0x80;

      // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
      // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
      this._block.fill(0, rem + 1);

      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }

      var bits = this._len * 8;

      // uint32
      if (bits <= 0xffffffff) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);

      // uint64
      } else {
        var lowBits = (bits & 0xffffffff) >>> 0;
        var highBits = (bits - lowBits) / 0x100000000;

        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }

      this._update(this._block);
      var hash = this._hash();

      return enc ? hash.toString(enc) : hash
    };

    Hash.prototype._update = function () {
      throw new Error('_update must be implemented by subclass')
    };

    var hash$1 = Hash;

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
     * in FIPS PUB 180-1
     * This source code is derived from sha1.js of the same repository.
     * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
     * operation was added.
     */

    var Buffer$9 = safeBuffer.Buffer;

    var K = [
      0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
    ];

    var W = new Array(80);

    function Sha () {
      this.init();
      this._w = W;

      hash$1.call(this, 64, 56);
    }

    inherits_browser(Sha, hash$1);

    Sha.prototype.init = function () {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;

      return this
    };

    function rotl5 (num) {
      return (num << 5) | (num >>> 27)
    }

    function rotl30 (num) {
      return (num << 30) | (num >>> 2)
    }

    function ft (s, b, c, d) {
      if (s === 0) return (b & c) | ((~b) & d)
      if (s === 2) return (b & c) | (b & d) | (c & d)
      return b ^ c ^ d
    }

    Sha.prototype._update = function (M) {
      var W = this._w;

      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;

      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }

      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };

    Sha.prototype._hash = function () {
      var H = Buffer$9.allocUnsafe(20);

      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);

      return H
    };

    var sha = Sha;

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS PUB 180-1
     * Version 2.1a Copyright Paul Johnston 2000 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */

    var Buffer$a = safeBuffer.Buffer;

    var K$1 = [
      0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
    ];

    var W$1 = new Array(80);

    function Sha1 () {
      this.init();
      this._w = W$1;

      hash$1.call(this, 64, 56);
    }

    inherits_browser(Sha1, hash$1);

    Sha1.prototype.init = function () {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;

      return this
    };

    function rotl1 (num) {
      return (num << 1) | (num >>> 31)
    }

    function rotl5$1 (num) {
      return (num << 5) | (num >>> 27)
    }

    function rotl30$1 (num) {
      return (num << 30) | (num >>> 2)
    }

    function ft$1 (s, b, c, d) {
      if (s === 0) return (b & c) | ((~b) & d)
      if (s === 2) return (b & c) | (b & d) | (c & d)
      return b ^ c ^ d
    }

    Sha1.prototype._update = function (M) {
      var W = this._w;

      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;

      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = (rotl5$1(a) + ft$1(s, b, c, d) + e + W[j] + K$1[s]) | 0;

        e = d;
        d = c;
        c = rotl30$1(b);
        b = a;
        a = t;
      }

      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };

    Sha1.prototype._hash = function () {
      var H = Buffer$a.allocUnsafe(20);

      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);

      return H
    };

    var sha1 = Sha1;

    /**
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
     * in FIPS 180-2
     * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     *
     */

    var Buffer$b = safeBuffer.Buffer;

    var K$2 = [
      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
    ];

    var W$2 = new Array(64);

    function Sha256 () {
      this.init();

      this._w = W$2; // new Array(64)

      hash$1.call(this, 64, 56);
    }

    inherits_browser(Sha256, hash$1);

    Sha256.prototype.init = function () {
      this._a = 0x6a09e667;
      this._b = 0xbb67ae85;
      this._c = 0x3c6ef372;
      this._d = 0xa54ff53a;
      this._e = 0x510e527f;
      this._f = 0x9b05688c;
      this._g = 0x1f83d9ab;
      this._h = 0x5be0cd19;

      return this
    };

    function ch (x, y, z) {
      return z ^ (x & (y ^ z))
    }

    function maj (x, y, z) {
      return (x & y) | (z & (x | y))
    }

    function sigma0 (x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
    }

    function sigma1 (x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
    }

    function gamma0 (x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
    }

    function gamma1 (x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
    }

    Sha256.prototype._update = function (M) {
      var W = this._w;

      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;

      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;

      for (var j = 0; j < 64; ++j) {
        var T1 = (h + sigma1(e) + ch(e, f, g) + K$2[j] + W[j]) | 0;
        var T2 = (sigma0(a) + maj(a, b, c)) | 0;

        h = g;
        g = f;
        f = e;
        e = (d + T1) | 0;
        d = c;
        c = b;
        b = a;
        a = (T1 + T2) | 0;
      }

      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
      this._f = (f + this._f) | 0;
      this._g = (g + this._g) | 0;
      this._h = (h + this._h) | 0;
    };

    Sha256.prototype._hash = function () {
      var H = Buffer$b.allocUnsafe(32);

      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);

      return H
    };

    var sha256 = Sha256;

    /**
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
     * in FIPS 180-2
     * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     *
     */

    var Buffer$c = safeBuffer.Buffer;

    var W$3 = new Array(64);

    function Sha224 () {
      this.init();

      this._w = W$3; // new Array(64)

      hash$1.call(this, 64, 56);
    }

    inherits_browser(Sha224, sha256);

    Sha224.prototype.init = function () {
      this._a = 0xc1059ed8;
      this._b = 0x367cd507;
      this._c = 0x3070dd17;
      this._d = 0xf70e5939;
      this._e = 0xffc00b31;
      this._f = 0x68581511;
      this._g = 0x64f98fa7;
      this._h = 0xbefa4fa4;

      return this
    };

    Sha224.prototype._hash = function () {
      var H = Buffer$c.allocUnsafe(28);

      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);

      return H
    };

    var sha224 = Sha224;

    var Buffer$d = safeBuffer.Buffer;

    var K$3 = [
      0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
      0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
      0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
      0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
      0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
      0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
      0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
      0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
      0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
      0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
      0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
      0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
      0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
      0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
      0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
      0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
      0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
      0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
      0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
      0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
      0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
      0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
      0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
      0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
      0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
      0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
      0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
      0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
      0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
      0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
      0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
      0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
      0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
      0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
      0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
      0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
      0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
      0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
      0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
      0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    ];

    var W$4 = new Array(160);

    function Sha512 () {
      this.init();
      this._w = W$4;

      hash$1.call(this, 128, 112);
    }

    inherits_browser(Sha512, hash$1);

    Sha512.prototype.init = function () {
      this._ah = 0x6a09e667;
      this._bh = 0xbb67ae85;
      this._ch = 0x3c6ef372;
      this._dh = 0xa54ff53a;
      this._eh = 0x510e527f;
      this._fh = 0x9b05688c;
      this._gh = 0x1f83d9ab;
      this._hh = 0x5be0cd19;

      this._al = 0xf3bcc908;
      this._bl = 0x84caa73b;
      this._cl = 0xfe94f82b;
      this._dl = 0x5f1d36f1;
      this._el = 0xade682d1;
      this._fl = 0x2b3e6c1f;
      this._gl = 0xfb41bd6b;
      this._hl = 0x137e2179;

      return this
    };

    function Ch (x, y, z) {
      return z ^ (x & (y ^ z))
    }

    function maj$1 (x, y, z) {
      return (x & y) | (z & (x | y))
    }

    function sigma0$1 (x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
    }

    function sigma1$1 (x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
    }

    function Gamma0 (x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
    }

    function Gamma0l (x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
    }

    function Gamma1 (x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
    }

    function Gamma1l (x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
    }

    function getCarry (a, b) {
      return (a >>> 0) < (b >>> 0) ? 1 : 0
    }

    Sha512.prototype._update = function (M) {
      var W = this._w;

      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;

      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;

      for (var i = 0; i < 32; i += 2) {
        W[i] = M.readInt32BE(i * 4);
        W[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W[i - 15 * 2];
        var xl = W[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);

        xh = W[i - 2 * 2];
        xl = W[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);

        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
        var Wi7h = W[i - 7 * 2];
        var Wi7l = W[i - 7 * 2 + 1];

        var Wi16h = W[i - 16 * 2];
        var Wi16l = W[i - 16 * 2 + 1];

        var Wil = (gamma0l + Wi7l) | 0;
        var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
        Wil = (Wil + gamma1l) | 0;
        Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
        Wil = (Wil + Wi16l) | 0;
        Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

        W[i] = Wih;
        W[i + 1] = Wil;
      }

      for (var j = 0; j < 160; j += 2) {
        Wih = W[j];
        Wil = W[j + 1];

        var majh = maj$1(ah, bh, ch);
        var majl = maj$1(al, bl, cl);

        var sigma0h = sigma0$1(ah, al);
        var sigma0l = sigma0$1(al, ah);
        var sigma1h = sigma1$1(eh, el);
        var sigma1l = sigma1$1(el, eh);

        // t1 = h + sigma1 + ch + K[j] + W[j]
        var Kih = K$3[j];
        var Kil = K$3[j + 1];

        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);

        var t1l = (hl + sigma1l) | 0;
        var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
        t1l = (t1l + chl) | 0;
        t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
        t1l = (t1l + Kil) | 0;
        t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
        t1l = (t1l + Wil) | 0;
        t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

        // t2 = sigma0 + maj
        var t2l = (sigma0l + majl) | 0;
        var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = (dl + t1l) | 0;
        eh = (dh + t1h + getCarry(el, dl)) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = (t1l + t2l) | 0;
        ah = (t1h + t2h + getCarry(al, t1l)) | 0;
      }

      this._al = (this._al + al) | 0;
      this._bl = (this._bl + bl) | 0;
      this._cl = (this._cl + cl) | 0;
      this._dl = (this._dl + dl) | 0;
      this._el = (this._el + el) | 0;
      this._fl = (this._fl + fl) | 0;
      this._gl = (this._gl + gl) | 0;
      this._hl = (this._hl + hl) | 0;

      this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
      this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
      this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
      this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
      this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
      this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
      this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
      this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
    };

    Sha512.prototype._hash = function () {
      var H = Buffer$d.allocUnsafe(64);

      function writeInt64BE (h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }

      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);

      return H
    };

    var sha512 = Sha512;

    var Buffer$e = safeBuffer.Buffer;

    var W$5 = new Array(160);

    function Sha384 () {
      this.init();
      this._w = W$5;

      hash$1.call(this, 128, 112);
    }

    inherits_browser(Sha384, sha512);

    Sha384.prototype.init = function () {
      this._ah = 0xcbbb9d5d;
      this._bh = 0x629a292a;
      this._ch = 0x9159015a;
      this._dh = 0x152fecd8;
      this._eh = 0x67332667;
      this._fh = 0x8eb44a87;
      this._gh = 0xdb0c2e0d;
      this._hh = 0x47b5481d;

      this._al = 0xc1059ed8;
      this._bl = 0x367cd507;
      this._cl = 0x3070dd17;
      this._dl = 0xf70e5939;
      this._el = 0xffc00b31;
      this._fl = 0x68581511;
      this._gl = 0x64f98fa7;
      this._hl = 0xbefa4fa4;

      return this
    };

    Sha384.prototype._hash = function () {
      var H = Buffer$e.allocUnsafe(48);

      function writeInt64BE (h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }

      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);

      return H
    };

    var sha384 = Sha384;

    var sha_js = createCommonjsModule(function (module) {
    var exports = module.exports = function SHA (algorithm) {
      algorithm = algorithm.toLowerCase();

      var Algorithm = exports[algorithm];
      if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

      return new Algorithm()
    };

    exports.sha = sha;
    exports.sha1 = sha1;
    exports.sha224 = sha224;
    exports.sha256 = sha256;
    exports.sha384 = sha384;
    exports.sha512 = sha512;
    });

    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    BufferList.prototype.push = function (v) {
      var entry = { data: v, next: null };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    };

    BufferList.prototype.unshift = function (v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    };

    BufferList.prototype.shift = function () {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    };

    BufferList.prototype.clear = function () {
      this.head = this.tail = null;
      this.length = 0;
    };

    BufferList.prototype.join = function (s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }return ret;
    };

    BufferList.prototype.concat = function (n) {
      if (this.length === 0) return Buffer.alloc(0);
      if (this.length === 1) return this.head.data;
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };

    // Copyright Joyent, Inc. and other Node contributors.
    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         };


    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    function StringDecoder$2(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }

      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    }

    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder$2.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;

        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;

        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }

        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);

        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;

        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }

      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);

      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }

      charStr += buffer.toString(this.encoding, 0, end);

      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }

      // or just emit the charStr
      return charStr;
    };

    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder$2.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;

      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];

        // See http://en.wikipedia.org/wiki/UTF-8#Description

        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }

        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }

        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };

    StringDecoder$2.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);

      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }

      return res;
    };

    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }

    var stringDecoder = /*#__PURE__*/Object.freeze({
        __proto__: null,
        StringDecoder: StringDecoder$2
    });

    Readable$1.ReadableState = ReadableState$1;

    var debug$1 = debuglog('stream');
    inherits$1(Readable$1, EventEmitter);

    function prependListener$1(emitter, event, fn) {
      // Sadly this is not cacheable as some libraries bundle their own
      // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn);
      } else {
        // This is a hack to make sure that our error handler is attached before any
        // userland ones.  NEVER DO THIS. This is here only because this code needs
        // to continue to work with older versions of Node.js that do not include
        // the prependListener() method. The goal is to eventually remove this hack.
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
    }
    function listenerCount$1 (emitter, type) {
      return emitter.listeners(type).length;
    }
    function ReadableState$1(options, stream) {

      options = options || {};

      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex$3) this.objectMode = this.objectMode || !!options.readableObjectMode;

      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      // A linked list is used to store data chunks instead of an array because the
      // linked list can remove elements from the beginning faster than
      // array.shift()
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;

      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;

      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;

      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        this.decoder = new StringDecoder$2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable$1(options) {

      if (!(this instanceof Readable$1)) return new Readable$1(options);

      this._readableState = new ReadableState$1(options, this);

      // legacy
      this.readable = true;

      if (options && typeof options.read === 'function') this._read = options.read;

      EventEmitter.call(this);
    }

    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable$1.prototype.push = function (chunk, encoding) {
      var state = this._readableState;

      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = '';
        }
      }

      return readableAddChunk$1(this, state, chunk, encoding, false);
    };

    // Unshift should *always* be something directly out of read()
    Readable$1.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk$1(this, state, chunk, '', true);
    };

    Readable$1.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    };

    function readableAddChunk$1(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid$1(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk$1(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var _e = new Error('stream.unshift() after end event');
          stream.emit('error', _e);
        } else {
          var skipAdd;
          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk);
            skipAdd = !state.objectMode && chunk.length === 0;
          }

          if (!addToFront) state.reading = false;

          // Don't add to the buffer if we've decoded to an empty string chunk and
          // we're not in object mode
          if (!skipAdd) {
            // if we want the data now, just emit it.
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

              if (state.needReadable) emitReadable$1(stream);
            }
          }

          maybeReadMore$1(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }

      return needMoreData(state);
    }

    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }

    // backwards compatibility.
    Readable$1.prototype.setEncoding = function (enc) {
      this._readableState.decoder = new StringDecoder$2(enc);
      this._readableState.encoding = enc;
      return this;
    };

    // Don't raise the hwm > 8MB
    var MAX_HWM$1 = 0x800000;
    function computeNewHighWaterMark$1(n) {
      if (n >= MAX_HWM$1) {
        n = MAX_HWM$1;
      } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }

    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function howMuchToRead$1(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      }
      // If we're asking for more than the current hwm, then raise the hwm.
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark$1(n);
      if (n <= state.length) return n;
      // Don't have enough
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }

    // you can override either this method, or the async _read(n) below.
    Readable$1.prototype.read = function (n) {
      debug$1('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;

      if (n !== 0) state.emittedReadable = false;

      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug$1('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable$1(this);else emitReadable$1(this);
        return null;
      }

      n = howMuchToRead$1(n, state);

      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable$1(this);
        return null;
      }

      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.

      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug$1('need readable', doRead);

      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug$1('length less than watermark', doRead);
      }

      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug$1('reading or ended', doRead);
      } else if (doRead) {
        debug$1('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead$1(nOrig, state);
      }

      var ret;
      if (n > 0) ret = fromList$1(n, state);else ret = null;

      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }

      if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;

        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable$1(this);
      }

      if (ret !== null) this.emit('data', ret);

      return ret;
    };

    function chunkInvalid$1(state, chunk) {
      var er = null;
      if (!isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }

    function onEofChunk$1(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;

      // emit 'readable' now to make sure it gets picked up.
      emitReadable$1(stream);
    }

    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable$1(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug$1('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) nextTick(emitReadable_$1, stream);else emitReadable_$1(stream);
      }
    }

    function emitReadable_$1(stream) {
      debug$1('emit readable');
      stream.emit('readable');
      flow$1(stream);
    }

    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore$1(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        nextTick(maybeReadMore_$1, stream, state);
      }
    }

    function maybeReadMore_$1(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug$1('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;else len = state.length;
      }
      state.readingMore = false;
    }

    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable$1.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };

    Readable$1.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug$1('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

      var doEnd = (!pipeOpts || pipeOpts.end !== false);

      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug$1('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }

      function onend() {
        debug$1('onend');
        dest.end();
      }

      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain$1(src);
      dest.on('drain', ondrain);

      var cleanedUp = false;
      function cleanup() {
        debug$1('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);

        cleanedUp = true;

        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }

      // If the user pushes more data while we're writing to dest then we'll end up
      // in ondata again. However, we only want to increase awaitDrain once because
      // dest will only emit one 'drain' event for the multiple writes.
      // => Introduce a guard on increasing awaitDrain.
      var increasedAwaitDrain = false;
      src.on('data', ondata);
      function ondata(chunk) {
        debug$1('ondata');
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          // If the user unpiped during `dest.write()`, it is possible
          // to get stuck in a permanently paused state if that write
          // also returned false.
          // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf$1(state.pipes, dest) !== -1) && !cleanedUp) {
            debug$1('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }

      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug$1('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (listenerCount$1(dest, 'error') === 0) dest.emit('error', er);
      }

      // Make sure our error handler is attached before userland ones.
      prependListener$1(dest, 'error', onerror);

      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug$1('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);

      function unpipe() {
        debug$1('unpipe');
        src.unpipe(dest);
      }

      // tell the dest that it's being piped to
      dest.emit('pipe', src);

      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug$1('pipe resume');
        src.resume();
      }

      return dest;
    };

    function pipeOnDrain$1(src) {
      return function () {
        var state = src._readableState;
        debug$1('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && src.listeners('data').length) {
          state.flowing = true;
          flow$1(src);
        }
      };
    }

    Readable$1.prototype.unpipe = function (dest) {
      var state = this._readableState;

      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0) return this;

      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;

        if (!dest) dest = state.pipes;

        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      }

      // slow case. multiple pipe destinations.

      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;

        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit('unpipe', this);
        }return this;
      }

      // try to find the right one.
      var i = indexOf$1(state.pipes, dest);
      if (i === -1) return this;

      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];

      dest.emit('unpipe', this);

      return this;
    };

    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable$1.prototype.on = function (ev, fn) {
      var res = EventEmitter.prototype.on.call(this, ev, fn);

      if (ev === 'data') {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick$1, this);
          } else if (state.length) {
            emitReadable$1(this);
          }
        }
      }

      return res;
    };
    Readable$1.prototype.addListener = Readable$1.prototype.on;

    function nReadingNextTick$1(self) {
      debug$1('readable nexttick read 0');
      self.read(0);
    }

    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable$1.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug$1('resume');
        state.flowing = true;
        resume$1(this, state);
      }
      return this;
    };

    function resume$1(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_$1, stream, state);
      }
    }

    function resume_$1(stream, state) {
      if (!state.reading) {
        debug$1('resume read 0');
        stream.read(0);
      }

      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit('resume');
      flow$1(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }

    Readable$1.prototype.pause = function () {
      debug$1('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug$1('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };

    function flow$1(stream) {
      var state = stream._readableState;
      debug$1('flow', state.flowing);
      while (state.flowing && stream.read() !== null) {}
    }

    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable$1.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;

      var self = this;
      stream.on('end', function () {
        debug$1('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }

        self.push(null);
      });

      stream.on('data', function (chunk) {
        debug$1('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);

        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });

      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }

      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });

      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function (n) {
        debug$1('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };

      return self;
    };

    // exposed for testing purposes only.
    Readable$1._fromList = fromList$1;

    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromList$1(n, state) {
      // nothing buffered
      if (state.length === 0) return null;

      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
      }

      return ret;
    }

    // Extracts only enough buffered data to satisfy the amount requested.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
      } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }

    // Copies a specified amount of characters from the list of buffered data
    // chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    // Copies a specified amount of bytes from the list of buffered data chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBuffer(n, list) {
      var ret = Buffer.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    function endReadable$1(stream) {
      var state = stream._readableState;

      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

      if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT$1, state, stream);
      }
    }

    function endReadableNT$1(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }

    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }

    function indexOf$1(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }

    // A bit simpler than readable streams.
    Writable$1.WritableState = WritableState$1;
    inherits$1(Writable$1, EventEmitter);

    function nop$1() {}

    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }

    function WritableState$1(options, stream) {
      Object.defineProperty(this, 'buffer', {
        get: deprecate(function () {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
      });
      options = options || {};

      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex$3) this.objectMode = this.objectMode || !!options.writableObjectMode;

      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;

      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;

      // a flag to see when we're in the middle of a write.
      this.writing = false;

      // when true all writes will be buffered until .uncork() call
      this.corked = 0;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;

      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function (er) {
        onwrite$1(stream, er);
      };

      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;

      // the amount that is being written when _write is called.
      this.writelen = 0;

      this.bufferedRequest = null;
      this.lastBufferedRequest = null;

      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;

      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;

      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;

      // count buffered requests
      this.bufferedRequestCount = 0;

      // allocate the first CorkedRequest, there is always
      // one allocated and free to use, and we maintain at most two
      this.corkedRequestsFree = new CorkedRequest$1(this);
    }

    WritableState$1.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    function Writable$1(options) {

      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable$1) && !(this instanceof Duplex$3)) return new Writable$1(options);

      this._writableState = new WritableState$1(options, this);

      // legacy.
      this.writable = true;

      if (options) {
        if (typeof options.write === 'function') this._write = options.write;

        if (typeof options.writev === 'function') this._writev = options.writev;
      }

      EventEmitter.call(this);
    }

    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable$1.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe, not readable'));
    };

    function writeAfterEnd$1(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      nextTick(cb, er);
    }

    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk$1(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      // Always throw error if a null is written
      // if we are not in object mode then throw
      // if it is not a buffer, string, or undefined.
      if (chunk === null) {
        er = new TypeError('May not write null values to stream');
      } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      if (er) {
        stream.emit('error', er);
        nextTick(cb, er);
        valid = false;
      }
      return valid;
    }

    Writable$1.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;

      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

      if (typeof cb !== 'function') cb = nop$1;

      if (state.ended) writeAfterEnd$1(this, cb);else if (validChunk$1(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer$1(this, state, chunk, encoding, cb);
      }

      return ret;
    };

    Writable$1.prototype.cork = function () {
      var state = this._writableState;

      state.corked++;
    };

    Writable$1.prototype.uncork = function () {
      var state = this._writableState;

      if (state.corked) {
        state.corked--;

        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer$1(this, state);
      }
    };

    Writable$1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };

    function decodeChunk$1(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer.from(chunk, encoding);
      }
      return chunk;
    }

    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer$1(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk$1(state, chunk, encoding);

      if (Buffer.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;

      state.length += len;

      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret) state.needDrain = true;

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite$1(stream, state, false, len, chunk, encoding, cb);
      }

      return ret;
    }

    function doWrite$1(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }

    function onwriteError$1(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) nextTick(cb, er);else cb(er);

      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }

    function onwriteStateUpdate$1(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }

    function onwrite$1(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;

      onwriteStateUpdate$1(state);

      if (er) onwriteError$1(stream, state, sync, er, cb);else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish$1(state);

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer$1(stream, state);
        }

        if (sync) {
          /*<replacement>*/
            nextTick(afterWrite$1, stream, state, finished, cb);
          /*</replacement>*/
        } else {
            afterWrite$1(stream, state, finished, cb);
          }
      }
    }

    function afterWrite$1(stream, state, finished, cb) {
      if (!finished) onwriteDrain$1(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe$1(stream, state);
    }

    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain$1(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }

    // if there's something in the buffer waiting, then process it
    function clearBuffer$1(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;

      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;

        var count = 0;
        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }

        doWrite$1(stream, state, true, state.length, buffer, '', holder.finish);

        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest$1(state);
        }
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;

          doWrite$1(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }

        if (entry === null) state.lastBufferedRequest = null;
      }

      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }

    Writable$1.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };

    Writable$1.prototype._writev = null;

    Writable$1.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;

      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }

      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished) endWritable$1(this, state, cb);
    };

    function needFinish$1(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }

    function prefinish$2(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }

    function finishMaybe$1(stream, state) {
      var need = needFinish$1(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish$2(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish$2(stream, state);
        }
      }
      return need;
    }

    function endWritable$1(stream, state, cb) {
      state.ending = true;
      finishMaybe$1(stream, state);
      if (cb) {
        if (state.finished) nextTick(cb);else stream.once('finish', cb);
      }
      state.ended = true;
      stream.writable = false;
    }

    // It seems a linked list but it is not
    // there will be only 2 of these for each stream
    function CorkedRequest$1(state) {
      var _this = this;

      this.next = null;
      this.entry = null;

      this.finish = function (err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }

    inherits$1(Duplex$3, Readable$1);

    var keys$1 = Object.keys(Writable$1.prototype);
    for (var v$1 = 0; v$1 < keys$1.length; v$1++) {
      var method$1 = keys$1[v$1];
      if (!Duplex$3.prototype[method$1]) Duplex$3.prototype[method$1] = Writable$1.prototype[method$1];
    }
    function Duplex$3(options) {
      if (!(this instanceof Duplex$3)) return new Duplex$3(options);

      Readable$1.call(this, options);
      Writable$1.call(this, options);

      if (options && options.readable === false) this.readable = false;

      if (options && options.writable === false) this.writable = false;

      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

      this.once('end', onend$1);
    }

    // the no-half-open enforcer
    function onend$1() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended) return;

      // no more data can be written.
      // But allow more writes to happen in this tick.
      nextTick(onEndNT$1, this);
    }

    function onEndNT$1(self) {
      self.end();
    }

    // a transform stream is a readable/writable stream where you do
    inherits$1(Transform$2, Duplex$3);

    function TransformState(stream) {
      this.afterTransform = function (er, data) {
        return afterTransform$1(stream, er, data);
      };

      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }

    function afterTransform$1(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;

      var cb = ts.writecb;

      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

      ts.writechunk = null;
      ts.writecb = null;

      if (data !== null && data !== undefined) stream.push(data);

      cb(er);

      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform$2(options) {
      if (!(this instanceof Transform$2)) return new Transform$2(options);

      Duplex$3.call(this, options);

      this._transformState = new TransformState(this);

      // when the writable side finishes, then flush out anything remaining.
      var stream = this;

      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;

      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;

        if (typeof options.flush === 'function') this._flush = options.flush;
      }

      this.once('prefinish', function () {
        if (typeof this._flush === 'function') this._flush(function (er) {
          done$1(stream, er);
        });else done$1(stream);
      });
    }

    Transform$2.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex$3.prototype.push.call(this, chunk, encoding);
    };

    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform$2.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('Not implemented');
    };

    Transform$2.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };

    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform$2.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    function done$1(stream, er) {
      if (er) return stream.emit('error', er);

      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;

      if (ws.length) throw new Error('Calling transform done when ws.length != 0');

      if (ts.transforming) throw new Error('Calling transform done when still transforming');

      return stream.push(null);
    }

    inherits$1(PassThrough$1, Transform$2);
    function PassThrough$1(options) {
      if (!(this instanceof PassThrough$1)) return new PassThrough$1(options);

      Transform$2.call(this, options);
    }

    PassThrough$1.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };

    inherits$1(Stream, EventEmitter);
    Stream.Readable = Readable$1;
    Stream.Writable = Writable$1;
    Stream.Duplex = Duplex$3;
    Stream.Transform = Transform$2;
    Stream.PassThrough = PassThrough$1;

    // Backwards-compat with node 0.4.x
    Stream.Stream = Stream;

    // old-style streams.  Note that the pipe method (the only relevant
    // part of this class) is overridden in the Readable class.

    function Stream() {
      EventEmitter.call(this);
    }

    Stream.prototype.pipe = function(dest, options) {
      var source = this;

      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }

      source.on('data', ondata);

      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }

      dest.on('drain', ondrain);

      // If the 'end' option is not supplied, dest.end() will be called when
      // source gets the 'end' or 'close' events.  Only dest.end() once.
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }

      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;

        dest.end();
      }


      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;

        if (typeof dest.destroy === 'function') dest.destroy();
      }

      // don't leave dangling pipes when there are errors.
      function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, 'error') === 0) {
          throw er; // Unhandled stream error in pipe.
        }
      }

      source.on('error', onerror);
      dest.on('error', onerror);

      // remove all the event listeners that were added.
      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);

        source.removeListener('end', onend);
        source.removeListener('close', onclose);

        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);

        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);

        dest.removeListener('close', cleanup);
      }

      source.on('end', cleanup);
      source.on('close', cleanup);

      dest.on('close', cleanup);

      dest.emit('pipe', source);

      // Allow for unix-like usage: A.pipe(B).pipe(C)
      return dest;
    };

    var stream = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Stream,
        Readable: Readable$1,
        Writable: Writable$1,
        Duplex: Duplex$3,
        Transform: Transform$2,
        PassThrough: PassThrough$1,
        Stream: Stream
    });

    var require$$1 = /*@__PURE__*/getAugmentedNamespace(stream);

    var require$$2 = /*@__PURE__*/getAugmentedNamespace(stringDecoder);

    var Buffer$f = safeBuffer.Buffer;
    var Transform$3 = require$$1.Transform;
    var StringDecoder$3 = require$$2.StringDecoder;


    function CipherBase (hashMode) {
      Transform$3.call(this);
      this.hashMode = typeof hashMode === 'string';
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits_browser(CipherBase, Transform$3);

    CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
      if (typeof data === 'string') {
        data = Buffer$f.from(data, inputEnc);
      }

      var outData = this._update(data);
      if (this.hashMode) return this

      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }

      return outData
    };

    CipherBase.prototype.setAutoPadding = function () {};
    CipherBase.prototype.getAuthTag = function () {
      throw new Error('trying to get auth tag in unsupported state')
    };

    CipherBase.prototype.setAuthTag = function () {
      throw new Error('trying to set auth tag in unsupported state')
    };

    CipherBase.prototype.setAAD = function () {
      throw new Error('trying to set aad in unsupported state')
    };

    CipherBase.prototype._transform = function (data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function (done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e) {
        err = e;
      }

      done(err);
    };
    CipherBase.prototype._finalOrDigest = function (outputEnc) {
      var outData = this.__final() || Buffer$f.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData
    };

    CipherBase.prototype._toString = function (value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder$3(enc);
        this._encoding = enc;
      }

      if (this._encoding !== enc) throw new Error('can\'t switch encodings')

      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }

      return out
    };

    var cipherBase = CipherBase;

    function Hash$1 (hash) {
      cipherBase.call(this, 'digest');

      this._hash = hash;
    }

    inherits_browser(Hash$1, cipherBase);

    Hash$1.prototype._update = function (data) {
      this._hash.update(data);
    };

    Hash$1.prototype._final = function () {
      return this._hash.digest()
    };

    var browser$2 = function createHash (alg) {
      alg = alg.toLowerCase();
      if (alg === 'md5') return new md5_js()
      if (alg === 'rmd160' || alg === 'ripemd160') return new ripemd160()

      return new Hash$1(sha_js(alg))
    };

    var Buffer$g = safeBuffer.Buffer;

    var Buffer$h = safeBuffer.Buffer;





    var ZEROS = Buffer$h.alloc(128);

    var Buffer$i = safeBuffer.Buffer;
    var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;

    var browser$3 = createCommonjsModule(function (module) {

    // limit of Crypto.getRandomValues()
    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
    var MAX_BYTES = 65536;

    // Node supports requesting up to this number of bytes
    // https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
    var MAX_UINT32 = 4294967295;

    function oldBrowser () {
      throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
    }

    var Buffer = safeBuffer.Buffer;
    var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;

    if (crypto && crypto.getRandomValues) {
      module.exports = randomBytes;
    } else {
      module.exports = oldBrowser;
    }

    function randomBytes (size, cb) {
      // phantomjs needs to throw
      if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

      var bytes = Buffer.allocUnsafe(size);

      if (size > 0) {  // getRandomValues fails on IE if size == 0
        if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
          // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            // buffer.slice automatically checks if the end is past the end of
            // the buffer so we don't have to here
            crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }

      if (typeof cb === 'function') {
        return nextTick(function () {
          cb(null, bytes);
        })
      }

      return bytes
    }
    });

    var require$$0$2 = [
    	"abdikace",
    	"abeceda",
    	"adresa",
    	"agrese",
    	"akce",
    	"aktovka",
    	"alej",
    	"alkohol",
    	"amputace",
    	"ananas",
    	"andulka",
    	"anekdota",
    	"anketa",
    	"antika",
    	"anulovat",
    	"archa",
    	"arogance",
    	"asfalt",
    	"asistent",
    	"aspirace",
    	"astma",
    	"astronom",
    	"atlas",
    	"atletika",
    	"atol",
    	"autobus",
    	"azyl",
    	"babka",
    	"bachor",
    	"bacil",
    	"baculka",
    	"badatel",
    	"bageta",
    	"bagr",
    	"bahno",
    	"bakterie",
    	"balada",
    	"baletka",
    	"balkon",
    	"balonek",
    	"balvan",
    	"balza",
    	"bambus",
    	"bankomat",
    	"barbar",
    	"baret",
    	"barman",
    	"baroko",
    	"barva",
    	"baterka",
    	"batoh",
    	"bavlna",
    	"bazalka",
    	"bazilika",
    	"bazuka",
    	"bedna",
    	"beran",
    	"beseda",
    	"bestie",
    	"beton",
    	"bezinka",
    	"bezmoc",
    	"beztak",
    	"bicykl",
    	"bidlo",
    	"biftek",
    	"bikiny",
    	"bilance",
    	"biograf",
    	"biolog",
    	"bitva",
    	"bizon",
    	"blahobyt",
    	"blatouch",
    	"blecha",
    	"bledule",
    	"blesk",
    	"blikat",
    	"blizna",
    	"blokovat",
    	"bloudit",
    	"blud",
    	"bobek",
    	"bobr",
    	"bodlina",
    	"bodnout",
    	"bohatost",
    	"bojkot",
    	"bojovat",
    	"bokorys",
    	"bolest",
    	"borec",
    	"borovice",
    	"bota",
    	"boubel",
    	"bouchat",
    	"bouda",
    	"boule",
    	"bourat",
    	"boxer",
    	"bradavka",
    	"brambora",
    	"branka",
    	"bratr",
    	"brepta",
    	"briketa",
    	"brko",
    	"brloh",
    	"bronz",
    	"broskev",
    	"brunetka",
    	"brusinka",
    	"brzda",
    	"brzy",
    	"bublina",
    	"bubnovat",
    	"buchta",
    	"buditel",
    	"budka",
    	"budova",
    	"bufet",
    	"bujarost",
    	"bukvice",
    	"buldok",
    	"bulva",
    	"bunda",
    	"bunkr",
    	"burza",
    	"butik",
    	"buvol",
    	"buzola",
    	"bydlet",
    	"bylina",
    	"bytovka",
    	"bzukot",
    	"capart",
    	"carevna",
    	"cedr",
    	"cedule",
    	"cejch",
    	"cejn",
    	"cela",
    	"celer",
    	"celkem",
    	"celnice",
    	"cenina",
    	"cennost",
    	"cenovka",
    	"centrum",
    	"cenzor",
    	"cestopis",
    	"cetka",
    	"chalupa",
    	"chapadlo",
    	"charita",
    	"chata",
    	"chechtat",
    	"chemie",
    	"chichot",
    	"chirurg",
    	"chlad",
    	"chleba",
    	"chlubit",
    	"chmel",
    	"chmura",
    	"chobot",
    	"chochol",
    	"chodba",
    	"cholera",
    	"chomout",
    	"chopit",
    	"choroba",
    	"chov",
    	"chrapot",
    	"chrlit",
    	"chrt",
    	"chrup",
    	"chtivost",
    	"chudina",
    	"chutnat",
    	"chvat",
    	"chvilka",
    	"chvost",
    	"chyba",
    	"chystat",
    	"chytit",
    	"cibule",
    	"cigareta",
    	"cihelna",
    	"cihla",
    	"cinkot",
    	"cirkus",
    	"cisterna",
    	"citace",
    	"citrus",
    	"cizinec",
    	"cizost",
    	"clona",
    	"cokoliv",
    	"couvat",
    	"ctitel",
    	"ctnost",
    	"cudnost",
    	"cuketa",
    	"cukr",
    	"cupot",
    	"cvaknout",
    	"cval",
    	"cvik",
    	"cvrkot",
    	"cyklista",
    	"daleko",
    	"dareba",
    	"datel",
    	"datum",
    	"dcera",
    	"debata",
    	"dechovka",
    	"decibel",
    	"deficit",
    	"deflace",
    	"dekl",
    	"dekret",
    	"demokrat",
    	"deprese",
    	"derby",
    	"deska",
    	"detektiv",
    	"dikobraz",
    	"diktovat",
    	"dioda",
    	"diplom",
    	"disk",
    	"displej",
    	"divadlo",
    	"divoch",
    	"dlaha",
    	"dlouho",
    	"dluhopis",
    	"dnes",
    	"dobro",
    	"dobytek",
    	"docent",
    	"dochutit",
    	"dodnes",
    	"dohled",
    	"dohoda",
    	"dohra",
    	"dojem",
    	"dojnice",
    	"doklad",
    	"dokola",
    	"doktor",
    	"dokument",
    	"dolar",
    	"doleva",
    	"dolina",
    	"doma",
    	"dominant",
    	"domluvit",
    	"domov",
    	"donutit",
    	"dopad",
    	"dopis",
    	"doplnit",
    	"doposud",
    	"doprovod",
    	"dopustit",
    	"dorazit",
    	"dorost",
    	"dort",
    	"dosah",
    	"doslov",
    	"dostatek",
    	"dosud",
    	"dosyta",
    	"dotaz",
    	"dotek",
    	"dotknout",
    	"doufat",
    	"doutnat",
    	"dovozce",
    	"dozadu",
    	"doznat",
    	"dozorce",
    	"drahota",
    	"drak",
    	"dramatik",
    	"dravec",
    	"draze",
    	"drdol",
    	"drobnost",
    	"drogerie",
    	"drozd",
    	"drsnost",
    	"drtit",
    	"drzost",
    	"duben",
    	"duchovno",
    	"dudek",
    	"duha",
    	"duhovka",
    	"dusit",
    	"dusno",
    	"dutost",
    	"dvojice",
    	"dvorec",
    	"dynamit",
    	"ekolog",
    	"ekonomie",
    	"elektron",
    	"elipsa",
    	"email",
    	"emise",
    	"emoce",
    	"empatie",
    	"epizoda",
    	"epocha",
    	"epopej",
    	"epos",
    	"esej",
    	"esence",
    	"eskorta",
    	"eskymo",
    	"etiketa",
    	"euforie",
    	"evoluce",
    	"exekuce",
    	"exkurze",
    	"expedice",
    	"exploze",
    	"export",
    	"extrakt",
    	"facka",
    	"fajfka",
    	"fakulta",
    	"fanatik",
    	"fantazie",
    	"farmacie",
    	"favorit",
    	"fazole",
    	"federace",
    	"fejeton",
    	"fenka",
    	"fialka",
    	"figurant",
    	"filozof",
    	"filtr",
    	"finance",
    	"finta",
    	"fixace",
    	"fjord",
    	"flanel",
    	"flirt",
    	"flotila",
    	"fond",
    	"fosfor",
    	"fotbal",
    	"fotka",
    	"foton",
    	"frakce",
    	"freska",
    	"fronta",
    	"fukar",
    	"funkce",
    	"fyzika",
    	"galeje",
    	"garant",
    	"genetika",
    	"geolog",
    	"gilotina",
    	"glazura",
    	"glejt",
    	"golem",
    	"golfista",
    	"gotika",
    	"graf",
    	"gramofon",
    	"granule",
    	"grep",
    	"gril",
    	"grog",
    	"groteska",
    	"guma",
    	"hadice",
    	"hadr",
    	"hala",
    	"halenka",
    	"hanba",
    	"hanopis",
    	"harfa",
    	"harpuna",
    	"havran",
    	"hebkost",
    	"hejkal",
    	"hejno",
    	"hejtman",
    	"hektar",
    	"helma",
    	"hematom",
    	"herec",
    	"herna",
    	"heslo",
    	"hezky",
    	"historik",
    	"hladovka",
    	"hlasivky",
    	"hlava",
    	"hledat",
    	"hlen",
    	"hlodavec",
    	"hloh",
    	"hloupost",
    	"hltat",
    	"hlubina",
    	"hluchota",
    	"hmat",
    	"hmota",
    	"hmyz",
    	"hnis",
    	"hnojivo",
    	"hnout",
    	"hoblina",
    	"hoboj",
    	"hoch",
    	"hodiny",
    	"hodlat",
    	"hodnota",
    	"hodovat",
    	"hojnost",
    	"hokej",
    	"holinka",
    	"holka",
    	"holub",
    	"homole",
    	"honitba",
    	"honorace",
    	"horal",
    	"horda",
    	"horizont",
    	"horko",
    	"horlivec",
    	"hormon",
    	"hornina",
    	"horoskop",
    	"horstvo",
    	"hospoda",
    	"hostina",
    	"hotovost",
    	"houba",
    	"houf",
    	"houpat",
    	"houska",
    	"hovor",
    	"hradba",
    	"hranice",
    	"hravost",
    	"hrazda",
    	"hrbolek",
    	"hrdina",
    	"hrdlo",
    	"hrdost",
    	"hrnek",
    	"hrobka",
    	"hromada",
    	"hrot",
    	"hrouda",
    	"hrozen",
    	"hrstka",
    	"hrubost",
    	"hryzat",
    	"hubenost",
    	"hubnout",
    	"hudba",
    	"hukot",
    	"humr",
    	"husita",
    	"hustota",
    	"hvozd",
    	"hybnost",
    	"hydrant",
    	"hygiena",
    	"hymna",
    	"hysterik",
    	"idylka",
    	"ihned",
    	"ikona",
    	"iluze",
    	"imunita",
    	"infekce",
    	"inflace",
    	"inkaso",
    	"inovace",
    	"inspekce",
    	"internet",
    	"invalida",
    	"investor",
    	"inzerce",
    	"ironie",
    	"jablko",
    	"jachta",
    	"jahoda",
    	"jakmile",
    	"jakost",
    	"jalovec",
    	"jantar",
    	"jarmark",
    	"jaro",
    	"jasan",
    	"jasno",
    	"jatka",
    	"javor",
    	"jazyk",
    	"jedinec",
    	"jedle",
    	"jednatel",
    	"jehlan",
    	"jekot",
    	"jelen",
    	"jelito",
    	"jemnost",
    	"jenom",
    	"jepice",
    	"jeseter",
    	"jevit",
    	"jezdec",
    	"jezero",
    	"jinak",
    	"jindy",
    	"jinoch",
    	"jiskra",
    	"jistota",
    	"jitrnice",
    	"jizva",
    	"jmenovat",
    	"jogurt",
    	"jurta",
    	"kabaret",
    	"kabel",
    	"kabinet",
    	"kachna",
    	"kadet",
    	"kadidlo",
    	"kahan",
    	"kajak",
    	"kajuta",
    	"kakao",
    	"kaktus",
    	"kalamita",
    	"kalhoty",
    	"kalibr",
    	"kalnost",
    	"kamera",
    	"kamkoliv",
    	"kamna",
    	"kanibal",
    	"kanoe",
    	"kantor",
    	"kapalina",
    	"kapela",
    	"kapitola",
    	"kapka",
    	"kaple",
    	"kapota",
    	"kapr",
    	"kapusta",
    	"kapybara",
    	"karamel",
    	"karotka",
    	"karton",
    	"kasa",
    	"katalog",
    	"katedra",
    	"kauce",
    	"kauza",
    	"kavalec",
    	"kazajka",
    	"kazeta",
    	"kazivost",
    	"kdekoliv",
    	"kdesi",
    	"kedluben",
    	"kemp",
    	"keramika",
    	"kino",
    	"klacek",
    	"kladivo",
    	"klam",
    	"klapot",
    	"klasika",
    	"klaun",
    	"klec",
    	"klenba",
    	"klepat",
    	"klesnout",
    	"klid",
    	"klima",
    	"klisna",
    	"klobouk",
    	"klokan",
    	"klopa",
    	"kloub",
    	"klubovna",
    	"klusat",
    	"kluzkost",
    	"kmen",
    	"kmitat",
    	"kmotr",
    	"kniha",
    	"knot",
    	"koalice",
    	"koberec",
    	"kobka",
    	"kobliha",
    	"kobyla",
    	"kocour",
    	"kohout",
    	"kojenec",
    	"kokos",
    	"koktejl",
    	"kolaps",
    	"koleda",
    	"kolize",
    	"kolo",
    	"komando",
    	"kometa",
    	"komik",
    	"komnata",
    	"komora",
    	"kompas",
    	"komunita",
    	"konat",
    	"koncept",
    	"kondice",
    	"konec",
    	"konfese",
    	"kongres",
    	"konina",
    	"konkurs",
    	"kontakt",
    	"konzerva",
    	"kopanec",
    	"kopie",
    	"kopnout",
    	"koprovka",
    	"korbel",
    	"korektor",
    	"kormidlo",
    	"koroptev",
    	"korpus",
    	"koruna",
    	"koryto",
    	"korzet",
    	"kosatec",
    	"kostka",
    	"kotel",
    	"kotleta",
    	"kotoul",
    	"koukat",
    	"koupelna",
    	"kousek",
    	"kouzlo",
    	"kovboj",
    	"koza",
    	"kozoroh",
    	"krabice",
    	"krach",
    	"krajina",
    	"kralovat",
    	"krasopis",
    	"kravata",
    	"kredit",
    	"krejcar",
    	"kresba",
    	"kreveta",
    	"kriket",
    	"kritik",
    	"krize",
    	"krkavec",
    	"krmelec",
    	"krmivo",
    	"krocan",
    	"krok",
    	"kronika",
    	"kropit",
    	"kroupa",
    	"krovka",
    	"krtek",
    	"kruhadlo",
    	"krupice",
    	"krutost",
    	"krvinka",
    	"krychle",
    	"krypta",
    	"krystal",
    	"kryt",
    	"kudlanka",
    	"kufr",
    	"kujnost",
    	"kukla",
    	"kulajda",
    	"kulich",
    	"kulka",
    	"kulomet",
    	"kultura",
    	"kuna",
    	"kupodivu",
    	"kurt",
    	"kurzor",
    	"kutil",
    	"kvalita",
    	"kvasinka",
    	"kvestor",
    	"kynolog",
    	"kyselina",
    	"kytara",
    	"kytice",
    	"kytka",
    	"kytovec",
    	"kyvadlo",
    	"labrador",
    	"lachtan",
    	"ladnost",
    	"laik",
    	"lakomec",
    	"lamela",
    	"lampa",
    	"lanovka",
    	"lasice",
    	"laso",
    	"lastura",
    	"latinka",
    	"lavina",
    	"lebka",
    	"leckdy",
    	"leden",
    	"lednice",
    	"ledovka",
    	"ledvina",
    	"legenda",
    	"legie",
    	"legrace",
    	"lehce",
    	"lehkost",
    	"lehnout",
    	"lektvar",
    	"lenochod",
    	"lentilka",
    	"lepenka",
    	"lepidlo",
    	"letadlo",
    	"letec",
    	"letmo",
    	"letokruh",
    	"levhart",
    	"levitace",
    	"levobok",
    	"libra",
    	"lichotka",
    	"lidojed",
    	"lidskost",
    	"lihovina",
    	"lijavec",
    	"lilek",
    	"limetka",
    	"linie",
    	"linka",
    	"linoleum",
    	"listopad",
    	"litina",
    	"litovat",
    	"lobista",
    	"lodivod",
    	"logika",
    	"logoped",
    	"lokalita",
    	"loket",
    	"lomcovat",
    	"lopata",
    	"lopuch",
    	"lord",
    	"losos",
    	"lotr",
    	"loudal",
    	"louh",
    	"louka",
    	"louskat",
    	"lovec",
    	"lstivost",
    	"lucerna",
    	"lucifer",
    	"lump",
    	"lusk",
    	"lustrace",
    	"lvice",
    	"lyra",
    	"lyrika",
    	"lysina",
    	"madam",
    	"madlo",
    	"magistr",
    	"mahagon",
    	"majetek",
    	"majitel",
    	"majorita",
    	"makak",
    	"makovice",
    	"makrela",
    	"malba",
    	"malina",
    	"malovat",
    	"malvice",
    	"maminka",
    	"mandle",
    	"manko",
    	"marnost",
    	"masakr",
    	"maskot",
    	"masopust",
    	"matice",
    	"matrika",
    	"maturita",
    	"mazanec",
    	"mazivo",
    	"mazlit",
    	"mazurka",
    	"mdloba",
    	"mechanik",
    	"meditace",
    	"medovina",
    	"melasa",
    	"meloun",
    	"mentolka",
    	"metla",
    	"metoda",
    	"metr",
    	"mezera",
    	"migrace",
    	"mihnout",
    	"mihule",
    	"mikina",
    	"mikrofon",
    	"milenec",
    	"milimetr",
    	"milost",
    	"mimika",
    	"mincovna",
    	"minibar",
    	"minomet",
    	"minulost",
    	"miska",
    	"mistr",
    	"mixovat",
    	"mladost",
    	"mlha",
    	"mlhovina",
    	"mlok",
    	"mlsat",
    	"mluvit",
    	"mnich",
    	"mnohem",
    	"mobil",
    	"mocnost",
    	"modelka",
    	"modlitba",
    	"mohyla",
    	"mokro",
    	"molekula",
    	"momentka",
    	"monarcha",
    	"monokl",
    	"monstrum",
    	"montovat",
    	"monzun",
    	"mosaz",
    	"moskyt",
    	"most",
    	"motivace",
    	"motorka",
    	"motyka",
    	"moucha",
    	"moudrost",
    	"mozaika",
    	"mozek",
    	"mozol",
    	"mramor",
    	"mravenec",
    	"mrkev",
    	"mrtvola",
    	"mrzet",
    	"mrzutost",
    	"mstitel",
    	"mudrc",
    	"muflon",
    	"mulat",
    	"mumie",
    	"munice",
    	"muset",
    	"mutace",
    	"muzeum",
    	"muzikant",
    	"myslivec",
    	"mzda",
    	"nabourat",
    	"nachytat",
    	"nadace",
    	"nadbytek",
    	"nadhoz",
    	"nadobro",
    	"nadpis",
    	"nahlas",
    	"nahnat",
    	"nahodile",
    	"nahradit",
    	"naivita",
    	"najednou",
    	"najisto",
    	"najmout",
    	"naklonit",
    	"nakonec",
    	"nakrmit",
    	"nalevo",
    	"namazat",
    	"namluvit",
    	"nanometr",
    	"naoko",
    	"naopak",
    	"naostro",
    	"napadat",
    	"napevno",
    	"naplnit",
    	"napnout",
    	"naposled",
    	"naprosto",
    	"narodit",
    	"naruby",
    	"narychlo",
    	"nasadit",
    	"nasekat",
    	"naslepo",
    	"nastat",
    	"natolik",
    	"navenek",
    	"navrch",
    	"navzdory",
    	"nazvat",
    	"nebe",
    	"nechat",
    	"necky",
    	"nedaleko",
    	"nedbat",
    	"neduh",
    	"negace",
    	"nehet",
    	"nehoda",
    	"nejen",
    	"nejprve",
    	"neklid",
    	"nelibost",
    	"nemilost",
    	"nemoc",
    	"neochota",
    	"neonka",
    	"nepokoj",
    	"nerost",
    	"nerv",
    	"nesmysl",
    	"nesoulad",
    	"netvor",
    	"neuron",
    	"nevina",
    	"nezvykle",
    	"nicota",
    	"nijak",
    	"nikam",
    	"nikdy",
    	"nikl",
    	"nikterak",
    	"nitro",
    	"nocleh",
    	"nohavice",
    	"nominace",
    	"nora",
    	"norek",
    	"nositel",
    	"nosnost",
    	"nouze",
    	"noviny",
    	"novota",
    	"nozdra",
    	"nuda",
    	"nudle",
    	"nuget",
    	"nutit",
    	"nutnost",
    	"nutrie",
    	"nymfa",
    	"obal",
    	"obarvit",
    	"obava",
    	"obdiv",
    	"obec",
    	"obehnat",
    	"obejmout",
    	"obezita",
    	"obhajoba",
    	"obilnice",
    	"objasnit",
    	"objekt",
    	"obklopit",
    	"oblast",
    	"oblek",
    	"obliba",
    	"obloha",
    	"obluda",
    	"obnos",
    	"obohatit",
    	"obojek",
    	"obout",
    	"obrazec",
    	"obrna",
    	"obruba",
    	"obrys",
    	"obsah",
    	"obsluha",
    	"obstarat",
    	"obuv",
    	"obvaz",
    	"obvinit",
    	"obvod",
    	"obvykle",
    	"obyvatel",
    	"obzor",
    	"ocas",
    	"ocel",
    	"ocenit",
    	"ochladit",
    	"ochota",
    	"ochrana",
    	"ocitnout",
    	"odboj",
    	"odbyt",
    	"odchod",
    	"odcizit",
    	"odebrat",
    	"odeslat",
    	"odevzdat",
    	"odezva",
    	"odhadce",
    	"odhodit",
    	"odjet",
    	"odjinud",
    	"odkaz",
    	"odkoupit",
    	"odliv",
    	"odluka",
    	"odmlka",
    	"odolnost",
    	"odpad",
    	"odpis",
    	"odplout",
    	"odpor",
    	"odpustit",
    	"odpykat",
    	"odrazka",
    	"odsoudit",
    	"odstup",
    	"odsun",
    	"odtok",
    	"odtud",
    	"odvaha",
    	"odveta",
    	"odvolat",
    	"odvracet",
    	"odznak",
    	"ofina",
    	"ofsajd",
    	"ohlas",
    	"ohnisko",
    	"ohrada",
    	"ohrozit",
    	"ohryzek",
    	"okap",
    	"okenice",
    	"oklika",
    	"okno",
    	"okouzlit",
    	"okovy",
    	"okrasa",
    	"okres",
    	"okrsek",
    	"okruh",
    	"okupant",
    	"okurka",
    	"okusit",
    	"olejnina",
    	"olizovat",
    	"omak",
    	"omeleta",
    	"omezit",
    	"omladina",
    	"omlouvat",
    	"omluva",
    	"omyl",
    	"onehdy",
    	"opakovat",
    	"opasek",
    	"operace",
    	"opice",
    	"opilost",
    	"opisovat",
    	"opora",
    	"opozice",
    	"opravdu",
    	"oproti",
    	"orbital",
    	"orchestr",
    	"orgie",
    	"orlice",
    	"orloj",
    	"ortel",
    	"osada",
    	"oschnout",
    	"osika",
    	"osivo",
    	"oslava",
    	"oslepit",
    	"oslnit",
    	"oslovit",
    	"osnova",
    	"osoba",
    	"osolit",
    	"ospalec",
    	"osten",
    	"ostraha",
    	"ostuda",
    	"ostych",
    	"osvojit",
    	"oteplit",
    	"otisk",
    	"otop",
    	"otrhat",
    	"otrlost",
    	"otrok",
    	"otruby",
    	"otvor",
    	"ovanout",
    	"ovar",
    	"oves",
    	"ovlivnit",
    	"ovoce",
    	"oxid",
    	"ozdoba",
    	"pachatel",
    	"pacient",
    	"padouch",
    	"pahorek",
    	"pakt",
    	"palanda",
    	"palec",
    	"palivo",
    	"paluba",
    	"pamflet",
    	"pamlsek",
    	"panenka",
    	"panika",
    	"panna",
    	"panovat",
    	"panstvo",
    	"pantofle",
    	"paprika",
    	"parketa",
    	"parodie",
    	"parta",
    	"paruka",
    	"paryba",
    	"paseka",
    	"pasivita",
    	"pastelka",
    	"patent",
    	"patrona",
    	"pavouk",
    	"pazneht",
    	"pazourek",
    	"pecka",
    	"pedagog",
    	"pejsek",
    	"peklo",
    	"peloton",
    	"penalta",
    	"pendrek",
    	"penze",
    	"periskop",
    	"pero",
    	"pestrost",
    	"petarda",
    	"petice",
    	"petrolej",
    	"pevnina",
    	"pexeso",
    	"pianista",
    	"piha",
    	"pijavice",
    	"pikle",
    	"piknik",
    	"pilina",
    	"pilnost",
    	"pilulka",
    	"pinzeta",
    	"pipeta",
    	"pisatel",
    	"pistole",
    	"pitevna",
    	"pivnice",
    	"pivovar",
    	"placenta",
    	"plakat",
    	"plamen",
    	"planeta",
    	"plastika",
    	"platit",
    	"plavidlo",
    	"plaz",
    	"plech",
    	"plemeno",
    	"plenta",
    	"ples",
    	"pletivo",
    	"plevel",
    	"plivat",
    	"plnit",
    	"plno",
    	"plocha",
    	"plodina",
    	"plomba",
    	"plout",
    	"pluk",
    	"plyn",
    	"pobavit",
    	"pobyt",
    	"pochod",
    	"pocit",
    	"poctivec",
    	"podat",
    	"podcenit",
    	"podepsat",
    	"podhled",
    	"podivit",
    	"podklad",
    	"podmanit",
    	"podnik",
    	"podoba",
    	"podpora",
    	"podraz",
    	"podstata",
    	"podvod",
    	"podzim",
    	"poezie",
    	"pohanka",
    	"pohnutka",
    	"pohovor",
    	"pohroma",
    	"pohyb",
    	"pointa",
    	"pojistka",
    	"pojmout",
    	"pokazit",
    	"pokles",
    	"pokoj",
    	"pokrok",
    	"pokuta",
    	"pokyn",
    	"poledne",
    	"polibek",
    	"polknout",
    	"poloha",
    	"polynom",
    	"pomalu",
    	"pominout",
    	"pomlka",
    	"pomoc",
    	"pomsta",
    	"pomyslet",
    	"ponechat",
    	"ponorka",
    	"ponurost",
    	"popadat",
    	"popel",
    	"popisek",
    	"poplach",
    	"poprosit",
    	"popsat",
    	"popud",
    	"poradce",
    	"porce",
    	"porod",
    	"porucha",
    	"poryv",
    	"posadit",
    	"posed",
    	"posila",
    	"poskok",
    	"poslanec",
    	"posoudit",
    	"pospolu",
    	"postava",
    	"posudek",
    	"posyp",
    	"potah",
    	"potkan",
    	"potlesk",
    	"potomek",
    	"potrava",
    	"potupa",
    	"potvora",
    	"poukaz",
    	"pouto",
    	"pouzdro",
    	"povaha",
    	"povidla",
    	"povlak",
    	"povoz",
    	"povrch",
    	"povstat",
    	"povyk",
    	"povzdech",
    	"pozdrav",
    	"pozemek",
    	"poznatek",
    	"pozor",
    	"pozvat",
    	"pracovat",
    	"prahory",
    	"praktika",
    	"prales",
    	"praotec",
    	"praporek",
    	"prase",
    	"pravda",
    	"princip",
    	"prkno",
    	"probudit",
    	"procento",
    	"prodej",
    	"profese",
    	"prohra",
    	"projekt",
    	"prolomit",
    	"promile",
    	"pronikat",
    	"propad",
    	"prorok",
    	"prosba",
    	"proton",
    	"proutek",
    	"provaz",
    	"prskavka",
    	"prsten",
    	"prudkost",
    	"prut",
    	"prvek",
    	"prvohory",
    	"psanec",
    	"psovod",
    	"pstruh",
    	"ptactvo",
    	"puberta",
    	"puch",
    	"pudl",
    	"pukavec",
    	"puklina",
    	"pukrle",
    	"pult",
    	"pumpa",
    	"punc",
    	"pupen",
    	"pusa",
    	"pusinka",
    	"pustina",
    	"putovat",
    	"putyka",
    	"pyramida",
    	"pysk",
    	"pytel",
    	"racek",
    	"rachot",
    	"radiace",
    	"radnice",
    	"radon",
    	"raft",
    	"ragby",
    	"raketa",
    	"rakovina",
    	"rameno",
    	"rampouch",
    	"rande",
    	"rarach",
    	"rarita",
    	"rasovna",
    	"rastr",
    	"ratolest",
    	"razance",
    	"razidlo",
    	"reagovat",
    	"reakce",
    	"recept",
    	"redaktor",
    	"referent",
    	"reflex",
    	"rejnok",
    	"reklama",
    	"rekord",
    	"rekrut",
    	"rektor",
    	"reputace",
    	"revize",
    	"revma",
    	"revolver",
    	"rezerva",
    	"riskovat",
    	"riziko",
    	"robotika",
    	"rodokmen",
    	"rohovka",
    	"rokle",
    	"rokoko",
    	"romaneto",
    	"ropovod",
    	"ropucha",
    	"rorejs",
    	"rosol",
    	"rostlina",
    	"rotmistr",
    	"rotoped",
    	"rotunda",
    	"roubenka",
    	"roucho",
    	"roup",
    	"roura",
    	"rovina",
    	"rovnice",
    	"rozbor",
    	"rozchod",
    	"rozdat",
    	"rozeznat",
    	"rozhodce",
    	"rozinka",
    	"rozjezd",
    	"rozkaz",
    	"rozloha",
    	"rozmar",
    	"rozpad",
    	"rozruch",
    	"rozsah",
    	"roztok",
    	"rozum",
    	"rozvod",
    	"rubrika",
    	"ruchadlo",
    	"rukavice",
    	"rukopis",
    	"ryba",
    	"rybolov",
    	"rychlost",
    	"rydlo",
    	"rypadlo",
    	"rytina",
    	"ryzost",
    	"sadista",
    	"sahat",
    	"sako",
    	"samec",
    	"samizdat",
    	"samota",
    	"sanitka",
    	"sardinka",
    	"sasanka",
    	"satelit",
    	"sazba",
    	"sazenice",
    	"sbor",
    	"schovat",
    	"sebranka",
    	"secese",
    	"sedadlo",
    	"sediment",
    	"sedlo",
    	"sehnat",
    	"sejmout",
    	"sekera",
    	"sekta",
    	"sekunda",
    	"sekvoje",
    	"semeno",
    	"seno",
    	"servis",
    	"sesadit",
    	"seshora",
    	"seskok",
    	"seslat",
    	"sestra",
    	"sesuv",
    	"sesypat",
    	"setba",
    	"setina",
    	"setkat",
    	"setnout",
    	"setrvat",
    	"sever",
    	"seznam",
    	"shoda",
    	"shrnout",
    	"sifon",
    	"silnice",
    	"sirka",
    	"sirotek",
    	"sirup",
    	"situace",
    	"skafandr",
    	"skalisko",
    	"skanzen",
    	"skaut",
    	"skeptik",
    	"skica",
    	"skladba",
    	"sklenice",
    	"sklo",
    	"skluz",
    	"skoba",
    	"skokan",
    	"skoro",
    	"skripta",
    	"skrz",
    	"skupina",
    	"skvost",
    	"skvrna",
    	"slabika",
    	"sladidlo",
    	"slanina",
    	"slast",
    	"slavnost",
    	"sledovat",
    	"slepec",
    	"sleva",
    	"slezina",
    	"slib",
    	"slina",
    	"sliznice",
    	"slon",
    	"sloupek",
    	"slovo",
    	"sluch",
    	"sluha",
    	"slunce",
    	"slupka",
    	"slza",
    	"smaragd",
    	"smetana",
    	"smilstvo",
    	"smlouva",
    	"smog",
    	"smrad",
    	"smrk",
    	"smrtka",
    	"smutek",
    	"smysl",
    	"snad",
    	"snaha",
    	"snob",
    	"sobota",
    	"socha",
    	"sodovka",
    	"sokol",
    	"sopka",
    	"sotva",
    	"souboj",
    	"soucit",
    	"soudce",
    	"souhlas",
    	"soulad",
    	"soumrak",
    	"souprava",
    	"soused",
    	"soutok",
    	"souviset",
    	"spalovna",
    	"spasitel",
    	"spis",
    	"splav",
    	"spodek",
    	"spojenec",
    	"spolu",
    	"sponzor",
    	"spornost",
    	"spousta",
    	"sprcha",
    	"spustit",
    	"sranda",
    	"sraz",
    	"srdce",
    	"srna",
    	"srnec",
    	"srovnat",
    	"srpen",
    	"srst",
    	"srub",
    	"stanice",
    	"starosta",
    	"statika",
    	"stavba",
    	"stehno",
    	"stezka",
    	"stodola",
    	"stolek",
    	"stopa",
    	"storno",
    	"stoupat",
    	"strach",
    	"stres",
    	"strhnout",
    	"strom",
    	"struna",
    	"studna",
    	"stupnice",
    	"stvol",
    	"styk",
    	"subjekt",
    	"subtropy",
    	"suchar",
    	"sudost",
    	"sukno",
    	"sundat",
    	"sunout",
    	"surikata",
    	"surovina",
    	"svah",
    	"svalstvo",
    	"svetr",
    	"svatba",
    	"svazek",
    	"svisle",
    	"svitek",
    	"svoboda",
    	"svodidlo",
    	"svorka",
    	"svrab",
    	"sykavka",
    	"sykot",
    	"synek",
    	"synovec",
    	"sypat",
    	"sypkost",
    	"syrovost",
    	"sysel",
    	"sytost",
    	"tabletka",
    	"tabule",
    	"tahoun",
    	"tajemno",
    	"tajfun",
    	"tajga",
    	"tajit",
    	"tajnost",
    	"taktika",
    	"tamhle",
    	"tampon",
    	"tancovat",
    	"tanec",
    	"tanker",
    	"tapeta",
    	"tavenina",
    	"tazatel",
    	"technika",
    	"tehdy",
    	"tekutina",
    	"telefon",
    	"temnota",
    	"tendence",
    	"tenista",
    	"tenor",
    	"teplota",
    	"tepna",
    	"teprve",
    	"terapie",
    	"termoska",
    	"textil",
    	"ticho",
    	"tiskopis",
    	"titulek",
    	"tkadlec",
    	"tkanina",
    	"tlapka",
    	"tleskat",
    	"tlukot",
    	"tlupa",
    	"tmel",
    	"toaleta",
    	"topinka",
    	"topol",
    	"torzo",
    	"touha",
    	"toulec",
    	"tradice",
    	"traktor",
    	"tramp",
    	"trasa",
    	"traverza",
    	"trefit",
    	"trest",
    	"trezor",
    	"trhavina",
    	"trhlina",
    	"trochu",
    	"trojice",
    	"troska",
    	"trouba",
    	"trpce",
    	"trpitel",
    	"trpkost",
    	"trubec",
    	"truchlit",
    	"truhlice",
    	"trus",
    	"trvat",
    	"tudy",
    	"tuhnout",
    	"tuhost",
    	"tundra",
    	"turista",
    	"turnaj",
    	"tuzemsko",
    	"tvaroh",
    	"tvorba",
    	"tvrdost",
    	"tvrz",
    	"tygr",
    	"tykev",
    	"ubohost",
    	"uboze",
    	"ubrat",
    	"ubrousek",
    	"ubrus",
    	"ubytovna",
    	"ucho",
    	"uctivost",
    	"udivit",
    	"uhradit",
    	"ujednat",
    	"ujistit",
    	"ujmout",
    	"ukazatel",
    	"uklidnit",
    	"uklonit",
    	"ukotvit",
    	"ukrojit",
    	"ulice",
    	"ulita",
    	"ulovit",
    	"umyvadlo",
    	"unavit",
    	"uniforma",
    	"uniknout",
    	"upadnout",
    	"uplatnit",
    	"uplynout",
    	"upoutat",
    	"upravit",
    	"uran",
    	"urazit",
    	"usednout",
    	"usilovat",
    	"usmrtit",
    	"usnadnit",
    	"usnout",
    	"usoudit",
    	"ustlat",
    	"ustrnout",
    	"utahovat",
    	"utkat",
    	"utlumit",
    	"utonout",
    	"utopenec",
    	"utrousit",
    	"uvalit",
    	"uvolnit",
    	"uvozovka",
    	"uzdravit",
    	"uzel",
    	"uzenina",
    	"uzlina",
    	"uznat",
    	"vagon",
    	"valcha",
    	"valoun",
    	"vana",
    	"vandal",
    	"vanilka",
    	"varan",
    	"varhany",
    	"varovat",
    	"vcelku",
    	"vchod",
    	"vdova",
    	"vedro",
    	"vegetace",
    	"vejce",
    	"velbloud",
    	"veletrh",
    	"velitel",
    	"velmoc",
    	"velryba",
    	"venkov",
    	"veranda",
    	"verze",
    	"veselka",
    	"veskrze",
    	"vesnice",
    	"vespodu",
    	"vesta",
    	"veterina",
    	"veverka",
    	"vibrace",
    	"vichr",
    	"videohra",
    	"vidina",
    	"vidle",
    	"vila",
    	"vinice",
    	"viset",
    	"vitalita",
    	"vize",
    	"vizitka",
    	"vjezd",
    	"vklad",
    	"vkus",
    	"vlajka",
    	"vlak",
    	"vlasec",
    	"vlevo",
    	"vlhkost",
    	"vliv",
    	"vlnovka",
    	"vloupat",
    	"vnucovat",
    	"vnuk",
    	"voda",
    	"vodivost",
    	"vodoznak",
    	"vodstvo",
    	"vojensky",
    	"vojna",
    	"vojsko",
    	"volant",
    	"volba",
    	"volit",
    	"volno",
    	"voskovka",
    	"vozidlo",
    	"vozovna",
    	"vpravo",
    	"vrabec",
    	"vracet",
    	"vrah",
    	"vrata",
    	"vrba",
    	"vrcholek",
    	"vrhat",
    	"vrstva",
    	"vrtule",
    	"vsadit",
    	"vstoupit",
    	"vstup",
    	"vtip",
    	"vybavit",
    	"vybrat",
    	"vychovat",
    	"vydat",
    	"vydra",
    	"vyfotit",
    	"vyhledat",
    	"vyhnout",
    	"vyhodit",
    	"vyhradit",
    	"vyhubit",
    	"vyjasnit",
    	"vyjet",
    	"vyjmout",
    	"vyklopit",
    	"vykonat",
    	"vylekat",
    	"vymazat",
    	"vymezit",
    	"vymizet",
    	"vymyslet",
    	"vynechat",
    	"vynikat",
    	"vynutit",
    	"vypadat",
    	"vyplatit",
    	"vypravit",
    	"vypustit",
    	"vyrazit",
    	"vyrovnat",
    	"vyrvat",
    	"vyslovit",
    	"vysoko",
    	"vystavit",
    	"vysunout",
    	"vysypat",
    	"vytasit",
    	"vytesat",
    	"vytratit",
    	"vyvinout",
    	"vyvolat",
    	"vyvrhel",
    	"vyzdobit",
    	"vyznat",
    	"vzadu",
    	"vzbudit",
    	"vzchopit",
    	"vzdor",
    	"vzduch",
    	"vzdychat",
    	"vzestup",
    	"vzhledem",
    	"vzkaz",
    	"vzlykat",
    	"vznik",
    	"vzorek",
    	"vzpoura",
    	"vztah",
    	"vztek",
    	"xylofon",
    	"zabrat",
    	"zabydlet",
    	"zachovat",
    	"zadarmo",
    	"zadusit",
    	"zafoukat",
    	"zahltit",
    	"zahodit",
    	"zahrada",
    	"zahynout",
    	"zajatec",
    	"zajet",
    	"zajistit",
    	"zaklepat",
    	"zakoupit",
    	"zalepit",
    	"zamezit",
    	"zamotat",
    	"zamyslet",
    	"zanechat",
    	"zanikat",
    	"zaplatit",
    	"zapojit",
    	"zapsat",
    	"zarazit",
    	"zastavit",
    	"zasunout",
    	"zatajit",
    	"zatemnit",
    	"zatknout",
    	"zaujmout",
    	"zavalit",
    	"zavelet",
    	"zavinit",
    	"zavolat",
    	"zavrtat",
    	"zazvonit",
    	"zbavit",
    	"zbrusu",
    	"zbudovat",
    	"zbytek",
    	"zdaleka",
    	"zdarma",
    	"zdatnost",
    	"zdivo",
    	"zdobit",
    	"zdroj",
    	"zdvih",
    	"zdymadlo",
    	"zelenina",
    	"zeman",
    	"zemina",
    	"zeptat",
    	"zezadu",
    	"zezdola",
    	"zhatit",
    	"zhltnout",
    	"zhluboka",
    	"zhotovit",
    	"zhruba",
    	"zima",
    	"zimnice",
    	"zjemnit",
    	"zklamat",
    	"zkoumat",
    	"zkratka",
    	"zkumavka",
    	"zlato",
    	"zlehka",
    	"zloba",
    	"zlom",
    	"zlost",
    	"zlozvyk",
    	"zmapovat",
    	"zmar",
    	"zmatek",
    	"zmije",
    	"zmizet",
    	"zmocnit",
    	"zmodrat",
    	"zmrzlina",
    	"zmutovat",
    	"znak",
    	"znalost",
    	"znamenat",
    	"znovu",
    	"zobrazit",
    	"zotavit",
    	"zoubek",
    	"zoufale",
    	"zplodit",
    	"zpomalit",
    	"zprava",
    	"zprostit",
    	"zprudka",
    	"zprvu",
    	"zrada",
    	"zranit",
    	"zrcadlo",
    	"zrnitost",
    	"zrno",
    	"zrovna",
    	"zrychlit",
    	"zrzavost",
    	"zticha",
    	"ztratit",
    	"zubovina",
    	"zubr",
    	"zvednout",
    	"zvenku",
    	"zvesela",
    	"zvon",
    	"zvrat",
    	"zvukovod",
    	"zvyk"
    ];

    var require$$1$1 = [
    	"的",
    	"一",
    	"是",
    	"在",
    	"不",
    	"了",
    	"有",
    	"和",
    	"人",
    	"这",
    	"中",
    	"大",
    	"为",
    	"上",
    	"个",
    	"国",
    	"我",
    	"以",
    	"要",
    	"他",
    	"时",
    	"来",
    	"用",
    	"们",
    	"生",
    	"到",
    	"作",
    	"地",
    	"于",
    	"出",
    	"就",
    	"分",
    	"对",
    	"成",
    	"会",
    	"可",
    	"主",
    	"发",
    	"年",
    	"动",
    	"同",
    	"工",
    	"也",
    	"能",
    	"下",
    	"过",
    	"子",
    	"说",
    	"产",
    	"种",
    	"面",
    	"而",
    	"方",
    	"后",
    	"多",
    	"定",
    	"行",
    	"学",
    	"法",
    	"所",
    	"民",
    	"得",
    	"经",
    	"十",
    	"三",
    	"之",
    	"进",
    	"着",
    	"等",
    	"部",
    	"度",
    	"家",
    	"电",
    	"力",
    	"里",
    	"如",
    	"水",
    	"化",
    	"高",
    	"自",
    	"二",
    	"理",
    	"起",
    	"小",
    	"物",
    	"现",
    	"实",
    	"加",
    	"量",
    	"都",
    	"两",
    	"体",
    	"制",
    	"机",
    	"当",
    	"使",
    	"点",
    	"从",
    	"业",
    	"本",
    	"去",
    	"把",
    	"性",
    	"好",
    	"应",
    	"开",
    	"它",
    	"合",
    	"还",
    	"因",
    	"由",
    	"其",
    	"些",
    	"然",
    	"前",
    	"外",
    	"天",
    	"政",
    	"四",
    	"日",
    	"那",
    	"社",
    	"义",
    	"事",
    	"平",
    	"形",
    	"相",
    	"全",
    	"表",
    	"间",
    	"样",
    	"与",
    	"关",
    	"各",
    	"重",
    	"新",
    	"线",
    	"内",
    	"数",
    	"正",
    	"心",
    	"反",
    	"你",
    	"明",
    	"看",
    	"原",
    	"又",
    	"么",
    	"利",
    	"比",
    	"或",
    	"但",
    	"质",
    	"气",
    	"第",
    	"向",
    	"道",
    	"命",
    	"此",
    	"变",
    	"条",
    	"只",
    	"没",
    	"结",
    	"解",
    	"问",
    	"意",
    	"建",
    	"月",
    	"公",
    	"无",
    	"系",
    	"军",
    	"很",
    	"情",
    	"者",
    	"最",
    	"立",
    	"代",
    	"想",
    	"已",
    	"通",
    	"并",
    	"提",
    	"直",
    	"题",
    	"党",
    	"程",
    	"展",
    	"五",
    	"果",
    	"料",
    	"象",
    	"员",
    	"革",
    	"位",
    	"入",
    	"常",
    	"文",
    	"总",
    	"次",
    	"品",
    	"式",
    	"活",
    	"设",
    	"及",
    	"管",
    	"特",
    	"件",
    	"长",
    	"求",
    	"老",
    	"头",
    	"基",
    	"资",
    	"边",
    	"流",
    	"路",
    	"级",
    	"少",
    	"图",
    	"山",
    	"统",
    	"接",
    	"知",
    	"较",
    	"将",
    	"组",
    	"见",
    	"计",
    	"别",
    	"她",
    	"手",
    	"角",
    	"期",
    	"根",
    	"论",
    	"运",
    	"农",
    	"指",
    	"几",
    	"九",
    	"区",
    	"强",
    	"放",
    	"决",
    	"西",
    	"被",
    	"干",
    	"做",
    	"必",
    	"战",
    	"先",
    	"回",
    	"则",
    	"任",
    	"取",
    	"据",
    	"处",
    	"队",
    	"南",
    	"给",
    	"色",
    	"光",
    	"门",
    	"即",
    	"保",
    	"治",
    	"北",
    	"造",
    	"百",
    	"规",
    	"热",
    	"领",
    	"七",
    	"海",
    	"口",
    	"东",
    	"导",
    	"器",
    	"压",
    	"志",
    	"世",
    	"金",
    	"增",
    	"争",
    	"济",
    	"阶",
    	"油",
    	"思",
    	"术",
    	"极",
    	"交",
    	"受",
    	"联",
    	"什",
    	"认",
    	"六",
    	"共",
    	"权",
    	"收",
    	"证",
    	"改",
    	"清",
    	"美",
    	"再",
    	"采",
    	"转",
    	"更",
    	"单",
    	"风",
    	"切",
    	"打",
    	"白",
    	"教",
    	"速",
    	"花",
    	"带",
    	"安",
    	"场",
    	"身",
    	"车",
    	"例",
    	"真",
    	"务",
    	"具",
    	"万",
    	"每",
    	"目",
    	"至",
    	"达",
    	"走",
    	"积",
    	"示",
    	"议",
    	"声",
    	"报",
    	"斗",
    	"完",
    	"类",
    	"八",
    	"离",
    	"华",
    	"名",
    	"确",
    	"才",
    	"科",
    	"张",
    	"信",
    	"马",
    	"节",
    	"话",
    	"米",
    	"整",
    	"空",
    	"元",
    	"况",
    	"今",
    	"集",
    	"温",
    	"传",
    	"土",
    	"许",
    	"步",
    	"群",
    	"广",
    	"石",
    	"记",
    	"需",
    	"段",
    	"研",
    	"界",
    	"拉",
    	"林",
    	"律",
    	"叫",
    	"且",
    	"究",
    	"观",
    	"越",
    	"织",
    	"装",
    	"影",
    	"算",
    	"低",
    	"持",
    	"音",
    	"众",
    	"书",
    	"布",
    	"复",
    	"容",
    	"儿",
    	"须",
    	"际",
    	"商",
    	"非",
    	"验",
    	"连",
    	"断",
    	"深",
    	"难",
    	"近",
    	"矿",
    	"千",
    	"周",
    	"委",
    	"素",
    	"技",
    	"备",
    	"半",
    	"办",
    	"青",
    	"省",
    	"列",
    	"习",
    	"响",
    	"约",
    	"支",
    	"般",
    	"史",
    	"感",
    	"劳",
    	"便",
    	"团",
    	"往",
    	"酸",
    	"历",
    	"市",
    	"克",
    	"何",
    	"除",
    	"消",
    	"构",
    	"府",
    	"称",
    	"太",
    	"准",
    	"精",
    	"值",
    	"号",
    	"率",
    	"族",
    	"维",
    	"划",
    	"选",
    	"标",
    	"写",
    	"存",
    	"候",
    	"毛",
    	"亲",
    	"快",
    	"效",
    	"斯",
    	"院",
    	"查",
    	"江",
    	"型",
    	"眼",
    	"王",
    	"按",
    	"格",
    	"养",
    	"易",
    	"置",
    	"派",
    	"层",
    	"片",
    	"始",
    	"却",
    	"专",
    	"状",
    	"育",
    	"厂",
    	"京",
    	"识",
    	"适",
    	"属",
    	"圆",
    	"包",
    	"火",
    	"住",
    	"调",
    	"满",
    	"县",
    	"局",
    	"照",
    	"参",
    	"红",
    	"细",
    	"引",
    	"听",
    	"该",
    	"铁",
    	"价",
    	"严",
    	"首",
    	"底",
    	"液",
    	"官",
    	"德",
    	"随",
    	"病",
    	"苏",
    	"失",
    	"尔",
    	"死",
    	"讲",
    	"配",
    	"女",
    	"黄",
    	"推",
    	"显",
    	"谈",
    	"罪",
    	"神",
    	"艺",
    	"呢",
    	"席",
    	"含",
    	"企",
    	"望",
    	"密",
    	"批",
    	"营",
    	"项",
    	"防",
    	"举",
    	"球",
    	"英",
    	"氧",
    	"势",
    	"告",
    	"李",
    	"台",
    	"落",
    	"木",
    	"帮",
    	"轮",
    	"破",
    	"亚",
    	"师",
    	"围",
    	"注",
    	"远",
    	"字",
    	"材",
    	"排",
    	"供",
    	"河",
    	"态",
    	"封",
    	"另",
    	"施",
    	"减",
    	"树",
    	"溶",
    	"怎",
    	"止",
    	"案",
    	"言",
    	"士",
    	"均",
    	"武",
    	"固",
    	"叶",
    	"鱼",
    	"波",
    	"视",
    	"仅",
    	"费",
    	"紧",
    	"爱",
    	"左",
    	"章",
    	"早",
    	"朝",
    	"害",
    	"续",
    	"轻",
    	"服",
    	"试",
    	"食",
    	"充",
    	"兵",
    	"源",
    	"判",
    	"护",
    	"司",
    	"足",
    	"某",
    	"练",
    	"差",
    	"致",
    	"板",
    	"田",
    	"降",
    	"黑",
    	"犯",
    	"负",
    	"击",
    	"范",
    	"继",
    	"兴",
    	"似",
    	"余",
    	"坚",
    	"曲",
    	"输",
    	"修",
    	"故",
    	"城",
    	"夫",
    	"够",
    	"送",
    	"笔",
    	"船",
    	"占",
    	"右",
    	"财",
    	"吃",
    	"富",
    	"春",
    	"职",
    	"觉",
    	"汉",
    	"画",
    	"功",
    	"巴",
    	"跟",
    	"虽",
    	"杂",
    	"飞",
    	"检",
    	"吸",
    	"助",
    	"升",
    	"阳",
    	"互",
    	"初",
    	"创",
    	"抗",
    	"考",
    	"投",
    	"坏",
    	"策",
    	"古",
    	"径",
    	"换",
    	"未",
    	"跑",
    	"留",
    	"钢",
    	"曾",
    	"端",
    	"责",
    	"站",
    	"简",
    	"述",
    	"钱",
    	"副",
    	"尽",
    	"帝",
    	"射",
    	"草",
    	"冲",
    	"承",
    	"独",
    	"令",
    	"限",
    	"阿",
    	"宣",
    	"环",
    	"双",
    	"请",
    	"超",
    	"微",
    	"让",
    	"控",
    	"州",
    	"良",
    	"轴",
    	"找",
    	"否",
    	"纪",
    	"益",
    	"依",
    	"优",
    	"顶",
    	"础",
    	"载",
    	"倒",
    	"房",
    	"突",
    	"坐",
    	"粉",
    	"敌",
    	"略",
    	"客",
    	"袁",
    	"冷",
    	"胜",
    	"绝",
    	"析",
    	"块",
    	"剂",
    	"测",
    	"丝",
    	"协",
    	"诉",
    	"念",
    	"陈",
    	"仍",
    	"罗",
    	"盐",
    	"友",
    	"洋",
    	"错",
    	"苦",
    	"夜",
    	"刑",
    	"移",
    	"频",
    	"逐",
    	"靠",
    	"混",
    	"母",
    	"短",
    	"皮",
    	"终",
    	"聚",
    	"汽",
    	"村",
    	"云",
    	"哪",
    	"既",
    	"距",
    	"卫",
    	"停",
    	"烈",
    	"央",
    	"察",
    	"烧",
    	"迅",
    	"境",
    	"若",
    	"印",
    	"洲",
    	"刻",
    	"括",
    	"激",
    	"孔",
    	"搞",
    	"甚",
    	"室",
    	"待",
    	"核",
    	"校",
    	"散",
    	"侵",
    	"吧",
    	"甲",
    	"游",
    	"久",
    	"菜",
    	"味",
    	"旧",
    	"模",
    	"湖",
    	"货",
    	"损",
    	"预",
    	"阻",
    	"毫",
    	"普",
    	"稳",
    	"乙",
    	"妈",
    	"植",
    	"息",
    	"扩",
    	"银",
    	"语",
    	"挥",
    	"酒",
    	"守",
    	"拿",
    	"序",
    	"纸",
    	"医",
    	"缺",
    	"雨",
    	"吗",
    	"针",
    	"刘",
    	"啊",
    	"急",
    	"唱",
    	"误",
    	"训",
    	"愿",
    	"审",
    	"附",
    	"获",
    	"茶",
    	"鲜",
    	"粮",
    	"斤",
    	"孩",
    	"脱",
    	"硫",
    	"肥",
    	"善",
    	"龙",
    	"演",
    	"父",
    	"渐",
    	"血",
    	"欢",
    	"械",
    	"掌",
    	"歌",
    	"沙",
    	"刚",
    	"攻",
    	"谓",
    	"盾",
    	"讨",
    	"晚",
    	"粒",
    	"乱",
    	"燃",
    	"矛",
    	"乎",
    	"杀",
    	"药",
    	"宁",
    	"鲁",
    	"贵",
    	"钟",
    	"煤",
    	"读",
    	"班",
    	"伯",
    	"香",
    	"介",
    	"迫",
    	"句",
    	"丰",
    	"培",
    	"握",
    	"兰",
    	"担",
    	"弦",
    	"蛋",
    	"沉",
    	"假",
    	"穿",
    	"执",
    	"答",
    	"乐",
    	"谁",
    	"顺",
    	"烟",
    	"缩",
    	"征",
    	"脸",
    	"喜",
    	"松",
    	"脚",
    	"困",
    	"异",
    	"免",
    	"背",
    	"星",
    	"福",
    	"买",
    	"染",
    	"井",
    	"概",
    	"慢",
    	"怕",
    	"磁",
    	"倍",
    	"祖",
    	"皇",
    	"促",
    	"静",
    	"补",
    	"评",
    	"翻",
    	"肉",
    	"践",
    	"尼",
    	"衣",
    	"宽",
    	"扬",
    	"棉",
    	"希",
    	"伤",
    	"操",
    	"垂",
    	"秋",
    	"宜",
    	"氢",
    	"套",
    	"督",
    	"振",
    	"架",
    	"亮",
    	"末",
    	"宪",
    	"庆",
    	"编",
    	"牛",
    	"触",
    	"映",
    	"雷",
    	"销",
    	"诗",
    	"座",
    	"居",
    	"抓",
    	"裂",
    	"胞",
    	"呼",
    	"娘",
    	"景",
    	"威",
    	"绿",
    	"晶",
    	"厚",
    	"盟",
    	"衡",
    	"鸡",
    	"孙",
    	"延",
    	"危",
    	"胶",
    	"屋",
    	"乡",
    	"临",
    	"陆",
    	"顾",
    	"掉",
    	"呀",
    	"灯",
    	"岁",
    	"措",
    	"束",
    	"耐",
    	"剧",
    	"玉",
    	"赵",
    	"跳",
    	"哥",
    	"季",
    	"课",
    	"凯",
    	"胡",
    	"额",
    	"款",
    	"绍",
    	"卷",
    	"齐",
    	"伟",
    	"蒸",
    	"殖",
    	"永",
    	"宗",
    	"苗",
    	"川",
    	"炉",
    	"岩",
    	"弱",
    	"零",
    	"杨",
    	"奏",
    	"沿",
    	"露",
    	"杆",
    	"探",
    	"滑",
    	"镇",
    	"饭",
    	"浓",
    	"航",
    	"怀",
    	"赶",
    	"库",
    	"夺",
    	"伊",
    	"灵",
    	"税",
    	"途",
    	"灭",
    	"赛",
    	"归",
    	"召",
    	"鼓",
    	"播",
    	"盘",
    	"裁",
    	"险",
    	"康",
    	"唯",
    	"录",
    	"菌",
    	"纯",
    	"借",
    	"糖",
    	"盖",
    	"横",
    	"符",
    	"私",
    	"努",
    	"堂",
    	"域",
    	"枪",
    	"润",
    	"幅",
    	"哈",
    	"竟",
    	"熟",
    	"虫",
    	"泽",
    	"脑",
    	"壤",
    	"碳",
    	"欧",
    	"遍",
    	"侧",
    	"寨",
    	"敢",
    	"彻",
    	"虑",
    	"斜",
    	"薄",
    	"庭",
    	"纳",
    	"弹",
    	"饲",
    	"伸",
    	"折",
    	"麦",
    	"湿",
    	"暗",
    	"荷",
    	"瓦",
    	"塞",
    	"床",
    	"筑",
    	"恶",
    	"户",
    	"访",
    	"塔",
    	"奇",
    	"透",
    	"梁",
    	"刀",
    	"旋",
    	"迹",
    	"卡",
    	"氯",
    	"遇",
    	"份",
    	"毒",
    	"泥",
    	"退",
    	"洗",
    	"摆",
    	"灰",
    	"彩",
    	"卖",
    	"耗",
    	"夏",
    	"择",
    	"忙",
    	"铜",
    	"献",
    	"硬",
    	"予",
    	"繁",
    	"圈",
    	"雪",
    	"函",
    	"亦",
    	"抽",
    	"篇",
    	"阵",
    	"阴",
    	"丁",
    	"尺",
    	"追",
    	"堆",
    	"雄",
    	"迎",
    	"泛",
    	"爸",
    	"楼",
    	"避",
    	"谋",
    	"吨",
    	"野",
    	"猪",
    	"旗",
    	"累",
    	"偏",
    	"典",
    	"馆",
    	"索",
    	"秦",
    	"脂",
    	"潮",
    	"爷",
    	"豆",
    	"忽",
    	"托",
    	"惊",
    	"塑",
    	"遗",
    	"愈",
    	"朱",
    	"替",
    	"纤",
    	"粗",
    	"倾",
    	"尚",
    	"痛",
    	"楚",
    	"谢",
    	"奋",
    	"购",
    	"磨",
    	"君",
    	"池",
    	"旁",
    	"碎",
    	"骨",
    	"监",
    	"捕",
    	"弟",
    	"暴",
    	"割",
    	"贯",
    	"殊",
    	"释",
    	"词",
    	"亡",
    	"壁",
    	"顿",
    	"宝",
    	"午",
    	"尘",
    	"闻",
    	"揭",
    	"炮",
    	"残",
    	"冬",
    	"桥",
    	"妇",
    	"警",
    	"综",
    	"招",
    	"吴",
    	"付",
    	"浮",
    	"遭",
    	"徐",
    	"您",
    	"摇",
    	"谷",
    	"赞",
    	"箱",
    	"隔",
    	"订",
    	"男",
    	"吹",
    	"园",
    	"纷",
    	"唐",
    	"败",
    	"宋",
    	"玻",
    	"巨",
    	"耕",
    	"坦",
    	"荣",
    	"闭",
    	"湾",
    	"键",
    	"凡",
    	"驻",
    	"锅",
    	"救",
    	"恩",
    	"剥",
    	"凝",
    	"碱",
    	"齿",
    	"截",
    	"炼",
    	"麻",
    	"纺",
    	"禁",
    	"废",
    	"盛",
    	"版",
    	"缓",
    	"净",
    	"睛",
    	"昌",
    	"婚",
    	"涉",
    	"筒",
    	"嘴",
    	"插",
    	"岸",
    	"朗",
    	"庄",
    	"街",
    	"藏",
    	"姑",
    	"贸",
    	"腐",
    	"奴",
    	"啦",
    	"惯",
    	"乘",
    	"伙",
    	"恢",
    	"匀",
    	"纱",
    	"扎",
    	"辩",
    	"耳",
    	"彪",
    	"臣",
    	"亿",
    	"璃",
    	"抵",
    	"脉",
    	"秀",
    	"萨",
    	"俄",
    	"网",
    	"舞",
    	"店",
    	"喷",
    	"纵",
    	"寸",
    	"汗",
    	"挂",
    	"洪",
    	"贺",
    	"闪",
    	"柬",
    	"爆",
    	"烯",
    	"津",
    	"稻",
    	"墙",
    	"软",
    	"勇",
    	"像",
    	"滚",
    	"厘",
    	"蒙",
    	"芳",
    	"肯",
    	"坡",
    	"柱",
    	"荡",
    	"腿",
    	"仪",
    	"旅",
    	"尾",
    	"轧",
    	"冰",
    	"贡",
    	"登",
    	"黎",
    	"削",
    	"钻",
    	"勒",
    	"逃",
    	"障",
    	"氨",
    	"郭",
    	"峰",
    	"币",
    	"港",
    	"伏",
    	"轨",
    	"亩",
    	"毕",
    	"擦",
    	"莫",
    	"刺",
    	"浪",
    	"秘",
    	"援",
    	"株",
    	"健",
    	"售",
    	"股",
    	"岛",
    	"甘",
    	"泡",
    	"睡",
    	"童",
    	"铸",
    	"汤",
    	"阀",
    	"休",
    	"汇",
    	"舍",
    	"牧",
    	"绕",
    	"炸",
    	"哲",
    	"磷",
    	"绩",
    	"朋",
    	"淡",
    	"尖",
    	"启",
    	"陷",
    	"柴",
    	"呈",
    	"徒",
    	"颜",
    	"泪",
    	"稍",
    	"忘",
    	"泵",
    	"蓝",
    	"拖",
    	"洞",
    	"授",
    	"镜",
    	"辛",
    	"壮",
    	"锋",
    	"贫",
    	"虚",
    	"弯",
    	"摩",
    	"泰",
    	"幼",
    	"廷",
    	"尊",
    	"窗",
    	"纲",
    	"弄",
    	"隶",
    	"疑",
    	"氏",
    	"宫",
    	"姐",
    	"震",
    	"瑞",
    	"怪",
    	"尤",
    	"琴",
    	"循",
    	"描",
    	"膜",
    	"违",
    	"夹",
    	"腰",
    	"缘",
    	"珠",
    	"穷",
    	"森",
    	"枝",
    	"竹",
    	"沟",
    	"催",
    	"绳",
    	"忆",
    	"邦",
    	"剩",
    	"幸",
    	"浆",
    	"栏",
    	"拥",
    	"牙",
    	"贮",
    	"礼",
    	"滤",
    	"钠",
    	"纹",
    	"罢",
    	"拍",
    	"咱",
    	"喊",
    	"袖",
    	"埃",
    	"勤",
    	"罚",
    	"焦",
    	"潜",
    	"伍",
    	"墨",
    	"欲",
    	"缝",
    	"姓",
    	"刊",
    	"饱",
    	"仿",
    	"奖",
    	"铝",
    	"鬼",
    	"丽",
    	"跨",
    	"默",
    	"挖",
    	"链",
    	"扫",
    	"喝",
    	"袋",
    	"炭",
    	"污",
    	"幕",
    	"诸",
    	"弧",
    	"励",
    	"梅",
    	"奶",
    	"洁",
    	"灾",
    	"舟",
    	"鉴",
    	"苯",
    	"讼",
    	"抱",
    	"毁",
    	"懂",
    	"寒",
    	"智",
    	"埔",
    	"寄",
    	"届",
    	"跃",
    	"渡",
    	"挑",
    	"丹",
    	"艰",
    	"贝",
    	"碰",
    	"拔",
    	"爹",
    	"戴",
    	"码",
    	"梦",
    	"芽",
    	"熔",
    	"赤",
    	"渔",
    	"哭",
    	"敬",
    	"颗",
    	"奔",
    	"铅",
    	"仲",
    	"虎",
    	"稀",
    	"妹",
    	"乏",
    	"珍",
    	"申",
    	"桌",
    	"遵",
    	"允",
    	"隆",
    	"螺",
    	"仓",
    	"魏",
    	"锐",
    	"晓",
    	"氮",
    	"兼",
    	"隐",
    	"碍",
    	"赫",
    	"拨",
    	"忠",
    	"肃",
    	"缸",
    	"牵",
    	"抢",
    	"博",
    	"巧",
    	"壳",
    	"兄",
    	"杜",
    	"讯",
    	"诚",
    	"碧",
    	"祥",
    	"柯",
    	"页",
    	"巡",
    	"矩",
    	"悲",
    	"灌",
    	"龄",
    	"伦",
    	"票",
    	"寻",
    	"桂",
    	"铺",
    	"圣",
    	"恐",
    	"恰",
    	"郑",
    	"趣",
    	"抬",
    	"荒",
    	"腾",
    	"贴",
    	"柔",
    	"滴",
    	"猛",
    	"阔",
    	"辆",
    	"妻",
    	"填",
    	"撤",
    	"储",
    	"签",
    	"闹",
    	"扰",
    	"紫",
    	"砂",
    	"递",
    	"戏",
    	"吊",
    	"陶",
    	"伐",
    	"喂",
    	"疗",
    	"瓶",
    	"婆",
    	"抚",
    	"臂",
    	"摸",
    	"忍",
    	"虾",
    	"蜡",
    	"邻",
    	"胸",
    	"巩",
    	"挤",
    	"偶",
    	"弃",
    	"槽",
    	"劲",
    	"乳",
    	"邓",
    	"吉",
    	"仁",
    	"烂",
    	"砖",
    	"租",
    	"乌",
    	"舰",
    	"伴",
    	"瓜",
    	"浅",
    	"丙",
    	"暂",
    	"燥",
    	"橡",
    	"柳",
    	"迷",
    	"暖",
    	"牌",
    	"秧",
    	"胆",
    	"详",
    	"簧",
    	"踏",
    	"瓷",
    	"谱",
    	"呆",
    	"宾",
    	"糊",
    	"洛",
    	"辉",
    	"愤",
    	"竞",
    	"隙",
    	"怒",
    	"粘",
    	"乃",
    	"绪",
    	"肩",
    	"籍",
    	"敏",
    	"涂",
    	"熙",
    	"皆",
    	"侦",
    	"悬",
    	"掘",
    	"享",
    	"纠",
    	"醒",
    	"狂",
    	"锁",
    	"淀",
    	"恨",
    	"牲",
    	"霸",
    	"爬",
    	"赏",
    	"逆",
    	"玩",
    	"陵",
    	"祝",
    	"秒",
    	"浙",
    	"貌",
    	"役",
    	"彼",
    	"悉",
    	"鸭",
    	"趋",
    	"凤",
    	"晨",
    	"畜",
    	"辈",
    	"秩",
    	"卵",
    	"署",
    	"梯",
    	"炎",
    	"滩",
    	"棋",
    	"驱",
    	"筛",
    	"峡",
    	"冒",
    	"啥",
    	"寿",
    	"译",
    	"浸",
    	"泉",
    	"帽",
    	"迟",
    	"硅",
    	"疆",
    	"贷",
    	"漏",
    	"稿",
    	"冠",
    	"嫩",
    	"胁",
    	"芯",
    	"牢",
    	"叛",
    	"蚀",
    	"奥",
    	"鸣",
    	"岭",
    	"羊",
    	"凭",
    	"串",
    	"塘",
    	"绘",
    	"酵",
    	"融",
    	"盆",
    	"锡",
    	"庙",
    	"筹",
    	"冻",
    	"辅",
    	"摄",
    	"袭",
    	"筋",
    	"拒",
    	"僚",
    	"旱",
    	"钾",
    	"鸟",
    	"漆",
    	"沈",
    	"眉",
    	"疏",
    	"添",
    	"棒",
    	"穗",
    	"硝",
    	"韩",
    	"逼",
    	"扭",
    	"侨",
    	"凉",
    	"挺",
    	"碗",
    	"栽",
    	"炒",
    	"杯",
    	"患",
    	"馏",
    	"劝",
    	"豪",
    	"辽",
    	"勃",
    	"鸿",
    	"旦",
    	"吏",
    	"拜",
    	"狗",
    	"埋",
    	"辊",
    	"掩",
    	"饮",
    	"搬",
    	"骂",
    	"辞",
    	"勾",
    	"扣",
    	"估",
    	"蒋",
    	"绒",
    	"雾",
    	"丈",
    	"朵",
    	"姆",
    	"拟",
    	"宇",
    	"辑",
    	"陕",
    	"雕",
    	"偿",
    	"蓄",
    	"崇",
    	"剪",
    	"倡",
    	"厅",
    	"咬",
    	"驶",
    	"薯",
    	"刷",
    	"斥",
    	"番",
    	"赋",
    	"奉",
    	"佛",
    	"浇",
    	"漫",
    	"曼",
    	"扇",
    	"钙",
    	"桃",
    	"扶",
    	"仔",
    	"返",
    	"俗",
    	"亏",
    	"腔",
    	"鞋",
    	"棱",
    	"覆",
    	"框",
    	"悄",
    	"叔",
    	"撞",
    	"骗",
    	"勘",
    	"旺",
    	"沸",
    	"孤",
    	"吐",
    	"孟",
    	"渠",
    	"屈",
    	"疾",
    	"妙",
    	"惜",
    	"仰",
    	"狠",
    	"胀",
    	"谐",
    	"抛",
    	"霉",
    	"桑",
    	"岗",
    	"嘛",
    	"衰",
    	"盗",
    	"渗",
    	"脏",
    	"赖",
    	"涌",
    	"甜",
    	"曹",
    	"阅",
    	"肌",
    	"哩",
    	"厉",
    	"烃",
    	"纬",
    	"毅",
    	"昨",
    	"伪",
    	"症",
    	"煮",
    	"叹",
    	"钉",
    	"搭",
    	"茎",
    	"笼",
    	"酷",
    	"偷",
    	"弓",
    	"锥",
    	"恒",
    	"杰",
    	"坑",
    	"鼻",
    	"翼",
    	"纶",
    	"叙",
    	"狱",
    	"逮",
    	"罐",
    	"络",
    	"棚",
    	"抑",
    	"膨",
    	"蔬",
    	"寺",
    	"骤",
    	"穆",
    	"冶",
    	"枯",
    	"册",
    	"尸",
    	"凸",
    	"绅",
    	"坯",
    	"牺",
    	"焰",
    	"轰",
    	"欣",
    	"晋",
    	"瘦",
    	"御",
    	"锭",
    	"锦",
    	"丧",
    	"旬",
    	"锻",
    	"垄",
    	"搜",
    	"扑",
    	"邀",
    	"亭",
    	"酯",
    	"迈",
    	"舒",
    	"脆",
    	"酶",
    	"闲",
    	"忧",
    	"酚",
    	"顽",
    	"羽",
    	"涨",
    	"卸",
    	"仗",
    	"陪",
    	"辟",
    	"惩",
    	"杭",
    	"姚",
    	"肚",
    	"捉",
    	"飘",
    	"漂",
    	"昆",
    	"欺",
    	"吾",
    	"郎",
    	"烷",
    	"汁",
    	"呵",
    	"饰",
    	"萧",
    	"雅",
    	"邮",
    	"迁",
    	"燕",
    	"撒",
    	"姻",
    	"赴",
    	"宴",
    	"烦",
    	"债",
    	"帐",
    	"斑",
    	"铃",
    	"旨",
    	"醇",
    	"董",
    	"饼",
    	"雏",
    	"姿",
    	"拌",
    	"傅",
    	"腹",
    	"妥",
    	"揉",
    	"贤",
    	"拆",
    	"歪",
    	"葡",
    	"胺",
    	"丢",
    	"浩",
    	"徽",
    	"昂",
    	"垫",
    	"挡",
    	"览",
    	"贪",
    	"慰",
    	"缴",
    	"汪",
    	"慌",
    	"冯",
    	"诺",
    	"姜",
    	"谊",
    	"凶",
    	"劣",
    	"诬",
    	"耀",
    	"昏",
    	"躺",
    	"盈",
    	"骑",
    	"乔",
    	"溪",
    	"丛",
    	"卢",
    	"抹",
    	"闷",
    	"咨",
    	"刮",
    	"驾",
    	"缆",
    	"悟",
    	"摘",
    	"铒",
    	"掷",
    	"颇",
    	"幻",
    	"柄",
    	"惠",
    	"惨",
    	"佳",
    	"仇",
    	"腊",
    	"窝",
    	"涤",
    	"剑",
    	"瞧",
    	"堡",
    	"泼",
    	"葱",
    	"罩",
    	"霍",
    	"捞",
    	"胎",
    	"苍",
    	"滨",
    	"俩",
    	"捅",
    	"湘",
    	"砍",
    	"霞",
    	"邵",
    	"萄",
    	"疯",
    	"淮",
    	"遂",
    	"熊",
    	"粪",
    	"烘",
    	"宿",
    	"档",
    	"戈",
    	"驳",
    	"嫂",
    	"裕",
    	"徙",
    	"箭",
    	"捐",
    	"肠",
    	"撑",
    	"晒",
    	"辨",
    	"殿",
    	"莲",
    	"摊",
    	"搅",
    	"酱",
    	"屏",
    	"疫",
    	"哀",
    	"蔡",
    	"堵",
    	"沫",
    	"皱",
    	"畅",
    	"叠",
    	"阁",
    	"莱",
    	"敲",
    	"辖",
    	"钩",
    	"痕",
    	"坝",
    	"巷",
    	"饿",
    	"祸",
    	"丘",
    	"玄",
    	"溜",
    	"曰",
    	"逻",
    	"彭",
    	"尝",
    	"卿",
    	"妨",
    	"艇",
    	"吞",
    	"韦",
    	"怨",
    	"矮",
    	"歇"
    ];

    var require$$2$1 = [
    	"的",
    	"一",
    	"是",
    	"在",
    	"不",
    	"了",
    	"有",
    	"和",
    	"人",
    	"這",
    	"中",
    	"大",
    	"為",
    	"上",
    	"個",
    	"國",
    	"我",
    	"以",
    	"要",
    	"他",
    	"時",
    	"來",
    	"用",
    	"們",
    	"生",
    	"到",
    	"作",
    	"地",
    	"於",
    	"出",
    	"就",
    	"分",
    	"對",
    	"成",
    	"會",
    	"可",
    	"主",
    	"發",
    	"年",
    	"動",
    	"同",
    	"工",
    	"也",
    	"能",
    	"下",
    	"過",
    	"子",
    	"說",
    	"產",
    	"種",
    	"面",
    	"而",
    	"方",
    	"後",
    	"多",
    	"定",
    	"行",
    	"學",
    	"法",
    	"所",
    	"民",
    	"得",
    	"經",
    	"十",
    	"三",
    	"之",
    	"進",
    	"著",
    	"等",
    	"部",
    	"度",
    	"家",
    	"電",
    	"力",
    	"裡",
    	"如",
    	"水",
    	"化",
    	"高",
    	"自",
    	"二",
    	"理",
    	"起",
    	"小",
    	"物",
    	"現",
    	"實",
    	"加",
    	"量",
    	"都",
    	"兩",
    	"體",
    	"制",
    	"機",
    	"當",
    	"使",
    	"點",
    	"從",
    	"業",
    	"本",
    	"去",
    	"把",
    	"性",
    	"好",
    	"應",
    	"開",
    	"它",
    	"合",
    	"還",
    	"因",
    	"由",
    	"其",
    	"些",
    	"然",
    	"前",
    	"外",
    	"天",
    	"政",
    	"四",
    	"日",
    	"那",
    	"社",
    	"義",
    	"事",
    	"平",
    	"形",
    	"相",
    	"全",
    	"表",
    	"間",
    	"樣",
    	"與",
    	"關",
    	"各",
    	"重",
    	"新",
    	"線",
    	"內",
    	"數",
    	"正",
    	"心",
    	"反",
    	"你",
    	"明",
    	"看",
    	"原",
    	"又",
    	"麼",
    	"利",
    	"比",
    	"或",
    	"但",
    	"質",
    	"氣",
    	"第",
    	"向",
    	"道",
    	"命",
    	"此",
    	"變",
    	"條",
    	"只",
    	"沒",
    	"結",
    	"解",
    	"問",
    	"意",
    	"建",
    	"月",
    	"公",
    	"無",
    	"系",
    	"軍",
    	"很",
    	"情",
    	"者",
    	"最",
    	"立",
    	"代",
    	"想",
    	"已",
    	"通",
    	"並",
    	"提",
    	"直",
    	"題",
    	"黨",
    	"程",
    	"展",
    	"五",
    	"果",
    	"料",
    	"象",
    	"員",
    	"革",
    	"位",
    	"入",
    	"常",
    	"文",
    	"總",
    	"次",
    	"品",
    	"式",
    	"活",
    	"設",
    	"及",
    	"管",
    	"特",
    	"件",
    	"長",
    	"求",
    	"老",
    	"頭",
    	"基",
    	"資",
    	"邊",
    	"流",
    	"路",
    	"級",
    	"少",
    	"圖",
    	"山",
    	"統",
    	"接",
    	"知",
    	"較",
    	"將",
    	"組",
    	"見",
    	"計",
    	"別",
    	"她",
    	"手",
    	"角",
    	"期",
    	"根",
    	"論",
    	"運",
    	"農",
    	"指",
    	"幾",
    	"九",
    	"區",
    	"強",
    	"放",
    	"決",
    	"西",
    	"被",
    	"幹",
    	"做",
    	"必",
    	"戰",
    	"先",
    	"回",
    	"則",
    	"任",
    	"取",
    	"據",
    	"處",
    	"隊",
    	"南",
    	"給",
    	"色",
    	"光",
    	"門",
    	"即",
    	"保",
    	"治",
    	"北",
    	"造",
    	"百",
    	"規",
    	"熱",
    	"領",
    	"七",
    	"海",
    	"口",
    	"東",
    	"導",
    	"器",
    	"壓",
    	"志",
    	"世",
    	"金",
    	"增",
    	"爭",
    	"濟",
    	"階",
    	"油",
    	"思",
    	"術",
    	"極",
    	"交",
    	"受",
    	"聯",
    	"什",
    	"認",
    	"六",
    	"共",
    	"權",
    	"收",
    	"證",
    	"改",
    	"清",
    	"美",
    	"再",
    	"採",
    	"轉",
    	"更",
    	"單",
    	"風",
    	"切",
    	"打",
    	"白",
    	"教",
    	"速",
    	"花",
    	"帶",
    	"安",
    	"場",
    	"身",
    	"車",
    	"例",
    	"真",
    	"務",
    	"具",
    	"萬",
    	"每",
    	"目",
    	"至",
    	"達",
    	"走",
    	"積",
    	"示",
    	"議",
    	"聲",
    	"報",
    	"鬥",
    	"完",
    	"類",
    	"八",
    	"離",
    	"華",
    	"名",
    	"確",
    	"才",
    	"科",
    	"張",
    	"信",
    	"馬",
    	"節",
    	"話",
    	"米",
    	"整",
    	"空",
    	"元",
    	"況",
    	"今",
    	"集",
    	"溫",
    	"傳",
    	"土",
    	"許",
    	"步",
    	"群",
    	"廣",
    	"石",
    	"記",
    	"需",
    	"段",
    	"研",
    	"界",
    	"拉",
    	"林",
    	"律",
    	"叫",
    	"且",
    	"究",
    	"觀",
    	"越",
    	"織",
    	"裝",
    	"影",
    	"算",
    	"低",
    	"持",
    	"音",
    	"眾",
    	"書",
    	"布",
    	"复",
    	"容",
    	"兒",
    	"須",
    	"際",
    	"商",
    	"非",
    	"驗",
    	"連",
    	"斷",
    	"深",
    	"難",
    	"近",
    	"礦",
    	"千",
    	"週",
    	"委",
    	"素",
    	"技",
    	"備",
    	"半",
    	"辦",
    	"青",
    	"省",
    	"列",
    	"習",
    	"響",
    	"約",
    	"支",
    	"般",
    	"史",
    	"感",
    	"勞",
    	"便",
    	"團",
    	"往",
    	"酸",
    	"歷",
    	"市",
    	"克",
    	"何",
    	"除",
    	"消",
    	"構",
    	"府",
    	"稱",
    	"太",
    	"準",
    	"精",
    	"值",
    	"號",
    	"率",
    	"族",
    	"維",
    	"劃",
    	"選",
    	"標",
    	"寫",
    	"存",
    	"候",
    	"毛",
    	"親",
    	"快",
    	"效",
    	"斯",
    	"院",
    	"查",
    	"江",
    	"型",
    	"眼",
    	"王",
    	"按",
    	"格",
    	"養",
    	"易",
    	"置",
    	"派",
    	"層",
    	"片",
    	"始",
    	"卻",
    	"專",
    	"狀",
    	"育",
    	"廠",
    	"京",
    	"識",
    	"適",
    	"屬",
    	"圓",
    	"包",
    	"火",
    	"住",
    	"調",
    	"滿",
    	"縣",
    	"局",
    	"照",
    	"參",
    	"紅",
    	"細",
    	"引",
    	"聽",
    	"該",
    	"鐵",
    	"價",
    	"嚴",
    	"首",
    	"底",
    	"液",
    	"官",
    	"德",
    	"隨",
    	"病",
    	"蘇",
    	"失",
    	"爾",
    	"死",
    	"講",
    	"配",
    	"女",
    	"黃",
    	"推",
    	"顯",
    	"談",
    	"罪",
    	"神",
    	"藝",
    	"呢",
    	"席",
    	"含",
    	"企",
    	"望",
    	"密",
    	"批",
    	"營",
    	"項",
    	"防",
    	"舉",
    	"球",
    	"英",
    	"氧",
    	"勢",
    	"告",
    	"李",
    	"台",
    	"落",
    	"木",
    	"幫",
    	"輪",
    	"破",
    	"亞",
    	"師",
    	"圍",
    	"注",
    	"遠",
    	"字",
    	"材",
    	"排",
    	"供",
    	"河",
    	"態",
    	"封",
    	"另",
    	"施",
    	"減",
    	"樹",
    	"溶",
    	"怎",
    	"止",
    	"案",
    	"言",
    	"士",
    	"均",
    	"武",
    	"固",
    	"葉",
    	"魚",
    	"波",
    	"視",
    	"僅",
    	"費",
    	"緊",
    	"愛",
    	"左",
    	"章",
    	"早",
    	"朝",
    	"害",
    	"續",
    	"輕",
    	"服",
    	"試",
    	"食",
    	"充",
    	"兵",
    	"源",
    	"判",
    	"護",
    	"司",
    	"足",
    	"某",
    	"練",
    	"差",
    	"致",
    	"板",
    	"田",
    	"降",
    	"黑",
    	"犯",
    	"負",
    	"擊",
    	"范",
    	"繼",
    	"興",
    	"似",
    	"餘",
    	"堅",
    	"曲",
    	"輸",
    	"修",
    	"故",
    	"城",
    	"夫",
    	"夠",
    	"送",
    	"筆",
    	"船",
    	"佔",
    	"右",
    	"財",
    	"吃",
    	"富",
    	"春",
    	"職",
    	"覺",
    	"漢",
    	"畫",
    	"功",
    	"巴",
    	"跟",
    	"雖",
    	"雜",
    	"飛",
    	"檢",
    	"吸",
    	"助",
    	"昇",
    	"陽",
    	"互",
    	"初",
    	"創",
    	"抗",
    	"考",
    	"投",
    	"壞",
    	"策",
    	"古",
    	"徑",
    	"換",
    	"未",
    	"跑",
    	"留",
    	"鋼",
    	"曾",
    	"端",
    	"責",
    	"站",
    	"簡",
    	"述",
    	"錢",
    	"副",
    	"盡",
    	"帝",
    	"射",
    	"草",
    	"衝",
    	"承",
    	"獨",
    	"令",
    	"限",
    	"阿",
    	"宣",
    	"環",
    	"雙",
    	"請",
    	"超",
    	"微",
    	"讓",
    	"控",
    	"州",
    	"良",
    	"軸",
    	"找",
    	"否",
    	"紀",
    	"益",
    	"依",
    	"優",
    	"頂",
    	"礎",
    	"載",
    	"倒",
    	"房",
    	"突",
    	"坐",
    	"粉",
    	"敵",
    	"略",
    	"客",
    	"袁",
    	"冷",
    	"勝",
    	"絕",
    	"析",
    	"塊",
    	"劑",
    	"測",
    	"絲",
    	"協",
    	"訴",
    	"念",
    	"陳",
    	"仍",
    	"羅",
    	"鹽",
    	"友",
    	"洋",
    	"錯",
    	"苦",
    	"夜",
    	"刑",
    	"移",
    	"頻",
    	"逐",
    	"靠",
    	"混",
    	"母",
    	"短",
    	"皮",
    	"終",
    	"聚",
    	"汽",
    	"村",
    	"雲",
    	"哪",
    	"既",
    	"距",
    	"衛",
    	"停",
    	"烈",
    	"央",
    	"察",
    	"燒",
    	"迅",
    	"境",
    	"若",
    	"印",
    	"洲",
    	"刻",
    	"括",
    	"激",
    	"孔",
    	"搞",
    	"甚",
    	"室",
    	"待",
    	"核",
    	"校",
    	"散",
    	"侵",
    	"吧",
    	"甲",
    	"遊",
    	"久",
    	"菜",
    	"味",
    	"舊",
    	"模",
    	"湖",
    	"貨",
    	"損",
    	"預",
    	"阻",
    	"毫",
    	"普",
    	"穩",
    	"乙",
    	"媽",
    	"植",
    	"息",
    	"擴",
    	"銀",
    	"語",
    	"揮",
    	"酒",
    	"守",
    	"拿",
    	"序",
    	"紙",
    	"醫",
    	"缺",
    	"雨",
    	"嗎",
    	"針",
    	"劉",
    	"啊",
    	"急",
    	"唱",
    	"誤",
    	"訓",
    	"願",
    	"審",
    	"附",
    	"獲",
    	"茶",
    	"鮮",
    	"糧",
    	"斤",
    	"孩",
    	"脫",
    	"硫",
    	"肥",
    	"善",
    	"龍",
    	"演",
    	"父",
    	"漸",
    	"血",
    	"歡",
    	"械",
    	"掌",
    	"歌",
    	"沙",
    	"剛",
    	"攻",
    	"謂",
    	"盾",
    	"討",
    	"晚",
    	"粒",
    	"亂",
    	"燃",
    	"矛",
    	"乎",
    	"殺",
    	"藥",
    	"寧",
    	"魯",
    	"貴",
    	"鐘",
    	"煤",
    	"讀",
    	"班",
    	"伯",
    	"香",
    	"介",
    	"迫",
    	"句",
    	"豐",
    	"培",
    	"握",
    	"蘭",
    	"擔",
    	"弦",
    	"蛋",
    	"沉",
    	"假",
    	"穿",
    	"執",
    	"答",
    	"樂",
    	"誰",
    	"順",
    	"煙",
    	"縮",
    	"徵",
    	"臉",
    	"喜",
    	"松",
    	"腳",
    	"困",
    	"異",
    	"免",
    	"背",
    	"星",
    	"福",
    	"買",
    	"染",
    	"井",
    	"概",
    	"慢",
    	"怕",
    	"磁",
    	"倍",
    	"祖",
    	"皇",
    	"促",
    	"靜",
    	"補",
    	"評",
    	"翻",
    	"肉",
    	"踐",
    	"尼",
    	"衣",
    	"寬",
    	"揚",
    	"棉",
    	"希",
    	"傷",
    	"操",
    	"垂",
    	"秋",
    	"宜",
    	"氫",
    	"套",
    	"督",
    	"振",
    	"架",
    	"亮",
    	"末",
    	"憲",
    	"慶",
    	"編",
    	"牛",
    	"觸",
    	"映",
    	"雷",
    	"銷",
    	"詩",
    	"座",
    	"居",
    	"抓",
    	"裂",
    	"胞",
    	"呼",
    	"娘",
    	"景",
    	"威",
    	"綠",
    	"晶",
    	"厚",
    	"盟",
    	"衡",
    	"雞",
    	"孫",
    	"延",
    	"危",
    	"膠",
    	"屋",
    	"鄉",
    	"臨",
    	"陸",
    	"顧",
    	"掉",
    	"呀",
    	"燈",
    	"歲",
    	"措",
    	"束",
    	"耐",
    	"劇",
    	"玉",
    	"趙",
    	"跳",
    	"哥",
    	"季",
    	"課",
    	"凱",
    	"胡",
    	"額",
    	"款",
    	"紹",
    	"卷",
    	"齊",
    	"偉",
    	"蒸",
    	"殖",
    	"永",
    	"宗",
    	"苗",
    	"川",
    	"爐",
    	"岩",
    	"弱",
    	"零",
    	"楊",
    	"奏",
    	"沿",
    	"露",
    	"桿",
    	"探",
    	"滑",
    	"鎮",
    	"飯",
    	"濃",
    	"航",
    	"懷",
    	"趕",
    	"庫",
    	"奪",
    	"伊",
    	"靈",
    	"稅",
    	"途",
    	"滅",
    	"賽",
    	"歸",
    	"召",
    	"鼓",
    	"播",
    	"盤",
    	"裁",
    	"險",
    	"康",
    	"唯",
    	"錄",
    	"菌",
    	"純",
    	"借",
    	"糖",
    	"蓋",
    	"橫",
    	"符",
    	"私",
    	"努",
    	"堂",
    	"域",
    	"槍",
    	"潤",
    	"幅",
    	"哈",
    	"竟",
    	"熟",
    	"蟲",
    	"澤",
    	"腦",
    	"壤",
    	"碳",
    	"歐",
    	"遍",
    	"側",
    	"寨",
    	"敢",
    	"徹",
    	"慮",
    	"斜",
    	"薄",
    	"庭",
    	"納",
    	"彈",
    	"飼",
    	"伸",
    	"折",
    	"麥",
    	"濕",
    	"暗",
    	"荷",
    	"瓦",
    	"塞",
    	"床",
    	"築",
    	"惡",
    	"戶",
    	"訪",
    	"塔",
    	"奇",
    	"透",
    	"梁",
    	"刀",
    	"旋",
    	"跡",
    	"卡",
    	"氯",
    	"遇",
    	"份",
    	"毒",
    	"泥",
    	"退",
    	"洗",
    	"擺",
    	"灰",
    	"彩",
    	"賣",
    	"耗",
    	"夏",
    	"擇",
    	"忙",
    	"銅",
    	"獻",
    	"硬",
    	"予",
    	"繁",
    	"圈",
    	"雪",
    	"函",
    	"亦",
    	"抽",
    	"篇",
    	"陣",
    	"陰",
    	"丁",
    	"尺",
    	"追",
    	"堆",
    	"雄",
    	"迎",
    	"泛",
    	"爸",
    	"樓",
    	"避",
    	"謀",
    	"噸",
    	"野",
    	"豬",
    	"旗",
    	"累",
    	"偏",
    	"典",
    	"館",
    	"索",
    	"秦",
    	"脂",
    	"潮",
    	"爺",
    	"豆",
    	"忽",
    	"托",
    	"驚",
    	"塑",
    	"遺",
    	"愈",
    	"朱",
    	"替",
    	"纖",
    	"粗",
    	"傾",
    	"尚",
    	"痛",
    	"楚",
    	"謝",
    	"奮",
    	"購",
    	"磨",
    	"君",
    	"池",
    	"旁",
    	"碎",
    	"骨",
    	"監",
    	"捕",
    	"弟",
    	"暴",
    	"割",
    	"貫",
    	"殊",
    	"釋",
    	"詞",
    	"亡",
    	"壁",
    	"頓",
    	"寶",
    	"午",
    	"塵",
    	"聞",
    	"揭",
    	"炮",
    	"殘",
    	"冬",
    	"橋",
    	"婦",
    	"警",
    	"綜",
    	"招",
    	"吳",
    	"付",
    	"浮",
    	"遭",
    	"徐",
    	"您",
    	"搖",
    	"谷",
    	"贊",
    	"箱",
    	"隔",
    	"訂",
    	"男",
    	"吹",
    	"園",
    	"紛",
    	"唐",
    	"敗",
    	"宋",
    	"玻",
    	"巨",
    	"耕",
    	"坦",
    	"榮",
    	"閉",
    	"灣",
    	"鍵",
    	"凡",
    	"駐",
    	"鍋",
    	"救",
    	"恩",
    	"剝",
    	"凝",
    	"鹼",
    	"齒",
    	"截",
    	"煉",
    	"麻",
    	"紡",
    	"禁",
    	"廢",
    	"盛",
    	"版",
    	"緩",
    	"淨",
    	"睛",
    	"昌",
    	"婚",
    	"涉",
    	"筒",
    	"嘴",
    	"插",
    	"岸",
    	"朗",
    	"莊",
    	"街",
    	"藏",
    	"姑",
    	"貿",
    	"腐",
    	"奴",
    	"啦",
    	"慣",
    	"乘",
    	"夥",
    	"恢",
    	"勻",
    	"紗",
    	"扎",
    	"辯",
    	"耳",
    	"彪",
    	"臣",
    	"億",
    	"璃",
    	"抵",
    	"脈",
    	"秀",
    	"薩",
    	"俄",
    	"網",
    	"舞",
    	"店",
    	"噴",
    	"縱",
    	"寸",
    	"汗",
    	"掛",
    	"洪",
    	"賀",
    	"閃",
    	"柬",
    	"爆",
    	"烯",
    	"津",
    	"稻",
    	"牆",
    	"軟",
    	"勇",
    	"像",
    	"滾",
    	"厘",
    	"蒙",
    	"芳",
    	"肯",
    	"坡",
    	"柱",
    	"盪",
    	"腿",
    	"儀",
    	"旅",
    	"尾",
    	"軋",
    	"冰",
    	"貢",
    	"登",
    	"黎",
    	"削",
    	"鑽",
    	"勒",
    	"逃",
    	"障",
    	"氨",
    	"郭",
    	"峰",
    	"幣",
    	"港",
    	"伏",
    	"軌",
    	"畝",
    	"畢",
    	"擦",
    	"莫",
    	"刺",
    	"浪",
    	"秘",
    	"援",
    	"株",
    	"健",
    	"售",
    	"股",
    	"島",
    	"甘",
    	"泡",
    	"睡",
    	"童",
    	"鑄",
    	"湯",
    	"閥",
    	"休",
    	"匯",
    	"舍",
    	"牧",
    	"繞",
    	"炸",
    	"哲",
    	"磷",
    	"績",
    	"朋",
    	"淡",
    	"尖",
    	"啟",
    	"陷",
    	"柴",
    	"呈",
    	"徒",
    	"顏",
    	"淚",
    	"稍",
    	"忘",
    	"泵",
    	"藍",
    	"拖",
    	"洞",
    	"授",
    	"鏡",
    	"辛",
    	"壯",
    	"鋒",
    	"貧",
    	"虛",
    	"彎",
    	"摩",
    	"泰",
    	"幼",
    	"廷",
    	"尊",
    	"窗",
    	"綱",
    	"弄",
    	"隸",
    	"疑",
    	"氏",
    	"宮",
    	"姐",
    	"震",
    	"瑞",
    	"怪",
    	"尤",
    	"琴",
    	"循",
    	"描",
    	"膜",
    	"違",
    	"夾",
    	"腰",
    	"緣",
    	"珠",
    	"窮",
    	"森",
    	"枝",
    	"竹",
    	"溝",
    	"催",
    	"繩",
    	"憶",
    	"邦",
    	"剩",
    	"幸",
    	"漿",
    	"欄",
    	"擁",
    	"牙",
    	"貯",
    	"禮",
    	"濾",
    	"鈉",
    	"紋",
    	"罷",
    	"拍",
    	"咱",
    	"喊",
    	"袖",
    	"埃",
    	"勤",
    	"罰",
    	"焦",
    	"潛",
    	"伍",
    	"墨",
    	"欲",
    	"縫",
    	"姓",
    	"刊",
    	"飽",
    	"仿",
    	"獎",
    	"鋁",
    	"鬼",
    	"麗",
    	"跨",
    	"默",
    	"挖",
    	"鏈",
    	"掃",
    	"喝",
    	"袋",
    	"炭",
    	"污",
    	"幕",
    	"諸",
    	"弧",
    	"勵",
    	"梅",
    	"奶",
    	"潔",
    	"災",
    	"舟",
    	"鑑",
    	"苯",
    	"訟",
    	"抱",
    	"毀",
    	"懂",
    	"寒",
    	"智",
    	"埔",
    	"寄",
    	"屆",
    	"躍",
    	"渡",
    	"挑",
    	"丹",
    	"艱",
    	"貝",
    	"碰",
    	"拔",
    	"爹",
    	"戴",
    	"碼",
    	"夢",
    	"芽",
    	"熔",
    	"赤",
    	"漁",
    	"哭",
    	"敬",
    	"顆",
    	"奔",
    	"鉛",
    	"仲",
    	"虎",
    	"稀",
    	"妹",
    	"乏",
    	"珍",
    	"申",
    	"桌",
    	"遵",
    	"允",
    	"隆",
    	"螺",
    	"倉",
    	"魏",
    	"銳",
    	"曉",
    	"氮",
    	"兼",
    	"隱",
    	"礙",
    	"赫",
    	"撥",
    	"忠",
    	"肅",
    	"缸",
    	"牽",
    	"搶",
    	"博",
    	"巧",
    	"殼",
    	"兄",
    	"杜",
    	"訊",
    	"誠",
    	"碧",
    	"祥",
    	"柯",
    	"頁",
    	"巡",
    	"矩",
    	"悲",
    	"灌",
    	"齡",
    	"倫",
    	"票",
    	"尋",
    	"桂",
    	"鋪",
    	"聖",
    	"恐",
    	"恰",
    	"鄭",
    	"趣",
    	"抬",
    	"荒",
    	"騰",
    	"貼",
    	"柔",
    	"滴",
    	"猛",
    	"闊",
    	"輛",
    	"妻",
    	"填",
    	"撤",
    	"儲",
    	"簽",
    	"鬧",
    	"擾",
    	"紫",
    	"砂",
    	"遞",
    	"戲",
    	"吊",
    	"陶",
    	"伐",
    	"餵",
    	"療",
    	"瓶",
    	"婆",
    	"撫",
    	"臂",
    	"摸",
    	"忍",
    	"蝦",
    	"蠟",
    	"鄰",
    	"胸",
    	"鞏",
    	"擠",
    	"偶",
    	"棄",
    	"槽",
    	"勁",
    	"乳",
    	"鄧",
    	"吉",
    	"仁",
    	"爛",
    	"磚",
    	"租",
    	"烏",
    	"艦",
    	"伴",
    	"瓜",
    	"淺",
    	"丙",
    	"暫",
    	"燥",
    	"橡",
    	"柳",
    	"迷",
    	"暖",
    	"牌",
    	"秧",
    	"膽",
    	"詳",
    	"簧",
    	"踏",
    	"瓷",
    	"譜",
    	"呆",
    	"賓",
    	"糊",
    	"洛",
    	"輝",
    	"憤",
    	"競",
    	"隙",
    	"怒",
    	"粘",
    	"乃",
    	"緒",
    	"肩",
    	"籍",
    	"敏",
    	"塗",
    	"熙",
    	"皆",
    	"偵",
    	"懸",
    	"掘",
    	"享",
    	"糾",
    	"醒",
    	"狂",
    	"鎖",
    	"淀",
    	"恨",
    	"牲",
    	"霸",
    	"爬",
    	"賞",
    	"逆",
    	"玩",
    	"陵",
    	"祝",
    	"秒",
    	"浙",
    	"貌",
    	"役",
    	"彼",
    	"悉",
    	"鴨",
    	"趨",
    	"鳳",
    	"晨",
    	"畜",
    	"輩",
    	"秩",
    	"卵",
    	"署",
    	"梯",
    	"炎",
    	"灘",
    	"棋",
    	"驅",
    	"篩",
    	"峽",
    	"冒",
    	"啥",
    	"壽",
    	"譯",
    	"浸",
    	"泉",
    	"帽",
    	"遲",
    	"矽",
    	"疆",
    	"貸",
    	"漏",
    	"稿",
    	"冠",
    	"嫩",
    	"脅",
    	"芯",
    	"牢",
    	"叛",
    	"蝕",
    	"奧",
    	"鳴",
    	"嶺",
    	"羊",
    	"憑",
    	"串",
    	"塘",
    	"繪",
    	"酵",
    	"融",
    	"盆",
    	"錫",
    	"廟",
    	"籌",
    	"凍",
    	"輔",
    	"攝",
    	"襲",
    	"筋",
    	"拒",
    	"僚",
    	"旱",
    	"鉀",
    	"鳥",
    	"漆",
    	"沈",
    	"眉",
    	"疏",
    	"添",
    	"棒",
    	"穗",
    	"硝",
    	"韓",
    	"逼",
    	"扭",
    	"僑",
    	"涼",
    	"挺",
    	"碗",
    	"栽",
    	"炒",
    	"杯",
    	"患",
    	"餾",
    	"勸",
    	"豪",
    	"遼",
    	"勃",
    	"鴻",
    	"旦",
    	"吏",
    	"拜",
    	"狗",
    	"埋",
    	"輥",
    	"掩",
    	"飲",
    	"搬",
    	"罵",
    	"辭",
    	"勾",
    	"扣",
    	"估",
    	"蔣",
    	"絨",
    	"霧",
    	"丈",
    	"朵",
    	"姆",
    	"擬",
    	"宇",
    	"輯",
    	"陝",
    	"雕",
    	"償",
    	"蓄",
    	"崇",
    	"剪",
    	"倡",
    	"廳",
    	"咬",
    	"駛",
    	"薯",
    	"刷",
    	"斥",
    	"番",
    	"賦",
    	"奉",
    	"佛",
    	"澆",
    	"漫",
    	"曼",
    	"扇",
    	"鈣",
    	"桃",
    	"扶",
    	"仔",
    	"返",
    	"俗",
    	"虧",
    	"腔",
    	"鞋",
    	"棱",
    	"覆",
    	"框",
    	"悄",
    	"叔",
    	"撞",
    	"騙",
    	"勘",
    	"旺",
    	"沸",
    	"孤",
    	"吐",
    	"孟",
    	"渠",
    	"屈",
    	"疾",
    	"妙",
    	"惜",
    	"仰",
    	"狠",
    	"脹",
    	"諧",
    	"拋",
    	"黴",
    	"桑",
    	"崗",
    	"嘛",
    	"衰",
    	"盜",
    	"滲",
    	"臟",
    	"賴",
    	"湧",
    	"甜",
    	"曹",
    	"閱",
    	"肌",
    	"哩",
    	"厲",
    	"烴",
    	"緯",
    	"毅",
    	"昨",
    	"偽",
    	"症",
    	"煮",
    	"嘆",
    	"釘",
    	"搭",
    	"莖",
    	"籠",
    	"酷",
    	"偷",
    	"弓",
    	"錐",
    	"恆",
    	"傑",
    	"坑",
    	"鼻",
    	"翼",
    	"綸",
    	"敘",
    	"獄",
    	"逮",
    	"罐",
    	"絡",
    	"棚",
    	"抑",
    	"膨",
    	"蔬",
    	"寺",
    	"驟",
    	"穆",
    	"冶",
    	"枯",
    	"冊",
    	"屍",
    	"凸",
    	"紳",
    	"坯",
    	"犧",
    	"焰",
    	"轟",
    	"欣",
    	"晉",
    	"瘦",
    	"禦",
    	"錠",
    	"錦",
    	"喪",
    	"旬",
    	"鍛",
    	"壟",
    	"搜",
    	"撲",
    	"邀",
    	"亭",
    	"酯",
    	"邁",
    	"舒",
    	"脆",
    	"酶",
    	"閒",
    	"憂",
    	"酚",
    	"頑",
    	"羽",
    	"漲",
    	"卸",
    	"仗",
    	"陪",
    	"闢",
    	"懲",
    	"杭",
    	"姚",
    	"肚",
    	"捉",
    	"飄",
    	"漂",
    	"昆",
    	"欺",
    	"吾",
    	"郎",
    	"烷",
    	"汁",
    	"呵",
    	"飾",
    	"蕭",
    	"雅",
    	"郵",
    	"遷",
    	"燕",
    	"撒",
    	"姻",
    	"赴",
    	"宴",
    	"煩",
    	"債",
    	"帳",
    	"斑",
    	"鈴",
    	"旨",
    	"醇",
    	"董",
    	"餅",
    	"雛",
    	"姿",
    	"拌",
    	"傅",
    	"腹",
    	"妥",
    	"揉",
    	"賢",
    	"拆",
    	"歪",
    	"葡",
    	"胺",
    	"丟",
    	"浩",
    	"徽",
    	"昂",
    	"墊",
    	"擋",
    	"覽",
    	"貪",
    	"慰",
    	"繳",
    	"汪",
    	"慌",
    	"馮",
    	"諾",
    	"姜",
    	"誼",
    	"兇",
    	"劣",
    	"誣",
    	"耀",
    	"昏",
    	"躺",
    	"盈",
    	"騎",
    	"喬",
    	"溪",
    	"叢",
    	"盧",
    	"抹",
    	"悶",
    	"諮",
    	"刮",
    	"駕",
    	"纜",
    	"悟",
    	"摘",
    	"鉺",
    	"擲",
    	"頗",
    	"幻",
    	"柄",
    	"惠",
    	"慘",
    	"佳",
    	"仇",
    	"臘",
    	"窩",
    	"滌",
    	"劍",
    	"瞧",
    	"堡",
    	"潑",
    	"蔥",
    	"罩",
    	"霍",
    	"撈",
    	"胎",
    	"蒼",
    	"濱",
    	"倆",
    	"捅",
    	"湘",
    	"砍",
    	"霞",
    	"邵",
    	"萄",
    	"瘋",
    	"淮",
    	"遂",
    	"熊",
    	"糞",
    	"烘",
    	"宿",
    	"檔",
    	"戈",
    	"駁",
    	"嫂",
    	"裕",
    	"徙",
    	"箭",
    	"捐",
    	"腸",
    	"撐",
    	"曬",
    	"辨",
    	"殿",
    	"蓮",
    	"攤",
    	"攪",
    	"醬",
    	"屏",
    	"疫",
    	"哀",
    	"蔡",
    	"堵",
    	"沫",
    	"皺",
    	"暢",
    	"疊",
    	"閣",
    	"萊",
    	"敲",
    	"轄",
    	"鉤",
    	"痕",
    	"壩",
    	"巷",
    	"餓",
    	"禍",
    	"丘",
    	"玄",
    	"溜",
    	"曰",
    	"邏",
    	"彭",
    	"嘗",
    	"卿",
    	"妨",
    	"艇",
    	"吞",
    	"韋",
    	"怨",
    	"矮",
    	"歇"
    ];

    var require$$3 = [
    	"가격",
    	"가끔",
    	"가난",
    	"가능",
    	"가득",
    	"가르침",
    	"가뭄",
    	"가방",
    	"가상",
    	"가슴",
    	"가운데",
    	"가을",
    	"가이드",
    	"가입",
    	"가장",
    	"가정",
    	"가족",
    	"가죽",
    	"각오",
    	"각자",
    	"간격",
    	"간부",
    	"간섭",
    	"간장",
    	"간접",
    	"간판",
    	"갈등",
    	"갈비",
    	"갈색",
    	"갈증",
    	"감각",
    	"감기",
    	"감소",
    	"감수성",
    	"감자",
    	"감정",
    	"갑자기",
    	"강남",
    	"강당",
    	"강도",
    	"강력히",
    	"강변",
    	"강북",
    	"강사",
    	"강수량",
    	"강아지",
    	"강원도",
    	"강의",
    	"강제",
    	"강조",
    	"같이",
    	"개구리",
    	"개나리",
    	"개방",
    	"개별",
    	"개선",
    	"개성",
    	"개인",
    	"객관적",
    	"거실",
    	"거액",
    	"거울",
    	"거짓",
    	"거품",
    	"걱정",
    	"건강",
    	"건물",
    	"건설",
    	"건조",
    	"건축",
    	"걸음",
    	"검사",
    	"검토",
    	"게시판",
    	"게임",
    	"겨울",
    	"견해",
    	"결과",
    	"결국",
    	"결론",
    	"결석",
    	"결승",
    	"결심",
    	"결정",
    	"결혼",
    	"경계",
    	"경고",
    	"경기",
    	"경력",
    	"경복궁",
    	"경비",
    	"경상도",
    	"경영",
    	"경우",
    	"경쟁",
    	"경제",
    	"경주",
    	"경찰",
    	"경치",
    	"경향",
    	"경험",
    	"계곡",
    	"계단",
    	"계란",
    	"계산",
    	"계속",
    	"계약",
    	"계절",
    	"계층",
    	"계획",
    	"고객",
    	"고구려",
    	"고궁",
    	"고급",
    	"고등학생",
    	"고무신",
    	"고민",
    	"고양이",
    	"고장",
    	"고전",
    	"고집",
    	"고춧가루",
    	"고통",
    	"고향",
    	"곡식",
    	"골목",
    	"골짜기",
    	"골프",
    	"공간",
    	"공개",
    	"공격",
    	"공군",
    	"공급",
    	"공기",
    	"공동",
    	"공무원",
    	"공부",
    	"공사",
    	"공식",
    	"공업",
    	"공연",
    	"공원",
    	"공장",
    	"공짜",
    	"공책",
    	"공통",
    	"공포",
    	"공항",
    	"공휴일",
    	"과목",
    	"과일",
    	"과장",
    	"과정",
    	"과학",
    	"관객",
    	"관계",
    	"관광",
    	"관념",
    	"관람",
    	"관련",
    	"관리",
    	"관습",
    	"관심",
    	"관점",
    	"관찰",
    	"광경",
    	"광고",
    	"광장",
    	"광주",
    	"괴로움",
    	"굉장히",
    	"교과서",
    	"교문",
    	"교복",
    	"교실",
    	"교양",
    	"교육",
    	"교장",
    	"교직",
    	"교통",
    	"교환",
    	"교훈",
    	"구경",
    	"구름",
    	"구멍",
    	"구별",
    	"구분",
    	"구석",
    	"구성",
    	"구속",
    	"구역",
    	"구입",
    	"구청",
    	"구체적",
    	"국가",
    	"국기",
    	"국내",
    	"국립",
    	"국물",
    	"국민",
    	"국수",
    	"국어",
    	"국왕",
    	"국적",
    	"국제",
    	"국회",
    	"군대",
    	"군사",
    	"군인",
    	"궁극적",
    	"권리",
    	"권위",
    	"권투",
    	"귀국",
    	"귀신",
    	"규정",
    	"규칙",
    	"균형",
    	"그날",
    	"그냥",
    	"그늘",
    	"그러나",
    	"그룹",
    	"그릇",
    	"그림",
    	"그제서야",
    	"그토록",
    	"극복",
    	"극히",
    	"근거",
    	"근교",
    	"근래",
    	"근로",
    	"근무",
    	"근본",
    	"근원",
    	"근육",
    	"근처",
    	"글씨",
    	"글자",
    	"금강산",
    	"금고",
    	"금년",
    	"금메달",
    	"금액",
    	"금연",
    	"금요일",
    	"금지",
    	"긍정적",
    	"기간",
    	"기관",
    	"기념",
    	"기능",
    	"기독교",
    	"기둥",
    	"기록",
    	"기름",
    	"기법",
    	"기본",
    	"기분",
    	"기쁨",
    	"기숙사",
    	"기술",
    	"기억",
    	"기업",
    	"기온",
    	"기운",
    	"기원",
    	"기적",
    	"기준",
    	"기침",
    	"기혼",
    	"기획",
    	"긴급",
    	"긴장",
    	"길이",
    	"김밥",
    	"김치",
    	"김포공항",
    	"깍두기",
    	"깜빡",
    	"깨달음",
    	"깨소금",
    	"껍질",
    	"꼭대기",
    	"꽃잎",
    	"나들이",
    	"나란히",
    	"나머지",
    	"나물",
    	"나침반",
    	"나흘",
    	"낙엽",
    	"난방",
    	"날개",
    	"날씨",
    	"날짜",
    	"남녀",
    	"남대문",
    	"남매",
    	"남산",
    	"남자",
    	"남편",
    	"남학생",
    	"낭비",
    	"낱말",
    	"내년",
    	"내용",
    	"내일",
    	"냄비",
    	"냄새",
    	"냇물",
    	"냉동",
    	"냉면",
    	"냉방",
    	"냉장고",
    	"넥타이",
    	"넷째",
    	"노동",
    	"노란색",
    	"노력",
    	"노인",
    	"녹음",
    	"녹차",
    	"녹화",
    	"논리",
    	"논문",
    	"논쟁",
    	"놀이",
    	"농구",
    	"농담",
    	"농민",
    	"농부",
    	"농업",
    	"농장",
    	"농촌",
    	"높이",
    	"눈동자",
    	"눈물",
    	"눈썹",
    	"뉴욕",
    	"느낌",
    	"늑대",
    	"능동적",
    	"능력",
    	"다방",
    	"다양성",
    	"다음",
    	"다이어트",
    	"다행",
    	"단계",
    	"단골",
    	"단독",
    	"단맛",
    	"단순",
    	"단어",
    	"단위",
    	"단점",
    	"단체",
    	"단추",
    	"단편",
    	"단풍",
    	"달걀",
    	"달러",
    	"달력",
    	"달리",
    	"닭고기",
    	"담당",
    	"담배",
    	"담요",
    	"담임",
    	"답변",
    	"답장",
    	"당근",
    	"당분간",
    	"당연히",
    	"당장",
    	"대규모",
    	"대낮",
    	"대단히",
    	"대답",
    	"대도시",
    	"대략",
    	"대량",
    	"대륙",
    	"대문",
    	"대부분",
    	"대신",
    	"대응",
    	"대장",
    	"대전",
    	"대접",
    	"대중",
    	"대책",
    	"대출",
    	"대충",
    	"대통령",
    	"대학",
    	"대한민국",
    	"대합실",
    	"대형",
    	"덩어리",
    	"데이트",
    	"도대체",
    	"도덕",
    	"도둑",
    	"도망",
    	"도서관",
    	"도심",
    	"도움",
    	"도입",
    	"도자기",
    	"도저히",
    	"도전",
    	"도중",
    	"도착",
    	"독감",
    	"독립",
    	"독서",
    	"독일",
    	"독창적",
    	"동화책",
    	"뒷모습",
    	"뒷산",
    	"딸아이",
    	"마누라",
    	"마늘",
    	"마당",
    	"마라톤",
    	"마련",
    	"마무리",
    	"마사지",
    	"마약",
    	"마요네즈",
    	"마을",
    	"마음",
    	"마이크",
    	"마중",
    	"마지막",
    	"마찬가지",
    	"마찰",
    	"마흔",
    	"막걸리",
    	"막내",
    	"막상",
    	"만남",
    	"만두",
    	"만세",
    	"만약",
    	"만일",
    	"만점",
    	"만족",
    	"만화",
    	"많이",
    	"말기",
    	"말씀",
    	"말투",
    	"맘대로",
    	"망원경",
    	"매년",
    	"매달",
    	"매력",
    	"매번",
    	"매스컴",
    	"매일",
    	"매장",
    	"맥주",
    	"먹이",
    	"먼저",
    	"먼지",
    	"멀리",
    	"메일",
    	"며느리",
    	"며칠",
    	"면담",
    	"멸치",
    	"명단",
    	"명령",
    	"명예",
    	"명의",
    	"명절",
    	"명칭",
    	"명함",
    	"모금",
    	"모니터",
    	"모델",
    	"모든",
    	"모범",
    	"모습",
    	"모양",
    	"모임",
    	"모조리",
    	"모집",
    	"모퉁이",
    	"목걸이",
    	"목록",
    	"목사",
    	"목소리",
    	"목숨",
    	"목적",
    	"목표",
    	"몰래",
    	"몸매",
    	"몸무게",
    	"몸살",
    	"몸속",
    	"몸짓",
    	"몸통",
    	"몹시",
    	"무관심",
    	"무궁화",
    	"무더위",
    	"무덤",
    	"무릎",
    	"무슨",
    	"무엇",
    	"무역",
    	"무용",
    	"무조건",
    	"무지개",
    	"무척",
    	"문구",
    	"문득",
    	"문법",
    	"문서",
    	"문제",
    	"문학",
    	"문화",
    	"물가",
    	"물건",
    	"물결",
    	"물고기",
    	"물론",
    	"물리학",
    	"물음",
    	"물질",
    	"물체",
    	"미국",
    	"미디어",
    	"미사일",
    	"미술",
    	"미역",
    	"미용실",
    	"미움",
    	"미인",
    	"미팅",
    	"미혼",
    	"민간",
    	"민족",
    	"민주",
    	"믿음",
    	"밀가루",
    	"밀리미터",
    	"밑바닥",
    	"바가지",
    	"바구니",
    	"바나나",
    	"바늘",
    	"바닥",
    	"바닷가",
    	"바람",
    	"바이러스",
    	"바탕",
    	"박물관",
    	"박사",
    	"박수",
    	"반대",
    	"반드시",
    	"반말",
    	"반발",
    	"반성",
    	"반응",
    	"반장",
    	"반죽",
    	"반지",
    	"반찬",
    	"받침",
    	"발가락",
    	"발걸음",
    	"발견",
    	"발달",
    	"발레",
    	"발목",
    	"발바닥",
    	"발생",
    	"발음",
    	"발자국",
    	"발전",
    	"발톱",
    	"발표",
    	"밤하늘",
    	"밥그릇",
    	"밥맛",
    	"밥상",
    	"밥솥",
    	"방금",
    	"방면",
    	"방문",
    	"방바닥",
    	"방법",
    	"방송",
    	"방식",
    	"방안",
    	"방울",
    	"방지",
    	"방학",
    	"방해",
    	"방향",
    	"배경",
    	"배꼽",
    	"배달",
    	"배드민턴",
    	"백두산",
    	"백색",
    	"백성",
    	"백인",
    	"백제",
    	"백화점",
    	"버릇",
    	"버섯",
    	"버튼",
    	"번개",
    	"번역",
    	"번지",
    	"번호",
    	"벌금",
    	"벌레",
    	"벌써",
    	"범위",
    	"범인",
    	"범죄",
    	"법률",
    	"법원",
    	"법적",
    	"법칙",
    	"베이징",
    	"벨트",
    	"변경",
    	"변동",
    	"변명",
    	"변신",
    	"변호사",
    	"변화",
    	"별도",
    	"별명",
    	"별일",
    	"병실",
    	"병아리",
    	"병원",
    	"보관",
    	"보너스",
    	"보라색",
    	"보람",
    	"보름",
    	"보상",
    	"보안",
    	"보자기",
    	"보장",
    	"보전",
    	"보존",
    	"보통",
    	"보편적",
    	"보험",
    	"복도",
    	"복사",
    	"복숭아",
    	"복습",
    	"볶음",
    	"본격적",
    	"본래",
    	"본부",
    	"본사",
    	"본성",
    	"본인",
    	"본질",
    	"볼펜",
    	"봉사",
    	"봉지",
    	"봉투",
    	"부근",
    	"부끄러움",
    	"부담",
    	"부동산",
    	"부문",
    	"부분",
    	"부산",
    	"부상",
    	"부엌",
    	"부인",
    	"부작용",
    	"부장",
    	"부정",
    	"부족",
    	"부지런히",
    	"부친",
    	"부탁",
    	"부품",
    	"부회장",
    	"북부",
    	"북한",
    	"분노",
    	"분량",
    	"분리",
    	"분명",
    	"분석",
    	"분야",
    	"분위기",
    	"분필",
    	"분홍색",
    	"불고기",
    	"불과",
    	"불교",
    	"불꽃",
    	"불만",
    	"불법",
    	"불빛",
    	"불안",
    	"불이익",
    	"불행",
    	"브랜드",
    	"비극",
    	"비난",
    	"비닐",
    	"비둘기",
    	"비디오",
    	"비로소",
    	"비만",
    	"비명",
    	"비밀",
    	"비바람",
    	"비빔밥",
    	"비상",
    	"비용",
    	"비율",
    	"비중",
    	"비타민",
    	"비판",
    	"빌딩",
    	"빗물",
    	"빗방울",
    	"빗줄기",
    	"빛깔",
    	"빨간색",
    	"빨래",
    	"빨리",
    	"사건",
    	"사계절",
    	"사나이",
    	"사냥",
    	"사람",
    	"사랑",
    	"사립",
    	"사모님",
    	"사물",
    	"사방",
    	"사상",
    	"사생활",
    	"사설",
    	"사슴",
    	"사실",
    	"사업",
    	"사용",
    	"사월",
    	"사장",
    	"사전",
    	"사진",
    	"사촌",
    	"사춘기",
    	"사탕",
    	"사투리",
    	"사흘",
    	"산길",
    	"산부인과",
    	"산업",
    	"산책",
    	"살림",
    	"살인",
    	"살짝",
    	"삼계탕",
    	"삼국",
    	"삼십",
    	"삼월",
    	"삼촌",
    	"상관",
    	"상금",
    	"상대",
    	"상류",
    	"상반기",
    	"상상",
    	"상식",
    	"상업",
    	"상인",
    	"상자",
    	"상점",
    	"상처",
    	"상추",
    	"상태",
    	"상표",
    	"상품",
    	"상황",
    	"새벽",
    	"색깔",
    	"색연필",
    	"생각",
    	"생명",
    	"생물",
    	"생방송",
    	"생산",
    	"생선",
    	"생신",
    	"생일",
    	"생활",
    	"서랍",
    	"서른",
    	"서명",
    	"서민",
    	"서비스",
    	"서양",
    	"서울",
    	"서적",
    	"서점",
    	"서쪽",
    	"서클",
    	"석사",
    	"석유",
    	"선거",
    	"선물",
    	"선배",
    	"선생",
    	"선수",
    	"선원",
    	"선장",
    	"선전",
    	"선택",
    	"선풍기",
    	"설거지",
    	"설날",
    	"설렁탕",
    	"설명",
    	"설문",
    	"설사",
    	"설악산",
    	"설치",
    	"설탕",
    	"섭씨",
    	"성공",
    	"성당",
    	"성명",
    	"성별",
    	"성인",
    	"성장",
    	"성적",
    	"성질",
    	"성함",
    	"세금",
    	"세미나",
    	"세상",
    	"세월",
    	"세종대왕",
    	"세탁",
    	"센터",
    	"센티미터",
    	"셋째",
    	"소규모",
    	"소극적",
    	"소금",
    	"소나기",
    	"소년",
    	"소득",
    	"소망",
    	"소문",
    	"소설",
    	"소속",
    	"소아과",
    	"소용",
    	"소원",
    	"소음",
    	"소중히",
    	"소지품",
    	"소질",
    	"소풍",
    	"소형",
    	"속담",
    	"속도",
    	"속옷",
    	"손가락",
    	"손길",
    	"손녀",
    	"손님",
    	"손등",
    	"손목",
    	"손뼉",
    	"손실",
    	"손질",
    	"손톱",
    	"손해",
    	"솔직히",
    	"솜씨",
    	"송아지",
    	"송이",
    	"송편",
    	"쇠고기",
    	"쇼핑",
    	"수건",
    	"수년",
    	"수단",
    	"수돗물",
    	"수동적",
    	"수면",
    	"수명",
    	"수박",
    	"수상",
    	"수석",
    	"수술",
    	"수시로",
    	"수업",
    	"수염",
    	"수영",
    	"수입",
    	"수준",
    	"수집",
    	"수출",
    	"수컷",
    	"수필",
    	"수학",
    	"수험생",
    	"수화기",
    	"숙녀",
    	"숙소",
    	"숙제",
    	"순간",
    	"순서",
    	"순수",
    	"순식간",
    	"순위",
    	"숟가락",
    	"술병",
    	"술집",
    	"숫자",
    	"스님",
    	"스물",
    	"스스로",
    	"스승",
    	"스웨터",
    	"스위치",
    	"스케이트",
    	"스튜디오",
    	"스트레스",
    	"스포츠",
    	"슬쩍",
    	"슬픔",
    	"습관",
    	"습기",
    	"승객",
    	"승리",
    	"승부",
    	"승용차",
    	"승진",
    	"시각",
    	"시간",
    	"시골",
    	"시금치",
    	"시나리오",
    	"시댁",
    	"시리즈",
    	"시멘트",
    	"시민",
    	"시부모",
    	"시선",
    	"시설",
    	"시스템",
    	"시아버지",
    	"시어머니",
    	"시월",
    	"시인",
    	"시일",
    	"시작",
    	"시장",
    	"시절",
    	"시점",
    	"시중",
    	"시즌",
    	"시집",
    	"시청",
    	"시합",
    	"시험",
    	"식구",
    	"식기",
    	"식당",
    	"식량",
    	"식료품",
    	"식물",
    	"식빵",
    	"식사",
    	"식생활",
    	"식초",
    	"식탁",
    	"식품",
    	"신고",
    	"신규",
    	"신념",
    	"신문",
    	"신발",
    	"신비",
    	"신사",
    	"신세",
    	"신용",
    	"신제품",
    	"신청",
    	"신체",
    	"신화",
    	"실감",
    	"실내",
    	"실력",
    	"실례",
    	"실망",
    	"실수",
    	"실습",
    	"실시",
    	"실장",
    	"실정",
    	"실질적",
    	"실천",
    	"실체",
    	"실컷",
    	"실태",
    	"실패",
    	"실험",
    	"실현",
    	"심리",
    	"심부름",
    	"심사",
    	"심장",
    	"심정",
    	"심판",
    	"쌍둥이",
    	"씨름",
    	"씨앗",
    	"아가씨",
    	"아나운서",
    	"아드님",
    	"아들",
    	"아쉬움",
    	"아스팔트",
    	"아시아",
    	"아울러",
    	"아저씨",
    	"아줌마",
    	"아직",
    	"아침",
    	"아파트",
    	"아프리카",
    	"아픔",
    	"아홉",
    	"아흔",
    	"악기",
    	"악몽",
    	"악수",
    	"안개",
    	"안경",
    	"안과",
    	"안내",
    	"안녕",
    	"안동",
    	"안방",
    	"안부",
    	"안주",
    	"알루미늄",
    	"알코올",
    	"암시",
    	"암컷",
    	"압력",
    	"앞날",
    	"앞문",
    	"애인",
    	"애정",
    	"액수",
    	"앨범",
    	"야간",
    	"야단",
    	"야옹",
    	"약간",
    	"약국",
    	"약속",
    	"약수",
    	"약점",
    	"약품",
    	"약혼녀",
    	"양념",
    	"양력",
    	"양말",
    	"양배추",
    	"양주",
    	"양파",
    	"어둠",
    	"어려움",
    	"어른",
    	"어젯밤",
    	"어쨌든",
    	"어쩌다가",
    	"어쩐지",
    	"언니",
    	"언덕",
    	"언론",
    	"언어",
    	"얼굴",
    	"얼른",
    	"얼음",
    	"얼핏",
    	"엄마",
    	"업무",
    	"업종",
    	"업체",
    	"엉덩이",
    	"엉망",
    	"엉터리",
    	"엊그제",
    	"에너지",
    	"에어컨",
    	"엔진",
    	"여건",
    	"여고생",
    	"여관",
    	"여군",
    	"여권",
    	"여대생",
    	"여덟",
    	"여동생",
    	"여든",
    	"여론",
    	"여름",
    	"여섯",
    	"여성",
    	"여왕",
    	"여인",
    	"여전히",
    	"여직원",
    	"여학생",
    	"여행",
    	"역사",
    	"역시",
    	"역할",
    	"연결",
    	"연구",
    	"연극",
    	"연기",
    	"연락",
    	"연설",
    	"연세",
    	"연속",
    	"연습",
    	"연애",
    	"연예인",
    	"연인",
    	"연장",
    	"연주",
    	"연출",
    	"연필",
    	"연합",
    	"연휴",
    	"열기",
    	"열매",
    	"열쇠",
    	"열심히",
    	"열정",
    	"열차",
    	"열흘",
    	"염려",
    	"엽서",
    	"영국",
    	"영남",
    	"영상",
    	"영양",
    	"영역",
    	"영웅",
    	"영원히",
    	"영하",
    	"영향",
    	"영혼",
    	"영화",
    	"옆구리",
    	"옆방",
    	"옆집",
    	"예감",
    	"예금",
    	"예방",
    	"예산",
    	"예상",
    	"예선",
    	"예술",
    	"예습",
    	"예식장",
    	"예약",
    	"예전",
    	"예절",
    	"예정",
    	"예컨대",
    	"옛날",
    	"오늘",
    	"오락",
    	"오랫동안",
    	"오렌지",
    	"오로지",
    	"오른발",
    	"오븐",
    	"오십",
    	"오염",
    	"오월",
    	"오전",
    	"오직",
    	"오징어",
    	"오페라",
    	"오피스텔",
    	"오히려",
    	"옥상",
    	"옥수수",
    	"온갖",
    	"온라인",
    	"온몸",
    	"온종일",
    	"온통",
    	"올가을",
    	"올림픽",
    	"올해",
    	"옷차림",
    	"와이셔츠",
    	"와인",
    	"완성",
    	"완전",
    	"왕비",
    	"왕자",
    	"왜냐하면",
    	"왠지",
    	"외갓집",
    	"외국",
    	"외로움",
    	"외삼촌",
    	"외출",
    	"외침",
    	"외할머니",
    	"왼발",
    	"왼손",
    	"왼쪽",
    	"요금",
    	"요일",
    	"요즘",
    	"요청",
    	"용기",
    	"용서",
    	"용어",
    	"우산",
    	"우선",
    	"우승",
    	"우연히",
    	"우정",
    	"우체국",
    	"우편",
    	"운동",
    	"운명",
    	"운반",
    	"운전",
    	"운행",
    	"울산",
    	"울음",
    	"움직임",
    	"웃어른",
    	"웃음",
    	"워낙",
    	"원고",
    	"원래",
    	"원서",
    	"원숭이",
    	"원인",
    	"원장",
    	"원피스",
    	"월급",
    	"월드컵",
    	"월세",
    	"월요일",
    	"웨이터",
    	"위반",
    	"위법",
    	"위성",
    	"위원",
    	"위험",
    	"위협",
    	"윗사람",
    	"유난히",
    	"유럽",
    	"유명",
    	"유물",
    	"유산",
    	"유적",
    	"유치원",
    	"유학",
    	"유행",
    	"유형",
    	"육군",
    	"육상",
    	"육십",
    	"육체",
    	"은행",
    	"음력",
    	"음료",
    	"음반",
    	"음성",
    	"음식",
    	"음악",
    	"음주",
    	"의견",
    	"의논",
    	"의문",
    	"의복",
    	"의식",
    	"의심",
    	"의외로",
    	"의욕",
    	"의원",
    	"의학",
    	"이것",
    	"이곳",
    	"이념",
    	"이놈",
    	"이달",
    	"이대로",
    	"이동",
    	"이렇게",
    	"이력서",
    	"이론적",
    	"이름",
    	"이민",
    	"이발소",
    	"이별",
    	"이불",
    	"이빨",
    	"이상",
    	"이성",
    	"이슬",
    	"이야기",
    	"이용",
    	"이웃",
    	"이월",
    	"이윽고",
    	"이익",
    	"이전",
    	"이중",
    	"이튿날",
    	"이틀",
    	"이혼",
    	"인간",
    	"인격",
    	"인공",
    	"인구",
    	"인근",
    	"인기",
    	"인도",
    	"인류",
    	"인물",
    	"인생",
    	"인쇄",
    	"인연",
    	"인원",
    	"인재",
    	"인종",
    	"인천",
    	"인체",
    	"인터넷",
    	"인하",
    	"인형",
    	"일곱",
    	"일기",
    	"일단",
    	"일대",
    	"일등",
    	"일반",
    	"일본",
    	"일부",
    	"일상",
    	"일생",
    	"일손",
    	"일요일",
    	"일월",
    	"일정",
    	"일종",
    	"일주일",
    	"일찍",
    	"일체",
    	"일치",
    	"일행",
    	"일회용",
    	"임금",
    	"임무",
    	"입대",
    	"입력",
    	"입맛",
    	"입사",
    	"입술",
    	"입시",
    	"입원",
    	"입장",
    	"입학",
    	"자가용",
    	"자격",
    	"자극",
    	"자동",
    	"자랑",
    	"자부심",
    	"자식",
    	"자신",
    	"자연",
    	"자원",
    	"자율",
    	"자전거",
    	"자정",
    	"자존심",
    	"자판",
    	"작가",
    	"작년",
    	"작성",
    	"작업",
    	"작용",
    	"작은딸",
    	"작품",
    	"잔디",
    	"잔뜩",
    	"잔치",
    	"잘못",
    	"잠깐",
    	"잠수함",
    	"잠시",
    	"잠옷",
    	"잠자리",
    	"잡지",
    	"장관",
    	"장군",
    	"장기간",
    	"장래",
    	"장례",
    	"장르",
    	"장마",
    	"장면",
    	"장모",
    	"장미",
    	"장비",
    	"장사",
    	"장소",
    	"장식",
    	"장애인",
    	"장인",
    	"장점",
    	"장차",
    	"장학금",
    	"재능",
    	"재빨리",
    	"재산",
    	"재생",
    	"재작년",
    	"재정",
    	"재채기",
    	"재판",
    	"재학",
    	"재활용",
    	"저것",
    	"저고리",
    	"저곳",
    	"저녁",
    	"저런",
    	"저렇게",
    	"저번",
    	"저울",
    	"저절로",
    	"저축",
    	"적극",
    	"적당히",
    	"적성",
    	"적용",
    	"적응",
    	"전개",
    	"전공",
    	"전기",
    	"전달",
    	"전라도",
    	"전망",
    	"전문",
    	"전반",
    	"전부",
    	"전세",
    	"전시",
    	"전용",
    	"전자",
    	"전쟁",
    	"전주",
    	"전철",
    	"전체",
    	"전통",
    	"전혀",
    	"전후",
    	"절대",
    	"절망",
    	"절반",
    	"절약",
    	"절차",
    	"점검",
    	"점수",
    	"점심",
    	"점원",
    	"점점",
    	"점차",
    	"접근",
    	"접시",
    	"접촉",
    	"젓가락",
    	"정거장",
    	"정도",
    	"정류장",
    	"정리",
    	"정말",
    	"정면",
    	"정문",
    	"정반대",
    	"정보",
    	"정부",
    	"정비",
    	"정상",
    	"정성",
    	"정오",
    	"정원",
    	"정장",
    	"정지",
    	"정치",
    	"정확히",
    	"제공",
    	"제과점",
    	"제대로",
    	"제목",
    	"제발",
    	"제법",
    	"제삿날",
    	"제안",
    	"제일",
    	"제작",
    	"제주도",
    	"제출",
    	"제품",
    	"제한",
    	"조각",
    	"조건",
    	"조금",
    	"조깅",
    	"조명",
    	"조미료",
    	"조상",
    	"조선",
    	"조용히",
    	"조절",
    	"조정",
    	"조직",
    	"존댓말",
    	"존재",
    	"졸업",
    	"졸음",
    	"종교",
    	"종로",
    	"종류",
    	"종소리",
    	"종업원",
    	"종종",
    	"종합",
    	"좌석",
    	"죄인",
    	"주관적",
    	"주름",
    	"주말",
    	"주머니",
    	"주먹",
    	"주문",
    	"주민",
    	"주방",
    	"주변",
    	"주식",
    	"주인",
    	"주일",
    	"주장",
    	"주전자",
    	"주택",
    	"준비",
    	"줄거리",
    	"줄기",
    	"줄무늬",
    	"중간",
    	"중계방송",
    	"중국",
    	"중년",
    	"중단",
    	"중독",
    	"중반",
    	"중부",
    	"중세",
    	"중소기업",
    	"중순",
    	"중앙",
    	"중요",
    	"중학교",
    	"즉석",
    	"즉시",
    	"즐거움",
    	"증가",
    	"증거",
    	"증권",
    	"증상",
    	"증세",
    	"지각",
    	"지갑",
    	"지경",
    	"지극히",
    	"지금",
    	"지급",
    	"지능",
    	"지름길",
    	"지리산",
    	"지방",
    	"지붕",
    	"지식",
    	"지역",
    	"지우개",
    	"지원",
    	"지적",
    	"지점",
    	"지진",
    	"지출",
    	"직선",
    	"직업",
    	"직원",
    	"직장",
    	"진급",
    	"진동",
    	"진로",
    	"진료",
    	"진리",
    	"진짜",
    	"진찰",
    	"진출",
    	"진통",
    	"진행",
    	"질문",
    	"질병",
    	"질서",
    	"짐작",
    	"집단",
    	"집안",
    	"집중",
    	"짜증",
    	"찌꺼기",
    	"차남",
    	"차라리",
    	"차량",
    	"차림",
    	"차별",
    	"차선",
    	"차츰",
    	"착각",
    	"찬물",
    	"찬성",
    	"참가",
    	"참기름",
    	"참새",
    	"참석",
    	"참여",
    	"참외",
    	"참조",
    	"찻잔",
    	"창가",
    	"창고",
    	"창구",
    	"창문",
    	"창밖",
    	"창작",
    	"창조",
    	"채널",
    	"채점",
    	"책가방",
    	"책방",
    	"책상",
    	"책임",
    	"챔피언",
    	"처벌",
    	"처음",
    	"천국",
    	"천둥",
    	"천장",
    	"천재",
    	"천천히",
    	"철도",
    	"철저히",
    	"철학",
    	"첫날",
    	"첫째",
    	"청년",
    	"청바지",
    	"청소",
    	"청춘",
    	"체계",
    	"체력",
    	"체온",
    	"체육",
    	"체중",
    	"체험",
    	"초등학생",
    	"초반",
    	"초밥",
    	"초상화",
    	"초순",
    	"초여름",
    	"초원",
    	"초저녁",
    	"초점",
    	"초청",
    	"초콜릿",
    	"촛불",
    	"총각",
    	"총리",
    	"총장",
    	"촬영",
    	"최근",
    	"최상",
    	"최선",
    	"최신",
    	"최악",
    	"최종",
    	"추석",
    	"추억",
    	"추진",
    	"추천",
    	"추측",
    	"축구",
    	"축소",
    	"축제",
    	"축하",
    	"출근",
    	"출발",
    	"출산",
    	"출신",
    	"출연",
    	"출입",
    	"출장",
    	"출판",
    	"충격",
    	"충고",
    	"충돌",
    	"충분히",
    	"충청도",
    	"취업",
    	"취직",
    	"취향",
    	"치약",
    	"친구",
    	"친척",
    	"칠십",
    	"칠월",
    	"칠판",
    	"침대",
    	"침묵",
    	"침실",
    	"칫솔",
    	"칭찬",
    	"카메라",
    	"카운터",
    	"칼국수",
    	"캐릭터",
    	"캠퍼스",
    	"캠페인",
    	"커튼",
    	"컨디션",
    	"컬러",
    	"컴퓨터",
    	"코끼리",
    	"코미디",
    	"콘서트",
    	"콜라",
    	"콤플렉스",
    	"콩나물",
    	"쾌감",
    	"쿠데타",
    	"크림",
    	"큰길",
    	"큰딸",
    	"큰소리",
    	"큰아들",
    	"큰어머니",
    	"큰일",
    	"큰절",
    	"클래식",
    	"클럽",
    	"킬로",
    	"타입",
    	"타자기",
    	"탁구",
    	"탁자",
    	"탄생",
    	"태권도",
    	"태양",
    	"태풍",
    	"택시",
    	"탤런트",
    	"터널",
    	"터미널",
    	"테니스",
    	"테스트",
    	"테이블",
    	"텔레비전",
    	"토론",
    	"토마토",
    	"토요일",
    	"통계",
    	"통과",
    	"통로",
    	"통신",
    	"통역",
    	"통일",
    	"통장",
    	"통제",
    	"통증",
    	"통합",
    	"통화",
    	"퇴근",
    	"퇴원",
    	"퇴직금",
    	"튀김",
    	"트럭",
    	"특급",
    	"특별",
    	"특성",
    	"특수",
    	"특징",
    	"특히",
    	"튼튼히",
    	"티셔츠",
    	"파란색",
    	"파일",
    	"파출소",
    	"판결",
    	"판단",
    	"판매",
    	"판사",
    	"팔십",
    	"팔월",
    	"팝송",
    	"패션",
    	"팩스",
    	"팩시밀리",
    	"팬티",
    	"퍼센트",
    	"페인트",
    	"편견",
    	"편의",
    	"편지",
    	"편히",
    	"평가",
    	"평균",
    	"평생",
    	"평소",
    	"평양",
    	"평일",
    	"평화",
    	"포스터",
    	"포인트",
    	"포장",
    	"포함",
    	"표면",
    	"표정",
    	"표준",
    	"표현",
    	"품목",
    	"품질",
    	"풍경",
    	"풍속",
    	"풍습",
    	"프랑스",
    	"프린터",
    	"플라스틱",
    	"피곤",
    	"피망",
    	"피아노",
    	"필름",
    	"필수",
    	"필요",
    	"필자",
    	"필통",
    	"핑계",
    	"하느님",
    	"하늘",
    	"하드웨어",
    	"하룻밤",
    	"하반기",
    	"하숙집",
    	"하순",
    	"하여튼",
    	"하지만",
    	"하천",
    	"하품",
    	"하필",
    	"학과",
    	"학교",
    	"학급",
    	"학기",
    	"학년",
    	"학력",
    	"학번",
    	"학부모",
    	"학비",
    	"학생",
    	"학술",
    	"학습",
    	"학용품",
    	"학원",
    	"학위",
    	"학자",
    	"학점",
    	"한계",
    	"한글",
    	"한꺼번에",
    	"한낮",
    	"한눈",
    	"한동안",
    	"한때",
    	"한라산",
    	"한마디",
    	"한문",
    	"한번",
    	"한복",
    	"한식",
    	"한여름",
    	"한쪽",
    	"할머니",
    	"할아버지",
    	"할인",
    	"함께",
    	"함부로",
    	"합격",
    	"합리적",
    	"항공",
    	"항구",
    	"항상",
    	"항의",
    	"해결",
    	"해군",
    	"해답",
    	"해당",
    	"해물",
    	"해석",
    	"해설",
    	"해수욕장",
    	"해안",
    	"핵심",
    	"핸드백",
    	"햄버거",
    	"햇볕",
    	"햇살",
    	"행동",
    	"행복",
    	"행사",
    	"행운",
    	"행위",
    	"향기",
    	"향상",
    	"향수",
    	"허락",
    	"허용",
    	"헬기",
    	"현관",
    	"현금",
    	"현대",
    	"현상",
    	"현실",
    	"현장",
    	"현재",
    	"현지",
    	"혈액",
    	"협력",
    	"형부",
    	"형사",
    	"형수",
    	"형식",
    	"형제",
    	"형태",
    	"형편",
    	"혜택",
    	"호기심",
    	"호남",
    	"호랑이",
    	"호박",
    	"호텔",
    	"호흡",
    	"혹시",
    	"홀로",
    	"홈페이지",
    	"홍보",
    	"홍수",
    	"홍차",
    	"화면",
    	"화분",
    	"화살",
    	"화요일",
    	"화장",
    	"화학",
    	"확보",
    	"확인",
    	"확장",
    	"확정",
    	"환갑",
    	"환경",
    	"환영",
    	"환율",
    	"환자",
    	"활기",
    	"활동",
    	"활발히",
    	"활용",
    	"활짝",
    	"회견",
    	"회관",
    	"회복",
    	"회색",
    	"회원",
    	"회장",
    	"회전",
    	"횟수",
    	"횡단보도",
    	"효율적",
    	"후반",
    	"후춧가루",
    	"훈련",
    	"훨씬",
    	"휴식",
    	"휴일",
    	"흉내",
    	"흐름",
    	"흑백",
    	"흑인",
    	"흔적",
    	"흔히",
    	"흥미",
    	"흥분",
    	"희곡",
    	"희망",
    	"희생",
    	"흰색",
    	"힘껏"
    ];

    var require$$4 = [
    	"abaisser",
    	"abandon",
    	"abdiquer",
    	"abeille",
    	"abolir",
    	"aborder",
    	"aboutir",
    	"aboyer",
    	"abrasif",
    	"abreuver",
    	"abriter",
    	"abroger",
    	"abrupt",
    	"absence",
    	"absolu",
    	"absurde",
    	"abusif",
    	"abyssal",
    	"académie",
    	"acajou",
    	"acarien",
    	"accabler",
    	"accepter",
    	"acclamer",
    	"accolade",
    	"accroche",
    	"accuser",
    	"acerbe",
    	"achat",
    	"acheter",
    	"aciduler",
    	"acier",
    	"acompte",
    	"acquérir",
    	"acronyme",
    	"acteur",
    	"actif",
    	"actuel",
    	"adepte",
    	"adéquat",
    	"adhésif",
    	"adjectif",
    	"adjuger",
    	"admettre",
    	"admirer",
    	"adopter",
    	"adorer",
    	"adoucir",
    	"adresse",
    	"adroit",
    	"adulte",
    	"adverbe",
    	"aérer",
    	"aéronef",
    	"affaire",
    	"affecter",
    	"affiche",
    	"affreux",
    	"affubler",
    	"agacer",
    	"agencer",
    	"agile",
    	"agiter",
    	"agrafer",
    	"agréable",
    	"agrume",
    	"aider",
    	"aiguille",
    	"ailier",
    	"aimable",
    	"aisance",
    	"ajouter",
    	"ajuster",
    	"alarmer",
    	"alchimie",
    	"alerte",
    	"algèbre",
    	"algue",
    	"aliéner",
    	"aliment",
    	"alléger",
    	"alliage",
    	"allouer",
    	"allumer",
    	"alourdir",
    	"alpaga",
    	"altesse",
    	"alvéole",
    	"amateur",
    	"ambigu",
    	"ambre",
    	"aménager",
    	"amertume",
    	"amidon",
    	"amiral",
    	"amorcer",
    	"amour",
    	"amovible",
    	"amphibie",
    	"ampleur",
    	"amusant",
    	"analyse",
    	"anaphore",
    	"anarchie",
    	"anatomie",
    	"ancien",
    	"anéantir",
    	"angle",
    	"angoisse",
    	"anguleux",
    	"animal",
    	"annexer",
    	"annonce",
    	"annuel",
    	"anodin",
    	"anomalie",
    	"anonyme",
    	"anormal",
    	"antenne",
    	"antidote",
    	"anxieux",
    	"apaiser",
    	"apéritif",
    	"aplanir",
    	"apologie",
    	"appareil",
    	"appeler",
    	"apporter",
    	"appuyer",
    	"aquarium",
    	"aqueduc",
    	"arbitre",
    	"arbuste",
    	"ardeur",
    	"ardoise",
    	"argent",
    	"arlequin",
    	"armature",
    	"armement",
    	"armoire",
    	"armure",
    	"arpenter",
    	"arracher",
    	"arriver",
    	"arroser",
    	"arsenic",
    	"artériel",
    	"article",
    	"aspect",
    	"asphalte",
    	"aspirer",
    	"assaut",
    	"asservir",
    	"assiette",
    	"associer",
    	"assurer",
    	"asticot",
    	"astre",
    	"astuce",
    	"atelier",
    	"atome",
    	"atrium",
    	"atroce",
    	"attaque",
    	"attentif",
    	"attirer",
    	"attraper",
    	"aubaine",
    	"auberge",
    	"audace",
    	"audible",
    	"augurer",
    	"aurore",
    	"automne",
    	"autruche",
    	"avaler",
    	"avancer",
    	"avarice",
    	"avenir",
    	"averse",
    	"aveugle",
    	"aviateur",
    	"avide",
    	"avion",
    	"aviser",
    	"avoine",
    	"avouer",
    	"avril",
    	"axial",
    	"axiome",
    	"badge",
    	"bafouer",
    	"bagage",
    	"baguette",
    	"baignade",
    	"balancer",
    	"balcon",
    	"baleine",
    	"balisage",
    	"bambin",
    	"bancaire",
    	"bandage",
    	"banlieue",
    	"bannière",
    	"banquier",
    	"barbier",
    	"baril",
    	"baron",
    	"barque",
    	"barrage",
    	"bassin",
    	"bastion",
    	"bataille",
    	"bateau",
    	"batterie",
    	"baudrier",
    	"bavarder",
    	"belette",
    	"bélier",
    	"belote",
    	"bénéfice",
    	"berceau",
    	"berger",
    	"berline",
    	"bermuda",
    	"besace",
    	"besogne",
    	"bétail",
    	"beurre",
    	"biberon",
    	"bicycle",
    	"bidule",
    	"bijou",
    	"bilan",
    	"bilingue",
    	"billard",
    	"binaire",
    	"biologie",
    	"biopsie",
    	"biotype",
    	"biscuit",
    	"bison",
    	"bistouri",
    	"bitume",
    	"bizarre",
    	"blafard",
    	"blague",
    	"blanchir",
    	"blessant",
    	"blinder",
    	"blond",
    	"bloquer",
    	"blouson",
    	"bobard",
    	"bobine",
    	"boire",
    	"boiser",
    	"bolide",
    	"bonbon",
    	"bondir",
    	"bonheur",
    	"bonifier",
    	"bonus",
    	"bordure",
    	"borne",
    	"botte",
    	"boucle",
    	"boueux",
    	"bougie",
    	"boulon",
    	"bouquin",
    	"bourse",
    	"boussole",
    	"boutique",
    	"boxeur",
    	"branche",
    	"brasier",
    	"brave",
    	"brebis",
    	"brèche",
    	"breuvage",
    	"bricoler",
    	"brigade",
    	"brillant",
    	"brioche",
    	"brique",
    	"brochure",
    	"broder",
    	"bronzer",
    	"brousse",
    	"broyeur",
    	"brume",
    	"brusque",
    	"brutal",
    	"bruyant",
    	"buffle",
    	"buisson",
    	"bulletin",
    	"bureau",
    	"burin",
    	"bustier",
    	"butiner",
    	"butoir",
    	"buvable",
    	"buvette",
    	"cabanon",
    	"cabine",
    	"cachette",
    	"cadeau",
    	"cadre",
    	"caféine",
    	"caillou",
    	"caisson",
    	"calculer",
    	"calepin",
    	"calibre",
    	"calmer",
    	"calomnie",
    	"calvaire",
    	"camarade",
    	"caméra",
    	"camion",
    	"campagne",
    	"canal",
    	"caneton",
    	"canon",
    	"cantine",
    	"canular",
    	"capable",
    	"caporal",
    	"caprice",
    	"capsule",
    	"capter",
    	"capuche",
    	"carabine",
    	"carbone",
    	"caresser",
    	"caribou",
    	"carnage",
    	"carotte",
    	"carreau",
    	"carton",
    	"cascade",
    	"casier",
    	"casque",
    	"cassure",
    	"causer",
    	"caution",
    	"cavalier",
    	"caverne",
    	"caviar",
    	"cédille",
    	"ceinture",
    	"céleste",
    	"cellule",
    	"cendrier",
    	"censurer",
    	"central",
    	"cercle",
    	"cérébral",
    	"cerise",
    	"cerner",
    	"cerveau",
    	"cesser",
    	"chagrin",
    	"chaise",
    	"chaleur",
    	"chambre",
    	"chance",
    	"chapitre",
    	"charbon",
    	"chasseur",
    	"chaton",
    	"chausson",
    	"chavirer",
    	"chemise",
    	"chenille",
    	"chéquier",
    	"chercher",
    	"cheval",
    	"chien",
    	"chiffre",
    	"chignon",
    	"chimère",
    	"chiot",
    	"chlorure",
    	"chocolat",
    	"choisir",
    	"chose",
    	"chouette",
    	"chrome",
    	"chute",
    	"cigare",
    	"cigogne",
    	"cimenter",
    	"cinéma",
    	"cintrer",
    	"circuler",
    	"cirer",
    	"cirque",
    	"citerne",
    	"citoyen",
    	"citron",
    	"civil",
    	"clairon",
    	"clameur",
    	"claquer",
    	"classe",
    	"clavier",
    	"client",
    	"cligner",
    	"climat",
    	"clivage",
    	"cloche",
    	"clonage",
    	"cloporte",
    	"cobalt",
    	"cobra",
    	"cocasse",
    	"cocotier",
    	"coder",
    	"codifier",
    	"coffre",
    	"cogner",
    	"cohésion",
    	"coiffer",
    	"coincer",
    	"colère",
    	"colibri",
    	"colline",
    	"colmater",
    	"colonel",
    	"combat",
    	"comédie",
    	"commande",
    	"compact",
    	"concert",
    	"conduire",
    	"confier",
    	"congeler",
    	"connoter",
    	"consonne",
    	"contact",
    	"convexe",
    	"copain",
    	"copie",
    	"corail",
    	"corbeau",
    	"cordage",
    	"corniche",
    	"corpus",
    	"correct",
    	"cortège",
    	"cosmique",
    	"costume",
    	"coton",
    	"coude",
    	"coupure",
    	"courage",
    	"couteau",
    	"couvrir",
    	"coyote",
    	"crabe",
    	"crainte",
    	"cravate",
    	"crayon",
    	"créature",
    	"créditer",
    	"crémeux",
    	"creuser",
    	"crevette",
    	"cribler",
    	"crier",
    	"cristal",
    	"critère",
    	"croire",
    	"croquer",
    	"crotale",
    	"crucial",
    	"cruel",
    	"crypter",
    	"cubique",
    	"cueillir",
    	"cuillère",
    	"cuisine",
    	"cuivre",
    	"culminer",
    	"cultiver",
    	"cumuler",
    	"cupide",
    	"curatif",
    	"curseur",
    	"cyanure",
    	"cycle",
    	"cylindre",
    	"cynique",
    	"daigner",
    	"damier",
    	"danger",
    	"danseur",
    	"dauphin",
    	"débattre",
    	"débiter",
    	"déborder",
    	"débrider",
    	"débutant",
    	"décaler",
    	"décembre",
    	"déchirer",
    	"décider",
    	"déclarer",
    	"décorer",
    	"décrire",
    	"décupler",
    	"dédale",
    	"déductif",
    	"déesse",
    	"défensif",
    	"défiler",
    	"défrayer",
    	"dégager",
    	"dégivrer",
    	"déglutir",
    	"dégrafer",
    	"déjeuner",
    	"délice",
    	"déloger",
    	"demander",
    	"demeurer",
    	"démolir",
    	"dénicher",
    	"dénouer",
    	"dentelle",
    	"dénuder",
    	"départ",
    	"dépenser",
    	"déphaser",
    	"déplacer",
    	"déposer",
    	"déranger",
    	"dérober",
    	"désastre",
    	"descente",
    	"désert",
    	"désigner",
    	"désobéir",
    	"dessiner",
    	"destrier",
    	"détacher",
    	"détester",
    	"détourer",
    	"détresse",
    	"devancer",
    	"devenir",
    	"deviner",
    	"devoir",
    	"diable",
    	"dialogue",
    	"diamant",
    	"dicter",
    	"différer",
    	"digérer",
    	"digital",
    	"digne",
    	"diluer",
    	"dimanche",
    	"diminuer",
    	"dioxyde",
    	"directif",
    	"diriger",
    	"discuter",
    	"disposer",
    	"dissiper",
    	"distance",
    	"divertir",
    	"diviser",
    	"docile",
    	"docteur",
    	"dogme",
    	"doigt",
    	"domaine",
    	"domicile",
    	"dompter",
    	"donateur",
    	"donjon",
    	"donner",
    	"dopamine",
    	"dortoir",
    	"dorure",
    	"dosage",
    	"doseur",
    	"dossier",
    	"dotation",
    	"douanier",
    	"double",
    	"douceur",
    	"douter",
    	"doyen",
    	"dragon",
    	"draper",
    	"dresser",
    	"dribbler",
    	"droiture",
    	"duperie",
    	"duplexe",
    	"durable",
    	"durcir",
    	"dynastie",
    	"éblouir",
    	"écarter",
    	"écharpe",
    	"échelle",
    	"éclairer",
    	"éclipse",
    	"éclore",
    	"écluse",
    	"école",
    	"économie",
    	"écorce",
    	"écouter",
    	"écraser",
    	"écrémer",
    	"écrivain",
    	"écrou",
    	"écume",
    	"écureuil",
    	"édifier",
    	"éduquer",
    	"effacer",
    	"effectif",
    	"effigie",
    	"effort",
    	"effrayer",
    	"effusion",
    	"égaliser",
    	"égarer",
    	"éjecter",
    	"élaborer",
    	"élargir",
    	"électron",
    	"élégant",
    	"éléphant",
    	"élève",
    	"éligible",
    	"élitisme",
    	"éloge",
    	"élucider",
    	"éluder",
    	"emballer",
    	"embellir",
    	"embryon",
    	"émeraude",
    	"émission",
    	"emmener",
    	"émotion",
    	"émouvoir",
    	"empereur",
    	"employer",
    	"emporter",
    	"emprise",
    	"émulsion",
    	"encadrer",
    	"enchère",
    	"enclave",
    	"encoche",
    	"endiguer",
    	"endosser",
    	"endroit",
    	"enduire",
    	"énergie",
    	"enfance",
    	"enfermer",
    	"enfouir",
    	"engager",
    	"engin",
    	"englober",
    	"énigme",
    	"enjamber",
    	"enjeu",
    	"enlever",
    	"ennemi",
    	"ennuyeux",
    	"enrichir",
    	"enrobage",
    	"enseigne",
    	"entasser",
    	"entendre",
    	"entier",
    	"entourer",
    	"entraver",
    	"énumérer",
    	"envahir",
    	"enviable",
    	"envoyer",
    	"enzyme",
    	"éolien",
    	"épaissir",
    	"épargne",
    	"épatant",
    	"épaule",
    	"épicerie",
    	"épidémie",
    	"épier",
    	"épilogue",
    	"épine",
    	"épisode",
    	"épitaphe",
    	"époque",
    	"épreuve",
    	"éprouver",
    	"épuisant",
    	"équerre",
    	"équipe",
    	"ériger",
    	"érosion",
    	"erreur",
    	"éruption",
    	"escalier",
    	"espadon",
    	"espèce",
    	"espiègle",
    	"espoir",
    	"esprit",
    	"esquiver",
    	"essayer",
    	"essence",
    	"essieu",
    	"essorer",
    	"estime",
    	"estomac",
    	"estrade",
    	"étagère",
    	"étaler",
    	"étanche",
    	"étatique",
    	"éteindre",
    	"étendoir",
    	"éternel",
    	"éthanol",
    	"éthique",
    	"ethnie",
    	"étirer",
    	"étoffer",
    	"étoile",
    	"étonnant",
    	"étourdir",
    	"étrange",
    	"étroit",
    	"étude",
    	"euphorie",
    	"évaluer",
    	"évasion",
    	"éventail",
    	"évidence",
    	"éviter",
    	"évolutif",
    	"évoquer",
    	"exact",
    	"exagérer",
    	"exaucer",
    	"exceller",
    	"excitant",
    	"exclusif",
    	"excuse",
    	"exécuter",
    	"exemple",
    	"exercer",
    	"exhaler",
    	"exhorter",
    	"exigence",
    	"exiler",
    	"exister",
    	"exotique",
    	"expédier",
    	"explorer",
    	"exposer",
    	"exprimer",
    	"exquis",
    	"extensif",
    	"extraire",
    	"exulter",
    	"fable",
    	"fabuleux",
    	"facette",
    	"facile",
    	"facture",
    	"faiblir",
    	"falaise",
    	"fameux",
    	"famille",
    	"farceur",
    	"farfelu",
    	"farine",
    	"farouche",
    	"fasciner",
    	"fatal",
    	"fatigue",
    	"faucon",
    	"fautif",
    	"faveur",
    	"favori",
    	"fébrile",
    	"féconder",
    	"fédérer",
    	"félin",
    	"femme",
    	"fémur",
    	"fendoir",
    	"féodal",
    	"fermer",
    	"féroce",
    	"ferveur",
    	"festival",
    	"feuille",
    	"feutre",
    	"février",
    	"fiasco",
    	"ficeler",
    	"fictif",
    	"fidèle",
    	"figure",
    	"filature",
    	"filetage",
    	"filière",
    	"filleul",
    	"filmer",
    	"filou",
    	"filtrer",
    	"financer",
    	"finir",
    	"fiole",
    	"firme",
    	"fissure",
    	"fixer",
    	"flairer",
    	"flamme",
    	"flasque",
    	"flatteur",
    	"fléau",
    	"flèche",
    	"fleur",
    	"flexion",
    	"flocon",
    	"flore",
    	"fluctuer",
    	"fluide",
    	"fluvial",
    	"folie",
    	"fonderie",
    	"fongible",
    	"fontaine",
    	"forcer",
    	"forgeron",
    	"formuler",
    	"fortune",
    	"fossile",
    	"foudre",
    	"fougère",
    	"fouiller",
    	"foulure",
    	"fourmi",
    	"fragile",
    	"fraise",
    	"franchir",
    	"frapper",
    	"frayeur",
    	"frégate",
    	"freiner",
    	"frelon",
    	"frémir",
    	"frénésie",
    	"frère",
    	"friable",
    	"friction",
    	"frisson",
    	"frivole",
    	"froid",
    	"fromage",
    	"frontal",
    	"frotter",
    	"fruit",
    	"fugitif",
    	"fuite",
    	"fureur",
    	"furieux",
    	"furtif",
    	"fusion",
    	"futur",
    	"gagner",
    	"galaxie",
    	"galerie",
    	"gambader",
    	"garantir",
    	"gardien",
    	"garnir",
    	"garrigue",
    	"gazelle",
    	"gazon",
    	"géant",
    	"gélatine",
    	"gélule",
    	"gendarme",
    	"général",
    	"génie",
    	"genou",
    	"gentil",
    	"géologie",
    	"géomètre",
    	"géranium",
    	"germe",
    	"gestuel",
    	"geyser",
    	"gibier",
    	"gicler",
    	"girafe",
    	"givre",
    	"glace",
    	"glaive",
    	"glisser",
    	"globe",
    	"gloire",
    	"glorieux",
    	"golfeur",
    	"gomme",
    	"gonfler",
    	"gorge",
    	"gorille",
    	"goudron",
    	"gouffre",
    	"goulot",
    	"goupille",
    	"gourmand",
    	"goutte",
    	"graduel",
    	"graffiti",
    	"graine",
    	"grand",
    	"grappin",
    	"gratuit",
    	"gravir",
    	"grenat",
    	"griffure",
    	"griller",
    	"grimper",
    	"grogner",
    	"gronder",
    	"grotte",
    	"groupe",
    	"gruger",
    	"grutier",
    	"gruyère",
    	"guépard",
    	"guerrier",
    	"guide",
    	"guimauve",
    	"guitare",
    	"gustatif",
    	"gymnaste",
    	"gyrostat",
    	"habitude",
    	"hachoir",
    	"halte",
    	"hameau",
    	"hangar",
    	"hanneton",
    	"haricot",
    	"harmonie",
    	"harpon",
    	"hasard",
    	"hélium",
    	"hématome",
    	"herbe",
    	"hérisson",
    	"hermine",
    	"héron",
    	"hésiter",
    	"heureux",
    	"hiberner",
    	"hibou",
    	"hilarant",
    	"histoire",
    	"hiver",
    	"homard",
    	"hommage",
    	"homogène",
    	"honneur",
    	"honorer",
    	"honteux",
    	"horde",
    	"horizon",
    	"horloge",
    	"hormone",
    	"horrible",
    	"houleux",
    	"housse",
    	"hublot",
    	"huileux",
    	"humain",
    	"humble",
    	"humide",
    	"humour",
    	"hurler",
    	"hydromel",
    	"hygiène",
    	"hymne",
    	"hypnose",
    	"idylle",
    	"ignorer",
    	"iguane",
    	"illicite",
    	"illusion",
    	"image",
    	"imbiber",
    	"imiter",
    	"immense",
    	"immobile",
    	"immuable",
    	"impact",
    	"impérial",
    	"implorer",
    	"imposer",
    	"imprimer",
    	"imputer",
    	"incarner",
    	"incendie",
    	"incident",
    	"incliner",
    	"incolore",
    	"indexer",
    	"indice",
    	"inductif",
    	"inédit",
    	"ineptie",
    	"inexact",
    	"infini",
    	"infliger",
    	"informer",
    	"infusion",
    	"ingérer",
    	"inhaler",
    	"inhiber",
    	"injecter",
    	"injure",
    	"innocent",
    	"inoculer",
    	"inonder",
    	"inscrire",
    	"insecte",
    	"insigne",
    	"insolite",
    	"inspirer",
    	"instinct",
    	"insulter",
    	"intact",
    	"intense",
    	"intime",
    	"intrigue",
    	"intuitif",
    	"inutile",
    	"invasion",
    	"inventer",
    	"inviter",
    	"invoquer",
    	"ironique",
    	"irradier",
    	"irréel",
    	"irriter",
    	"isoler",
    	"ivoire",
    	"ivresse",
    	"jaguar",
    	"jaillir",
    	"jambe",
    	"janvier",
    	"jardin",
    	"jauger",
    	"jaune",
    	"javelot",
    	"jetable",
    	"jeton",
    	"jeudi",
    	"jeunesse",
    	"joindre",
    	"joncher",
    	"jongler",
    	"joueur",
    	"jouissif",
    	"journal",
    	"jovial",
    	"joyau",
    	"joyeux",
    	"jubiler",
    	"jugement",
    	"junior",
    	"jupon",
    	"juriste",
    	"justice",
    	"juteux",
    	"juvénile",
    	"kayak",
    	"kimono",
    	"kiosque",
    	"label",
    	"labial",
    	"labourer",
    	"lacérer",
    	"lactose",
    	"lagune",
    	"laine",
    	"laisser",
    	"laitier",
    	"lambeau",
    	"lamelle",
    	"lampe",
    	"lanceur",
    	"langage",
    	"lanterne",
    	"lapin",
    	"largeur",
    	"larme",
    	"laurier",
    	"lavabo",
    	"lavoir",
    	"lecture",
    	"légal",
    	"léger",
    	"légume",
    	"lessive",
    	"lettre",
    	"levier",
    	"lexique",
    	"lézard",
    	"liasse",
    	"libérer",
    	"libre",
    	"licence",
    	"licorne",
    	"liège",
    	"lièvre",
    	"ligature",
    	"ligoter",
    	"ligue",
    	"limer",
    	"limite",
    	"limonade",
    	"limpide",
    	"linéaire",
    	"lingot",
    	"lionceau",
    	"liquide",
    	"lisière",
    	"lister",
    	"lithium",
    	"litige",
    	"littoral",
    	"livreur",
    	"logique",
    	"lointain",
    	"loisir",
    	"lombric",
    	"loterie",
    	"louer",
    	"lourd",
    	"loutre",
    	"louve",
    	"loyal",
    	"lubie",
    	"lucide",
    	"lucratif",
    	"lueur",
    	"lugubre",
    	"luisant",
    	"lumière",
    	"lunaire",
    	"lundi",
    	"luron",
    	"lutter",
    	"luxueux",
    	"machine",
    	"magasin",
    	"magenta",
    	"magique",
    	"maigre",
    	"maillon",
    	"maintien",
    	"mairie",
    	"maison",
    	"majorer",
    	"malaxer",
    	"maléfice",
    	"malheur",
    	"malice",
    	"mallette",
    	"mammouth",
    	"mandater",
    	"maniable",
    	"manquant",
    	"manteau",
    	"manuel",
    	"marathon",
    	"marbre",
    	"marchand",
    	"mardi",
    	"maritime",
    	"marqueur",
    	"marron",
    	"marteler",
    	"mascotte",
    	"massif",
    	"matériel",
    	"matière",
    	"matraque",
    	"maudire",
    	"maussade",
    	"mauve",
    	"maximal",
    	"méchant",
    	"méconnu",
    	"médaille",
    	"médecin",
    	"méditer",
    	"méduse",
    	"meilleur",
    	"mélange",
    	"mélodie",
    	"membre",
    	"mémoire",
    	"menacer",
    	"mener",
    	"menhir",
    	"mensonge",
    	"mentor",
    	"mercredi",
    	"mérite",
    	"merle",
    	"messager",
    	"mesure",
    	"métal",
    	"météore",
    	"méthode",
    	"métier",
    	"meuble",
    	"miauler",
    	"microbe",
    	"miette",
    	"mignon",
    	"migrer",
    	"milieu",
    	"million",
    	"mimique",
    	"mince",
    	"minéral",
    	"minimal",
    	"minorer",
    	"minute",
    	"miracle",
    	"miroiter",
    	"missile",
    	"mixte",
    	"mobile",
    	"moderne",
    	"moelleux",
    	"mondial",
    	"moniteur",
    	"monnaie",
    	"monotone",
    	"monstre",
    	"montagne",
    	"monument",
    	"moqueur",
    	"morceau",
    	"morsure",
    	"mortier",
    	"moteur",
    	"motif",
    	"mouche",
    	"moufle",
    	"moulin",
    	"mousson",
    	"mouton",
    	"mouvant",
    	"multiple",
    	"munition",
    	"muraille",
    	"murène",
    	"murmure",
    	"muscle",
    	"muséum",
    	"musicien",
    	"mutation",
    	"muter",
    	"mutuel",
    	"myriade",
    	"myrtille",
    	"mystère",
    	"mythique",
    	"nageur",
    	"nappe",
    	"narquois",
    	"narrer",
    	"natation",
    	"nation",
    	"nature",
    	"naufrage",
    	"nautique",
    	"navire",
    	"nébuleux",
    	"nectar",
    	"néfaste",
    	"négation",
    	"négliger",
    	"négocier",
    	"neige",
    	"nerveux",
    	"nettoyer",
    	"neurone",
    	"neutron",
    	"neveu",
    	"niche",
    	"nickel",
    	"nitrate",
    	"niveau",
    	"noble",
    	"nocif",
    	"nocturne",
    	"noirceur",
    	"noisette",
    	"nomade",
    	"nombreux",
    	"nommer",
    	"normatif",
    	"notable",
    	"notifier",
    	"notoire",
    	"nourrir",
    	"nouveau",
    	"novateur",
    	"novembre",
    	"novice",
    	"nuage",
    	"nuancer",
    	"nuire",
    	"nuisible",
    	"numéro",
    	"nuptial",
    	"nuque",
    	"nutritif",
    	"obéir",
    	"objectif",
    	"obliger",
    	"obscur",
    	"observer",
    	"obstacle",
    	"obtenir",
    	"obturer",
    	"occasion",
    	"occuper",
    	"océan",
    	"octobre",
    	"octroyer",
    	"octupler",
    	"oculaire",
    	"odeur",
    	"odorant",
    	"offenser",
    	"officier",
    	"offrir",
    	"ogive",
    	"oiseau",
    	"oisillon",
    	"olfactif",
    	"olivier",
    	"ombrage",
    	"omettre",
    	"onctueux",
    	"onduler",
    	"onéreux",
    	"onirique",
    	"opale",
    	"opaque",
    	"opérer",
    	"opinion",
    	"opportun",
    	"opprimer",
    	"opter",
    	"optique",
    	"orageux",
    	"orange",
    	"orbite",
    	"ordonner",
    	"oreille",
    	"organe",
    	"orgueil",
    	"orifice",
    	"ornement",
    	"orque",
    	"ortie",
    	"osciller",
    	"osmose",
    	"ossature",
    	"otarie",
    	"ouragan",
    	"ourson",
    	"outil",
    	"outrager",
    	"ouvrage",
    	"ovation",
    	"oxyde",
    	"oxygène",
    	"ozone",
    	"paisible",
    	"palace",
    	"palmarès",
    	"palourde",
    	"palper",
    	"panache",
    	"panda",
    	"pangolin",
    	"paniquer",
    	"panneau",
    	"panorama",
    	"pantalon",
    	"papaye",
    	"papier",
    	"papoter",
    	"papyrus",
    	"paradoxe",
    	"parcelle",
    	"paresse",
    	"parfumer",
    	"parler",
    	"parole",
    	"parrain",
    	"parsemer",
    	"partager",
    	"parure",
    	"parvenir",
    	"passion",
    	"pastèque",
    	"paternel",
    	"patience",
    	"patron",
    	"pavillon",
    	"pavoiser",
    	"payer",
    	"paysage",
    	"peigne",
    	"peintre",
    	"pelage",
    	"pélican",
    	"pelle",
    	"pelouse",
    	"peluche",
    	"pendule",
    	"pénétrer",
    	"pénible",
    	"pensif",
    	"pénurie",
    	"pépite",
    	"péplum",
    	"perdrix",
    	"perforer",
    	"période",
    	"permuter",
    	"perplexe",
    	"persil",
    	"perte",
    	"peser",
    	"pétale",
    	"petit",
    	"pétrir",
    	"peuple",
    	"pharaon",
    	"phobie",
    	"phoque",
    	"photon",
    	"phrase",
    	"physique",
    	"piano",
    	"pictural",
    	"pièce",
    	"pierre",
    	"pieuvre",
    	"pilote",
    	"pinceau",
    	"pipette",
    	"piquer",
    	"pirogue",
    	"piscine",
    	"piston",
    	"pivoter",
    	"pixel",
    	"pizza",
    	"placard",
    	"plafond",
    	"plaisir",
    	"planer",
    	"plaque",
    	"plastron",
    	"plateau",
    	"pleurer",
    	"plexus",
    	"pliage",
    	"plomb",
    	"plonger",
    	"pluie",
    	"plumage",
    	"pochette",
    	"poésie",
    	"poète",
    	"pointe",
    	"poirier",
    	"poisson",
    	"poivre",
    	"polaire",
    	"policier",
    	"pollen",
    	"polygone",
    	"pommade",
    	"pompier",
    	"ponctuel",
    	"pondérer",
    	"poney",
    	"portique",
    	"position",
    	"posséder",
    	"posture",
    	"potager",
    	"poteau",
    	"potion",
    	"pouce",
    	"poulain",
    	"poumon",
    	"pourpre",
    	"poussin",
    	"pouvoir",
    	"prairie",
    	"pratique",
    	"précieux",
    	"prédire",
    	"préfixe",
    	"prélude",
    	"prénom",
    	"présence",
    	"prétexte",
    	"prévoir",
    	"primitif",
    	"prince",
    	"prison",
    	"priver",
    	"problème",
    	"procéder",
    	"prodige",
    	"profond",
    	"progrès",
    	"proie",
    	"projeter",
    	"prologue",
    	"promener",
    	"propre",
    	"prospère",
    	"protéger",
    	"prouesse",
    	"proverbe",
    	"prudence",
    	"pruneau",
    	"psychose",
    	"public",
    	"puceron",
    	"puiser",
    	"pulpe",
    	"pulsar",
    	"punaise",
    	"punitif",
    	"pupitre",
    	"purifier",
    	"puzzle",
    	"pyramide",
    	"quasar",
    	"querelle",
    	"question",
    	"quiétude",
    	"quitter",
    	"quotient",
    	"racine",
    	"raconter",
    	"radieux",
    	"ragondin",
    	"raideur",
    	"raisin",
    	"ralentir",
    	"rallonge",
    	"ramasser",
    	"rapide",
    	"rasage",
    	"ratisser",
    	"ravager",
    	"ravin",
    	"rayonner",
    	"réactif",
    	"réagir",
    	"réaliser",
    	"réanimer",
    	"recevoir",
    	"réciter",
    	"réclamer",
    	"récolter",
    	"recruter",
    	"reculer",
    	"recycler",
    	"rédiger",
    	"redouter",
    	"refaire",
    	"réflexe",
    	"réformer",
    	"refrain",
    	"refuge",
    	"régalien",
    	"région",
    	"réglage",
    	"régulier",
    	"réitérer",
    	"rejeter",
    	"rejouer",
    	"relatif",
    	"relever",
    	"relief",
    	"remarque",
    	"remède",
    	"remise",
    	"remonter",
    	"remplir",
    	"remuer",
    	"renard",
    	"renfort",
    	"renifler",
    	"renoncer",
    	"rentrer",
    	"renvoi",
    	"replier",
    	"reporter",
    	"reprise",
    	"reptile",
    	"requin",
    	"réserve",
    	"résineux",
    	"résoudre",
    	"respect",
    	"rester",
    	"résultat",
    	"rétablir",
    	"retenir",
    	"réticule",
    	"retomber",
    	"retracer",
    	"réunion",
    	"réussir",
    	"revanche",
    	"revivre",
    	"révolte",
    	"révulsif",
    	"richesse",
    	"rideau",
    	"rieur",
    	"rigide",
    	"rigoler",
    	"rincer",
    	"riposter",
    	"risible",
    	"risque",
    	"rituel",
    	"rival",
    	"rivière",
    	"rocheux",
    	"romance",
    	"rompre",
    	"ronce",
    	"rondin",
    	"roseau",
    	"rosier",
    	"rotatif",
    	"rotor",
    	"rotule",
    	"rouge",
    	"rouille",
    	"rouleau",
    	"routine",
    	"royaume",
    	"ruban",
    	"rubis",
    	"ruche",
    	"ruelle",
    	"rugueux",
    	"ruiner",
    	"ruisseau",
    	"ruser",
    	"rustique",
    	"rythme",
    	"sabler",
    	"saboter",
    	"sabre",
    	"sacoche",
    	"safari",
    	"sagesse",
    	"saisir",
    	"salade",
    	"salive",
    	"salon",
    	"saluer",
    	"samedi",
    	"sanction",
    	"sanglier",
    	"sarcasme",
    	"sardine",
    	"saturer",
    	"saugrenu",
    	"saumon",
    	"sauter",
    	"sauvage",
    	"savant",
    	"savonner",
    	"scalpel",
    	"scandale",
    	"scélérat",
    	"scénario",
    	"sceptre",
    	"schéma",
    	"science",
    	"scinder",
    	"score",
    	"scrutin",
    	"sculpter",
    	"séance",
    	"sécable",
    	"sécher",
    	"secouer",
    	"sécréter",
    	"sédatif",
    	"séduire",
    	"seigneur",
    	"séjour",
    	"sélectif",
    	"semaine",
    	"sembler",
    	"semence",
    	"séminal",
    	"sénateur",
    	"sensible",
    	"sentence",
    	"séparer",
    	"séquence",
    	"serein",
    	"sergent",
    	"sérieux",
    	"serrure",
    	"sérum",
    	"service",
    	"sésame",
    	"sévir",
    	"sevrage",
    	"sextuple",
    	"sidéral",
    	"siècle",
    	"siéger",
    	"siffler",
    	"sigle",
    	"signal",
    	"silence",
    	"silicium",
    	"simple",
    	"sincère",
    	"sinistre",
    	"siphon",
    	"sirop",
    	"sismique",
    	"situer",
    	"skier",
    	"social",
    	"socle",
    	"sodium",
    	"soigneux",
    	"soldat",
    	"soleil",
    	"solitude",
    	"soluble",
    	"sombre",
    	"sommeil",
    	"somnoler",
    	"sonde",
    	"songeur",
    	"sonnette",
    	"sonore",
    	"sorcier",
    	"sortir",
    	"sosie",
    	"sottise",
    	"soucieux",
    	"soudure",
    	"souffle",
    	"soulever",
    	"soupape",
    	"source",
    	"soutirer",
    	"souvenir",
    	"spacieux",
    	"spatial",
    	"spécial",
    	"sphère",
    	"spiral",
    	"stable",
    	"station",
    	"sternum",
    	"stimulus",
    	"stipuler",
    	"strict",
    	"studieux",
    	"stupeur",
    	"styliste",
    	"sublime",
    	"substrat",
    	"subtil",
    	"subvenir",
    	"succès",
    	"sucre",
    	"suffixe",
    	"suggérer",
    	"suiveur",
    	"sulfate",
    	"superbe",
    	"supplier",
    	"surface",
    	"suricate",
    	"surmener",
    	"surprise",
    	"sursaut",
    	"survie",
    	"suspect",
    	"syllabe",
    	"symbole",
    	"symétrie",
    	"synapse",
    	"syntaxe",
    	"système",
    	"tabac",
    	"tablier",
    	"tactile",
    	"tailler",
    	"talent",
    	"talisman",
    	"talonner",
    	"tambour",
    	"tamiser",
    	"tangible",
    	"tapis",
    	"taquiner",
    	"tarder",
    	"tarif",
    	"tartine",
    	"tasse",
    	"tatami",
    	"tatouage",
    	"taupe",
    	"taureau",
    	"taxer",
    	"témoin",
    	"temporel",
    	"tenaille",
    	"tendre",
    	"teneur",
    	"tenir",
    	"tension",
    	"terminer",
    	"terne",
    	"terrible",
    	"tétine",
    	"texte",
    	"thème",
    	"théorie",
    	"thérapie",
    	"thorax",
    	"tibia",
    	"tiède",
    	"timide",
    	"tirelire",
    	"tiroir",
    	"tissu",
    	"titane",
    	"titre",
    	"tituber",
    	"toboggan",
    	"tolérant",
    	"tomate",
    	"tonique",
    	"tonneau",
    	"toponyme",
    	"torche",
    	"tordre",
    	"tornade",
    	"torpille",
    	"torrent",
    	"torse",
    	"tortue",
    	"totem",
    	"toucher",
    	"tournage",
    	"tousser",
    	"toxine",
    	"traction",
    	"trafic",
    	"tragique",
    	"trahir",
    	"train",
    	"trancher",
    	"travail",
    	"trèfle",
    	"tremper",
    	"trésor",
    	"treuil",
    	"triage",
    	"tribunal",
    	"tricoter",
    	"trilogie",
    	"triomphe",
    	"tripler",
    	"triturer",
    	"trivial",
    	"trombone",
    	"tronc",
    	"tropical",
    	"troupeau",
    	"tuile",
    	"tulipe",
    	"tumulte",
    	"tunnel",
    	"turbine",
    	"tuteur",
    	"tutoyer",
    	"tuyau",
    	"tympan",
    	"typhon",
    	"typique",
    	"tyran",
    	"ubuesque",
    	"ultime",
    	"ultrason",
    	"unanime",
    	"unifier",
    	"union",
    	"unique",
    	"unitaire",
    	"univers",
    	"uranium",
    	"urbain",
    	"urticant",
    	"usage",
    	"usine",
    	"usuel",
    	"usure",
    	"utile",
    	"utopie",
    	"vacarme",
    	"vaccin",
    	"vagabond",
    	"vague",
    	"vaillant",
    	"vaincre",
    	"vaisseau",
    	"valable",
    	"valise",
    	"vallon",
    	"valve",
    	"vampire",
    	"vanille",
    	"vapeur",
    	"varier",
    	"vaseux",
    	"vassal",
    	"vaste",
    	"vecteur",
    	"vedette",
    	"végétal",
    	"véhicule",
    	"veinard",
    	"véloce",
    	"vendredi",
    	"vénérer",
    	"venger",
    	"venimeux",
    	"ventouse",
    	"verdure",
    	"vérin",
    	"vernir",
    	"verrou",
    	"verser",
    	"vertu",
    	"veston",
    	"vétéran",
    	"vétuste",
    	"vexant",
    	"vexer",
    	"viaduc",
    	"viande",
    	"victoire",
    	"vidange",
    	"vidéo",
    	"vignette",
    	"vigueur",
    	"vilain",
    	"village",
    	"vinaigre",
    	"violon",
    	"vipère",
    	"virement",
    	"virtuose",
    	"virus",
    	"visage",
    	"viseur",
    	"vision",
    	"visqueux",
    	"visuel",
    	"vital",
    	"vitesse",
    	"viticole",
    	"vitrine",
    	"vivace",
    	"vivipare",
    	"vocation",
    	"voguer",
    	"voile",
    	"voisin",
    	"voiture",
    	"volaille",
    	"volcan",
    	"voltiger",
    	"volume",
    	"vorace",
    	"vortex",
    	"voter",
    	"vouloir",
    	"voyage",
    	"voyelle",
    	"wagon",
    	"xénon",
    	"yacht",
    	"zèbre",
    	"zénith",
    	"zeste",
    	"zoologie"
    ];

    var require$$5 = [
    	"abaco",
    	"abbaglio",
    	"abbinato",
    	"abete",
    	"abisso",
    	"abolire",
    	"abrasivo",
    	"abrogato",
    	"accadere",
    	"accenno",
    	"accusato",
    	"acetone",
    	"achille",
    	"acido",
    	"acqua",
    	"acre",
    	"acrilico",
    	"acrobata",
    	"acuto",
    	"adagio",
    	"addebito",
    	"addome",
    	"adeguato",
    	"aderire",
    	"adipe",
    	"adottare",
    	"adulare",
    	"affabile",
    	"affetto",
    	"affisso",
    	"affranto",
    	"aforisma",
    	"afoso",
    	"africano",
    	"agave",
    	"agente",
    	"agevole",
    	"aggancio",
    	"agire",
    	"agitare",
    	"agonismo",
    	"agricolo",
    	"agrumeto",
    	"aguzzo",
    	"alabarda",
    	"alato",
    	"albatro",
    	"alberato",
    	"albo",
    	"albume",
    	"alce",
    	"alcolico",
    	"alettone",
    	"alfa",
    	"algebra",
    	"aliante",
    	"alibi",
    	"alimento",
    	"allagato",
    	"allegro",
    	"allievo",
    	"allodola",
    	"allusivo",
    	"almeno",
    	"alogeno",
    	"alpaca",
    	"alpestre",
    	"altalena",
    	"alterno",
    	"alticcio",
    	"altrove",
    	"alunno",
    	"alveolo",
    	"alzare",
    	"amalgama",
    	"amanita",
    	"amarena",
    	"ambito",
    	"ambrato",
    	"ameba",
    	"america",
    	"ametista",
    	"amico",
    	"ammasso",
    	"ammenda",
    	"ammirare",
    	"ammonito",
    	"amore",
    	"ampio",
    	"ampliare",
    	"amuleto",
    	"anacardo",
    	"anagrafe",
    	"analista",
    	"anarchia",
    	"anatra",
    	"anca",
    	"ancella",
    	"ancora",
    	"andare",
    	"andrea",
    	"anello",
    	"angelo",
    	"angolare",
    	"angusto",
    	"anima",
    	"annegare",
    	"annidato",
    	"anno",
    	"annuncio",
    	"anonimo",
    	"anticipo",
    	"anzi",
    	"apatico",
    	"apertura",
    	"apode",
    	"apparire",
    	"appetito",
    	"appoggio",
    	"approdo",
    	"appunto",
    	"aprile",
    	"arabica",
    	"arachide",
    	"aragosta",
    	"araldica",
    	"arancio",
    	"aratura",
    	"arazzo",
    	"arbitro",
    	"archivio",
    	"ardito",
    	"arenile",
    	"argento",
    	"argine",
    	"arguto",
    	"aria",
    	"armonia",
    	"arnese",
    	"arredato",
    	"arringa",
    	"arrosto",
    	"arsenico",
    	"arso",
    	"artefice",
    	"arzillo",
    	"asciutto",
    	"ascolto",
    	"asepsi",
    	"asettico",
    	"asfalto",
    	"asino",
    	"asola",
    	"aspirato",
    	"aspro",
    	"assaggio",
    	"asse",
    	"assoluto",
    	"assurdo",
    	"asta",
    	"astenuto",
    	"astice",
    	"astratto",
    	"atavico",
    	"ateismo",
    	"atomico",
    	"atono",
    	"attesa",
    	"attivare",
    	"attorno",
    	"attrito",
    	"attuale",
    	"ausilio",
    	"austria",
    	"autista",
    	"autonomo",
    	"autunno",
    	"avanzato",
    	"avere",
    	"avvenire",
    	"avviso",
    	"avvolgere",
    	"azione",
    	"azoto",
    	"azzimo",
    	"azzurro",
    	"babele",
    	"baccano",
    	"bacino",
    	"baco",
    	"badessa",
    	"badilata",
    	"bagnato",
    	"baita",
    	"balcone",
    	"baldo",
    	"balena",
    	"ballata",
    	"balzano",
    	"bambino",
    	"bandire",
    	"baraonda",
    	"barbaro",
    	"barca",
    	"baritono",
    	"barlume",
    	"barocco",
    	"basilico",
    	"basso",
    	"batosta",
    	"battuto",
    	"baule",
    	"bava",
    	"bavosa",
    	"becco",
    	"beffa",
    	"belgio",
    	"belva",
    	"benda",
    	"benevole",
    	"benigno",
    	"benzina",
    	"bere",
    	"berlina",
    	"beta",
    	"bibita",
    	"bici",
    	"bidone",
    	"bifido",
    	"biga",
    	"bilancia",
    	"bimbo",
    	"binocolo",
    	"biologo",
    	"bipede",
    	"bipolare",
    	"birbante",
    	"birra",
    	"biscotto",
    	"bisesto",
    	"bisnonno",
    	"bisonte",
    	"bisturi",
    	"bizzarro",
    	"blando",
    	"blatta",
    	"bollito",
    	"bonifico",
    	"bordo",
    	"bosco",
    	"botanico",
    	"bottino",
    	"bozzolo",
    	"braccio",
    	"bradipo",
    	"brama",
    	"branca",
    	"bravura",
    	"bretella",
    	"brevetto",
    	"brezza",
    	"briglia",
    	"brillante",
    	"brindare",
    	"broccolo",
    	"brodo",
    	"bronzina",
    	"brullo",
    	"bruno",
    	"bubbone",
    	"buca",
    	"budino",
    	"buffone",
    	"buio",
    	"bulbo",
    	"buono",
    	"burlone",
    	"burrasca",
    	"bussola",
    	"busta",
    	"cadetto",
    	"caduco",
    	"calamaro",
    	"calcolo",
    	"calesse",
    	"calibro",
    	"calmo",
    	"caloria",
    	"cambusa",
    	"camerata",
    	"camicia",
    	"cammino",
    	"camola",
    	"campale",
    	"canapa",
    	"candela",
    	"cane",
    	"canino",
    	"canotto",
    	"cantina",
    	"capace",
    	"capello",
    	"capitolo",
    	"capogiro",
    	"cappero",
    	"capra",
    	"capsula",
    	"carapace",
    	"carcassa",
    	"cardo",
    	"carisma",
    	"carovana",
    	"carretto",
    	"cartolina",
    	"casaccio",
    	"cascata",
    	"caserma",
    	"caso",
    	"cassone",
    	"castello",
    	"casuale",
    	"catasta",
    	"catena",
    	"catrame",
    	"cauto",
    	"cavillo",
    	"cedibile",
    	"cedrata",
    	"cefalo",
    	"celebre",
    	"cellulare",
    	"cena",
    	"cenone",
    	"centesimo",
    	"ceramica",
    	"cercare",
    	"certo",
    	"cerume",
    	"cervello",
    	"cesoia",
    	"cespo",
    	"ceto",
    	"chela",
    	"chiaro",
    	"chicca",
    	"chiedere",
    	"chimera",
    	"china",
    	"chirurgo",
    	"chitarra",
    	"ciao",
    	"ciclismo",
    	"cifrare",
    	"cigno",
    	"cilindro",
    	"ciottolo",
    	"circa",
    	"cirrosi",
    	"citrico",
    	"cittadino",
    	"ciuffo",
    	"civetta",
    	"civile",
    	"classico",
    	"clinica",
    	"cloro",
    	"cocco",
    	"codardo",
    	"codice",
    	"coerente",
    	"cognome",
    	"collare",
    	"colmato",
    	"colore",
    	"colposo",
    	"coltivato",
    	"colza",
    	"coma",
    	"cometa",
    	"commando",
    	"comodo",
    	"computer",
    	"comune",
    	"conciso",
    	"condurre",
    	"conferma",
    	"congelare",
    	"coniuge",
    	"connesso",
    	"conoscere",
    	"consumo",
    	"continuo",
    	"convegno",
    	"coperto",
    	"copione",
    	"coppia",
    	"copricapo",
    	"corazza",
    	"cordata",
    	"coricato",
    	"cornice",
    	"corolla",
    	"corpo",
    	"corredo",
    	"corsia",
    	"cortese",
    	"cosmico",
    	"costante",
    	"cottura",
    	"covato",
    	"cratere",
    	"cravatta",
    	"creato",
    	"credere",
    	"cremoso",
    	"crescita",
    	"creta",
    	"criceto",
    	"crinale",
    	"crisi",
    	"critico",
    	"croce",
    	"cronaca",
    	"crostata",
    	"cruciale",
    	"crusca",
    	"cucire",
    	"cuculo",
    	"cugino",
    	"cullato",
    	"cupola",
    	"curatore",
    	"cursore",
    	"curvo",
    	"cuscino",
    	"custode",
    	"dado",
    	"daino",
    	"dalmata",
    	"damerino",
    	"daniela",
    	"dannoso",
    	"danzare",
    	"datato",
    	"davanti",
    	"davvero",
    	"debutto",
    	"decennio",
    	"deciso",
    	"declino",
    	"decollo",
    	"decreto",
    	"dedicato",
    	"definito",
    	"deforme",
    	"degno",
    	"delegare",
    	"delfino",
    	"delirio",
    	"delta",
    	"demenza",
    	"denotato",
    	"dentro",
    	"deposito",
    	"derapata",
    	"derivare",
    	"deroga",
    	"descritto",
    	"deserto",
    	"desiderio",
    	"desumere",
    	"detersivo",
    	"devoto",
    	"diametro",
    	"dicembre",
    	"diedro",
    	"difeso",
    	"diffuso",
    	"digerire",
    	"digitale",
    	"diluvio",
    	"dinamico",
    	"dinnanzi",
    	"dipinto",
    	"diploma",
    	"dipolo",
    	"diradare",
    	"dire",
    	"dirotto",
    	"dirupo",
    	"disagio",
    	"discreto",
    	"disfare",
    	"disgelo",
    	"disposto",
    	"distanza",
    	"disumano",
    	"dito",
    	"divano",
    	"divelto",
    	"dividere",
    	"divorato",
    	"doblone",
    	"docente",
    	"doganale",
    	"dogma",
    	"dolce",
    	"domato",
    	"domenica",
    	"dominare",
    	"dondolo",
    	"dono",
    	"dormire",
    	"dote",
    	"dottore",
    	"dovuto",
    	"dozzina",
    	"drago",
    	"druido",
    	"dubbio",
    	"dubitare",
    	"ducale",
    	"duna",
    	"duomo",
    	"duplice",
    	"duraturo",
    	"ebano",
    	"eccesso",
    	"ecco",
    	"eclissi",
    	"economia",
    	"edera",
    	"edicola",
    	"edile",
    	"editoria",
    	"educare",
    	"egemonia",
    	"egli",
    	"egoismo",
    	"egregio",
    	"elaborato",
    	"elargire",
    	"elegante",
    	"elencato",
    	"eletto",
    	"elevare",
    	"elfico",
    	"elica",
    	"elmo",
    	"elsa",
    	"eluso",
    	"emanato",
    	"emblema",
    	"emesso",
    	"emiro",
    	"emotivo",
    	"emozione",
    	"empirico",
    	"emulo",
    	"endemico",
    	"enduro",
    	"energia",
    	"enfasi",
    	"enoteca",
    	"entrare",
    	"enzima",
    	"epatite",
    	"epilogo",
    	"episodio",
    	"epocale",
    	"eppure",
    	"equatore",
    	"erario",
    	"erba",
    	"erboso",
    	"erede",
    	"eremita",
    	"erigere",
    	"ermetico",
    	"eroe",
    	"erosivo",
    	"errante",
    	"esagono",
    	"esame",
    	"esanime",
    	"esaudire",
    	"esca",
    	"esempio",
    	"esercito",
    	"esibito",
    	"esigente",
    	"esistere",
    	"esito",
    	"esofago",
    	"esortato",
    	"esoso",
    	"espanso",
    	"espresso",
    	"essenza",
    	"esso",
    	"esteso",
    	"estimare",
    	"estonia",
    	"estroso",
    	"esultare",
    	"etilico",
    	"etnico",
    	"etrusco",
    	"etto",
    	"euclideo",
    	"europa",
    	"evaso",
    	"evidenza",
    	"evitato",
    	"evoluto",
    	"evviva",
    	"fabbrica",
    	"faccenda",
    	"fachiro",
    	"falco",
    	"famiglia",
    	"fanale",
    	"fanfara",
    	"fango",
    	"fantasma",
    	"fare",
    	"farfalla",
    	"farinoso",
    	"farmaco",
    	"fascia",
    	"fastoso",
    	"fasullo",
    	"faticare",
    	"fato",
    	"favoloso",
    	"febbre",
    	"fecola",
    	"fede",
    	"fegato",
    	"felpa",
    	"feltro",
    	"femmina",
    	"fendere",
    	"fenomeno",
    	"fermento",
    	"ferro",
    	"fertile",
    	"fessura",
    	"festivo",
    	"fetta",
    	"feudo",
    	"fiaba",
    	"fiducia",
    	"fifa",
    	"figurato",
    	"filo",
    	"finanza",
    	"finestra",
    	"finire",
    	"fiore",
    	"fiscale",
    	"fisico",
    	"fiume",
    	"flacone",
    	"flamenco",
    	"flebo",
    	"flemma",
    	"florido",
    	"fluente",
    	"fluoro",
    	"fobico",
    	"focaccia",
    	"focoso",
    	"foderato",
    	"foglio",
    	"folata",
    	"folclore",
    	"folgore",
    	"fondente",
    	"fonetico",
    	"fonia",
    	"fontana",
    	"forbito",
    	"forchetta",
    	"foresta",
    	"formica",
    	"fornaio",
    	"foro",
    	"fortezza",
    	"forzare",
    	"fosfato",
    	"fosso",
    	"fracasso",
    	"frana",
    	"frassino",
    	"fratello",
    	"freccetta",
    	"frenata",
    	"fresco",
    	"frigo",
    	"frollino",
    	"fronde",
    	"frugale",
    	"frutta",
    	"fucilata",
    	"fucsia",
    	"fuggente",
    	"fulmine",
    	"fulvo",
    	"fumante",
    	"fumetto",
    	"fumoso",
    	"fune",
    	"funzione",
    	"fuoco",
    	"furbo",
    	"furgone",
    	"furore",
    	"fuso",
    	"futile",
    	"gabbiano",
    	"gaffe",
    	"galateo",
    	"gallina",
    	"galoppo",
    	"gambero",
    	"gamma",
    	"garanzia",
    	"garbo",
    	"garofano",
    	"garzone",
    	"gasdotto",
    	"gasolio",
    	"gastrico",
    	"gatto",
    	"gaudio",
    	"gazebo",
    	"gazzella",
    	"geco",
    	"gelatina",
    	"gelso",
    	"gemello",
    	"gemmato",
    	"gene",
    	"genitore",
    	"gennaio",
    	"genotipo",
    	"gergo",
    	"ghepardo",
    	"ghiaccio",
    	"ghisa",
    	"giallo",
    	"gilda",
    	"ginepro",
    	"giocare",
    	"gioiello",
    	"giorno",
    	"giove",
    	"girato",
    	"girone",
    	"gittata",
    	"giudizio",
    	"giurato",
    	"giusto",
    	"globulo",
    	"glutine",
    	"gnomo",
    	"gobba",
    	"golf",
    	"gomito",
    	"gommone",
    	"gonfio",
    	"gonna",
    	"governo",
    	"gracile",
    	"grado",
    	"grafico",
    	"grammo",
    	"grande",
    	"grattare",
    	"gravoso",
    	"grazia",
    	"greca",
    	"gregge",
    	"grifone",
    	"grigio",
    	"grinza",
    	"grotta",
    	"gruppo",
    	"guadagno",
    	"guaio",
    	"guanto",
    	"guardare",
    	"gufo",
    	"guidare",
    	"ibernato",
    	"icona",
    	"identico",
    	"idillio",
    	"idolo",
    	"idra",
    	"idrico",
    	"idrogeno",
    	"igiene",
    	"ignaro",
    	"ignorato",
    	"ilare",
    	"illeso",
    	"illogico",
    	"illudere",
    	"imballo",
    	"imbevuto",
    	"imbocco",
    	"imbuto",
    	"immane",
    	"immerso",
    	"immolato",
    	"impacco",
    	"impeto",
    	"impiego",
    	"importo",
    	"impronta",
    	"inalare",
    	"inarcare",
    	"inattivo",
    	"incanto",
    	"incendio",
    	"inchino",
    	"incisivo",
    	"incluso",
    	"incontro",
    	"incrocio",
    	"incubo",
    	"indagine",
    	"india",
    	"indole",
    	"inedito",
    	"infatti",
    	"infilare",
    	"inflitto",
    	"ingaggio",
    	"ingegno",
    	"inglese",
    	"ingordo",
    	"ingrosso",
    	"innesco",
    	"inodore",
    	"inoltrare",
    	"inondato",
    	"insano",
    	"insetto",
    	"insieme",
    	"insonnia",
    	"insulina",
    	"intasato",
    	"intero",
    	"intonaco",
    	"intuito",
    	"inumidire",
    	"invalido",
    	"invece",
    	"invito",
    	"iperbole",
    	"ipnotico",
    	"ipotesi",
    	"ippica",
    	"iride",
    	"irlanda",
    	"ironico",
    	"irrigato",
    	"irrorare",
    	"isolato",
    	"isotopo",
    	"isterico",
    	"istituto",
    	"istrice",
    	"italia",
    	"iterare",
    	"labbro",
    	"labirinto",
    	"lacca",
    	"lacerato",
    	"lacrima",
    	"lacuna",
    	"laddove",
    	"lago",
    	"lampo",
    	"lancetta",
    	"lanterna",
    	"lardoso",
    	"larga",
    	"laringe",
    	"lastra",
    	"latenza",
    	"latino",
    	"lattuga",
    	"lavagna",
    	"lavoro",
    	"legale",
    	"leggero",
    	"lembo",
    	"lentezza",
    	"lenza",
    	"leone",
    	"lepre",
    	"lesivo",
    	"lessato",
    	"lesto",
    	"letterale",
    	"leva",
    	"levigato",
    	"libero",
    	"lido",
    	"lievito",
    	"lilla",
    	"limatura",
    	"limitare",
    	"limpido",
    	"lineare",
    	"lingua",
    	"liquido",
    	"lira",
    	"lirica",
    	"lisca",
    	"lite",
    	"litigio",
    	"livrea",
    	"locanda",
    	"lode",
    	"logica",
    	"lombare",
    	"londra",
    	"longevo",
    	"loquace",
    	"lorenzo",
    	"loto",
    	"lotteria",
    	"luce",
    	"lucidato",
    	"lumaca",
    	"luminoso",
    	"lungo",
    	"lupo",
    	"luppolo",
    	"lusinga",
    	"lusso",
    	"lutto",
    	"macabro",
    	"macchina",
    	"macero",
    	"macinato",
    	"madama",
    	"magico",
    	"maglia",
    	"magnete",
    	"magro",
    	"maiolica",
    	"malafede",
    	"malgrado",
    	"malinteso",
    	"malsano",
    	"malto",
    	"malumore",
    	"mana",
    	"mancia",
    	"mandorla",
    	"mangiare",
    	"manifesto",
    	"mannaro",
    	"manovra",
    	"mansarda",
    	"mantide",
    	"manubrio",
    	"mappa",
    	"maratona",
    	"marcire",
    	"maretta",
    	"marmo",
    	"marsupio",
    	"maschera",
    	"massaia",
    	"mastino",
    	"materasso",
    	"matricola",
    	"mattone",
    	"maturo",
    	"mazurca",
    	"meandro",
    	"meccanico",
    	"mecenate",
    	"medesimo",
    	"meditare",
    	"mega",
    	"melassa",
    	"melis",
    	"melodia",
    	"meninge",
    	"meno",
    	"mensola",
    	"mercurio",
    	"merenda",
    	"merlo",
    	"meschino",
    	"mese",
    	"messere",
    	"mestolo",
    	"metallo",
    	"metodo",
    	"mettere",
    	"miagolare",
    	"mica",
    	"micelio",
    	"michele",
    	"microbo",
    	"midollo",
    	"miele",
    	"migliore",
    	"milano",
    	"milite",
    	"mimosa",
    	"minerale",
    	"mini",
    	"minore",
    	"mirino",
    	"mirtillo",
    	"miscela",
    	"missiva",
    	"misto",
    	"misurare",
    	"mitezza",
    	"mitigare",
    	"mitra",
    	"mittente",
    	"mnemonico",
    	"modello",
    	"modifica",
    	"modulo",
    	"mogano",
    	"mogio",
    	"mole",
    	"molosso",
    	"monastero",
    	"monco",
    	"mondina",
    	"monetario",
    	"monile",
    	"monotono",
    	"monsone",
    	"montato",
    	"monviso",
    	"mora",
    	"mordere",
    	"morsicato",
    	"mostro",
    	"motivato",
    	"motosega",
    	"motto",
    	"movenza",
    	"movimento",
    	"mozzo",
    	"mucca",
    	"mucosa",
    	"muffa",
    	"mughetto",
    	"mugnaio",
    	"mulatto",
    	"mulinello",
    	"multiplo",
    	"mummia",
    	"munto",
    	"muovere",
    	"murale",
    	"musa",
    	"muscolo",
    	"musica",
    	"mutevole",
    	"muto",
    	"nababbo",
    	"nafta",
    	"nanometro",
    	"narciso",
    	"narice",
    	"narrato",
    	"nascere",
    	"nastrare",
    	"naturale",
    	"nautica",
    	"naviglio",
    	"nebulosa",
    	"necrosi",
    	"negativo",
    	"negozio",
    	"nemmeno",
    	"neofita",
    	"neretto",
    	"nervo",
    	"nessuno",
    	"nettuno",
    	"neutrale",
    	"neve",
    	"nevrotico",
    	"nicchia",
    	"ninfa",
    	"nitido",
    	"nobile",
    	"nocivo",
    	"nodo",
    	"nome",
    	"nomina",
    	"nordico",
    	"normale",
    	"norvegese",
    	"nostrano",
    	"notare",
    	"notizia",
    	"notturno",
    	"novella",
    	"nucleo",
    	"nulla",
    	"numero",
    	"nuovo",
    	"nutrire",
    	"nuvola",
    	"nuziale",
    	"oasi",
    	"obbedire",
    	"obbligo",
    	"obelisco",
    	"oblio",
    	"obolo",
    	"obsoleto",
    	"occasione",
    	"occhio",
    	"occidente",
    	"occorrere",
    	"occultare",
    	"ocra",
    	"oculato",
    	"odierno",
    	"odorare",
    	"offerta",
    	"offrire",
    	"offuscato",
    	"oggetto",
    	"oggi",
    	"ognuno",
    	"olandese",
    	"olfatto",
    	"oliato",
    	"oliva",
    	"ologramma",
    	"oltre",
    	"omaggio",
    	"ombelico",
    	"ombra",
    	"omega",
    	"omissione",
    	"ondoso",
    	"onere",
    	"onice",
    	"onnivoro",
    	"onorevole",
    	"onta",
    	"operato",
    	"opinione",
    	"opposto",
    	"oracolo",
    	"orafo",
    	"ordine",
    	"orecchino",
    	"orefice",
    	"orfano",
    	"organico",
    	"origine",
    	"orizzonte",
    	"orma",
    	"ormeggio",
    	"ornativo",
    	"orologio",
    	"orrendo",
    	"orribile",
    	"ortensia",
    	"ortica",
    	"orzata",
    	"orzo",
    	"osare",
    	"oscurare",
    	"osmosi",
    	"ospedale",
    	"ospite",
    	"ossa",
    	"ossidare",
    	"ostacolo",
    	"oste",
    	"otite",
    	"otre",
    	"ottagono",
    	"ottimo",
    	"ottobre",
    	"ovale",
    	"ovest",
    	"ovino",
    	"oviparo",
    	"ovocito",
    	"ovunque",
    	"ovviare",
    	"ozio",
    	"pacchetto",
    	"pace",
    	"pacifico",
    	"padella",
    	"padrone",
    	"paese",
    	"paga",
    	"pagina",
    	"palazzina",
    	"palesare",
    	"pallido",
    	"palo",
    	"palude",
    	"pandoro",
    	"pannello",
    	"paolo",
    	"paonazzo",
    	"paprica",
    	"parabola",
    	"parcella",
    	"parere",
    	"pargolo",
    	"pari",
    	"parlato",
    	"parola",
    	"partire",
    	"parvenza",
    	"parziale",
    	"passivo",
    	"pasticca",
    	"patacca",
    	"patologia",
    	"pattume",
    	"pavone",
    	"peccato",
    	"pedalare",
    	"pedonale",
    	"peggio",
    	"peloso",
    	"penare",
    	"pendice",
    	"penisola",
    	"pennuto",
    	"penombra",
    	"pensare",
    	"pentola",
    	"pepe",
    	"pepita",
    	"perbene",
    	"percorso",
    	"perdonato",
    	"perforare",
    	"pergamena",
    	"periodo",
    	"permesso",
    	"perno",
    	"perplesso",
    	"persuaso",
    	"pertugio",
    	"pervaso",
    	"pesatore",
    	"pesista",
    	"peso",
    	"pestifero",
    	"petalo",
    	"pettine",
    	"petulante",
    	"pezzo",
    	"piacere",
    	"pianta",
    	"piattino",
    	"piccino",
    	"picozza",
    	"piega",
    	"pietra",
    	"piffero",
    	"pigiama",
    	"pigolio",
    	"pigro",
    	"pila",
    	"pilifero",
    	"pillola",
    	"pilota",
    	"pimpante",
    	"pineta",
    	"pinna",
    	"pinolo",
    	"pioggia",
    	"piombo",
    	"piramide",
    	"piretico",
    	"pirite",
    	"pirolisi",
    	"pitone",
    	"pizzico",
    	"placebo",
    	"planare",
    	"plasma",
    	"platano",
    	"plenario",
    	"pochezza",
    	"poderoso",
    	"podismo",
    	"poesia",
    	"poggiare",
    	"polenta",
    	"poligono",
    	"pollice",
    	"polmonite",
    	"polpetta",
    	"polso",
    	"poltrona",
    	"polvere",
    	"pomice",
    	"pomodoro",
    	"ponte",
    	"popoloso",
    	"porfido",
    	"poroso",
    	"porpora",
    	"porre",
    	"portata",
    	"posa",
    	"positivo",
    	"possesso",
    	"postulato",
    	"potassio",
    	"potere",
    	"pranzo",
    	"prassi",
    	"pratica",
    	"precluso",
    	"predica",
    	"prefisso",
    	"pregiato",
    	"prelievo",
    	"premere",
    	"prenotare",
    	"preparato",
    	"presenza",
    	"pretesto",
    	"prevalso",
    	"prima",
    	"principe",
    	"privato",
    	"problema",
    	"procura",
    	"produrre",
    	"profumo",
    	"progetto",
    	"prolunga",
    	"promessa",
    	"pronome",
    	"proposta",
    	"proroga",
    	"proteso",
    	"prova",
    	"prudente",
    	"prugna",
    	"prurito",
    	"psiche",
    	"pubblico",
    	"pudica",
    	"pugilato",
    	"pugno",
    	"pulce",
    	"pulito",
    	"pulsante",
    	"puntare",
    	"pupazzo",
    	"pupilla",
    	"puro",
    	"quadro",
    	"qualcosa",
    	"quasi",
    	"querela",
    	"quota",
    	"raccolto",
    	"raddoppio",
    	"radicale",
    	"radunato",
    	"raffica",
    	"ragazzo",
    	"ragione",
    	"ragno",
    	"ramarro",
    	"ramingo",
    	"ramo",
    	"randagio",
    	"rantolare",
    	"rapato",
    	"rapina",
    	"rappreso",
    	"rasatura",
    	"raschiato",
    	"rasente",
    	"rassegna",
    	"rastrello",
    	"rata",
    	"ravveduto",
    	"reale",
    	"recepire",
    	"recinto",
    	"recluta",
    	"recondito",
    	"recupero",
    	"reddito",
    	"redimere",
    	"regalato",
    	"registro",
    	"regola",
    	"regresso",
    	"relazione",
    	"remare",
    	"remoto",
    	"renna",
    	"replica",
    	"reprimere",
    	"reputare",
    	"resa",
    	"residente",
    	"responso",
    	"restauro",
    	"rete",
    	"retina",
    	"retorica",
    	"rettifica",
    	"revocato",
    	"riassunto",
    	"ribadire",
    	"ribelle",
    	"ribrezzo",
    	"ricarica",
    	"ricco",
    	"ricevere",
    	"riciclato",
    	"ricordo",
    	"ricreduto",
    	"ridicolo",
    	"ridurre",
    	"rifasare",
    	"riflesso",
    	"riforma",
    	"rifugio",
    	"rigare",
    	"rigettato",
    	"righello",
    	"rilassato",
    	"rilevato",
    	"rimanere",
    	"rimbalzo",
    	"rimedio",
    	"rimorchio",
    	"rinascita",
    	"rincaro",
    	"rinforzo",
    	"rinnovo",
    	"rinomato",
    	"rinsavito",
    	"rintocco",
    	"rinuncia",
    	"rinvenire",
    	"riparato",
    	"ripetuto",
    	"ripieno",
    	"riportare",
    	"ripresa",
    	"ripulire",
    	"risata",
    	"rischio",
    	"riserva",
    	"risibile",
    	"riso",
    	"rispetto",
    	"ristoro",
    	"risultato",
    	"risvolto",
    	"ritardo",
    	"ritegno",
    	"ritmico",
    	"ritrovo",
    	"riunione",
    	"riva",
    	"riverso",
    	"rivincita",
    	"rivolto",
    	"rizoma",
    	"roba",
    	"robotico",
    	"robusto",
    	"roccia",
    	"roco",
    	"rodaggio",
    	"rodere",
    	"roditore",
    	"rogito",
    	"rollio",
    	"romantico",
    	"rompere",
    	"ronzio",
    	"rosolare",
    	"rospo",
    	"rotante",
    	"rotondo",
    	"rotula",
    	"rovescio",
    	"rubizzo",
    	"rubrica",
    	"ruga",
    	"rullino",
    	"rumine",
    	"rumoroso",
    	"ruolo",
    	"rupe",
    	"russare",
    	"rustico",
    	"sabato",
    	"sabbiare",
    	"sabotato",
    	"sagoma",
    	"salasso",
    	"saldatura",
    	"salgemma",
    	"salivare",
    	"salmone",
    	"salone",
    	"saltare",
    	"saluto",
    	"salvo",
    	"sapere",
    	"sapido",
    	"saporito",
    	"saraceno",
    	"sarcasmo",
    	"sarto",
    	"sassoso",
    	"satellite",
    	"satira",
    	"satollo",
    	"saturno",
    	"savana",
    	"savio",
    	"saziato",
    	"sbadiglio",
    	"sbalzo",
    	"sbancato",
    	"sbarra",
    	"sbattere",
    	"sbavare",
    	"sbendare",
    	"sbirciare",
    	"sbloccato",
    	"sbocciato",
    	"sbrinare",
    	"sbruffone",
    	"sbuffare",
    	"scabroso",
    	"scadenza",
    	"scala",
    	"scambiare",
    	"scandalo",
    	"scapola",
    	"scarso",
    	"scatenare",
    	"scavato",
    	"scelto",
    	"scenico",
    	"scettro",
    	"scheda",
    	"schiena",
    	"sciarpa",
    	"scienza",
    	"scindere",
    	"scippo",
    	"sciroppo",
    	"scivolo",
    	"sclerare",
    	"scodella",
    	"scolpito",
    	"scomparto",
    	"sconforto",
    	"scoprire",
    	"scorta",
    	"scossone",
    	"scozzese",
    	"scriba",
    	"scrollare",
    	"scrutinio",
    	"scuderia",
    	"scultore",
    	"scuola",
    	"scuro",
    	"scusare",
    	"sdebitare",
    	"sdoganare",
    	"seccatura",
    	"secondo",
    	"sedano",
    	"seggiola",
    	"segnalato",
    	"segregato",
    	"seguito",
    	"selciato",
    	"selettivo",
    	"sella",
    	"selvaggio",
    	"semaforo",
    	"sembrare",
    	"seme",
    	"seminato",
    	"sempre",
    	"senso",
    	"sentire",
    	"sepolto",
    	"sequenza",
    	"serata",
    	"serbato",
    	"sereno",
    	"serio",
    	"serpente",
    	"serraglio",
    	"servire",
    	"sestina",
    	"setola",
    	"settimana",
    	"sfacelo",
    	"sfaldare",
    	"sfamato",
    	"sfarzoso",
    	"sfaticato",
    	"sfera",
    	"sfida",
    	"sfilato",
    	"sfinge",
    	"sfocato",
    	"sfoderare",
    	"sfogo",
    	"sfoltire",
    	"sforzato",
    	"sfratto",
    	"sfruttato",
    	"sfuggito",
    	"sfumare",
    	"sfuso",
    	"sgabello",
    	"sgarbato",
    	"sgonfiare",
    	"sgorbio",
    	"sgrassato",
    	"sguardo",
    	"sibilo",
    	"siccome",
    	"sierra",
    	"sigla",
    	"signore",
    	"silenzio",
    	"sillaba",
    	"simbolo",
    	"simpatico",
    	"simulato",
    	"sinfonia",
    	"singolo",
    	"sinistro",
    	"sino",
    	"sintesi",
    	"sinusoide",
    	"sipario",
    	"sisma",
    	"sistole",
    	"situato",
    	"slitta",
    	"slogatura",
    	"sloveno",
    	"smarrito",
    	"smemorato",
    	"smentito",
    	"smeraldo",
    	"smilzo",
    	"smontare",
    	"smottato",
    	"smussato",
    	"snellire",
    	"snervato",
    	"snodo",
    	"sobbalzo",
    	"sobrio",
    	"soccorso",
    	"sociale",
    	"sodale",
    	"soffitto",
    	"sogno",
    	"soldato",
    	"solenne",
    	"solido",
    	"sollazzo",
    	"solo",
    	"solubile",
    	"solvente",
    	"somatico",
    	"somma",
    	"sonda",
    	"sonetto",
    	"sonnifero",
    	"sopire",
    	"soppeso",
    	"sopra",
    	"sorgere",
    	"sorpasso",
    	"sorriso",
    	"sorso",
    	"sorteggio",
    	"sorvolato",
    	"sospiro",
    	"sosta",
    	"sottile",
    	"spada",
    	"spalla",
    	"spargere",
    	"spatola",
    	"spavento",
    	"spazzola",
    	"specie",
    	"spedire",
    	"spegnere",
    	"spelatura",
    	"speranza",
    	"spessore",
    	"spettrale",
    	"spezzato",
    	"spia",
    	"spigoloso",
    	"spillato",
    	"spinoso",
    	"spirale",
    	"splendido",
    	"sportivo",
    	"sposo",
    	"spranga",
    	"sprecare",
    	"spronato",
    	"spruzzo",
    	"spuntino",
    	"squillo",
    	"sradicare",
    	"srotolato",
    	"stabile",
    	"stacco",
    	"staffa",
    	"stagnare",
    	"stampato",
    	"stantio",
    	"starnuto",
    	"stasera",
    	"statuto",
    	"stelo",
    	"steppa",
    	"sterzo",
    	"stiletto",
    	"stima",
    	"stirpe",
    	"stivale",
    	"stizzoso",
    	"stonato",
    	"storico",
    	"strappo",
    	"stregato",
    	"stridulo",
    	"strozzare",
    	"strutto",
    	"stuccare",
    	"stufo",
    	"stupendo",
    	"subentro",
    	"succoso",
    	"sudore",
    	"suggerito",
    	"sugo",
    	"sultano",
    	"suonare",
    	"superbo",
    	"supporto",
    	"surgelato",
    	"surrogato",
    	"sussurro",
    	"sutura",
    	"svagare",
    	"svedese",
    	"sveglio",
    	"svelare",
    	"svenuto",
    	"svezia",
    	"sviluppo",
    	"svista",
    	"svizzera",
    	"svolta",
    	"svuotare",
    	"tabacco",
    	"tabulato",
    	"tacciare",
    	"taciturno",
    	"tale",
    	"talismano",
    	"tampone",
    	"tannino",
    	"tara",
    	"tardivo",
    	"targato",
    	"tariffa",
    	"tarpare",
    	"tartaruga",
    	"tasto",
    	"tattico",
    	"taverna",
    	"tavolata",
    	"tazza",
    	"teca",
    	"tecnico",
    	"telefono",
    	"temerario",
    	"tempo",
    	"temuto",
    	"tendone",
    	"tenero",
    	"tensione",
    	"tentacolo",
    	"teorema",
    	"terme",
    	"terrazzo",
    	"terzetto",
    	"tesi",
    	"tesserato",
    	"testato",
    	"tetro",
    	"tettoia",
    	"tifare",
    	"tigella",
    	"timbro",
    	"tinto",
    	"tipico",
    	"tipografo",
    	"tiraggio",
    	"tiro",
    	"titanio",
    	"titolo",
    	"titubante",
    	"tizio",
    	"tizzone",
    	"toccare",
    	"tollerare",
    	"tolto",
    	"tombola",
    	"tomo",
    	"tonfo",
    	"tonsilla",
    	"topazio",
    	"topologia",
    	"toppa",
    	"torba",
    	"tornare",
    	"torrone",
    	"tortora",
    	"toscano",
    	"tossire",
    	"tostatura",
    	"totano",
    	"trabocco",
    	"trachea",
    	"trafila",
    	"tragedia",
    	"tralcio",
    	"tramonto",
    	"transito",
    	"trapano",
    	"trarre",
    	"trasloco",
    	"trattato",
    	"trave",
    	"treccia",
    	"tremolio",
    	"trespolo",
    	"tributo",
    	"tricheco",
    	"trifoglio",
    	"trillo",
    	"trincea",
    	"trio",
    	"tristezza",
    	"triturato",
    	"trivella",
    	"tromba",
    	"trono",
    	"troppo",
    	"trottola",
    	"trovare",
    	"truccato",
    	"tubatura",
    	"tuffato",
    	"tulipano",
    	"tumulto",
    	"tunisia",
    	"turbare",
    	"turchino",
    	"tuta",
    	"tutela",
    	"ubicato",
    	"uccello",
    	"uccisore",
    	"udire",
    	"uditivo",
    	"uffa",
    	"ufficio",
    	"uguale",
    	"ulisse",
    	"ultimato",
    	"umano",
    	"umile",
    	"umorismo",
    	"uncinetto",
    	"ungere",
    	"ungherese",
    	"unicorno",
    	"unificato",
    	"unisono",
    	"unitario",
    	"unte",
    	"uovo",
    	"upupa",
    	"uragano",
    	"urgenza",
    	"urlo",
    	"usanza",
    	"usato",
    	"uscito",
    	"usignolo",
    	"usuraio",
    	"utensile",
    	"utilizzo",
    	"utopia",
    	"vacante",
    	"vaccinato",
    	"vagabondo",
    	"vagliato",
    	"valanga",
    	"valgo",
    	"valico",
    	"valletta",
    	"valoroso",
    	"valutare",
    	"valvola",
    	"vampata",
    	"vangare",
    	"vanitoso",
    	"vano",
    	"vantaggio",
    	"vanvera",
    	"vapore",
    	"varano",
    	"varcato",
    	"variante",
    	"vasca",
    	"vedetta",
    	"vedova",
    	"veduto",
    	"vegetale",
    	"veicolo",
    	"velcro",
    	"velina",
    	"velluto",
    	"veloce",
    	"venato",
    	"vendemmia",
    	"vento",
    	"verace",
    	"verbale",
    	"vergogna",
    	"verifica",
    	"vero",
    	"verruca",
    	"verticale",
    	"vescica",
    	"vessillo",
    	"vestale",
    	"veterano",
    	"vetrina",
    	"vetusto",
    	"viandante",
    	"vibrante",
    	"vicenda",
    	"vichingo",
    	"vicinanza",
    	"vidimare",
    	"vigilia",
    	"vigneto",
    	"vigore",
    	"vile",
    	"villano",
    	"vimini",
    	"vincitore",
    	"viola",
    	"vipera",
    	"virgola",
    	"virologo",
    	"virulento",
    	"viscoso",
    	"visione",
    	"vispo",
    	"vissuto",
    	"visura",
    	"vita",
    	"vitello",
    	"vittima",
    	"vivanda",
    	"vivido",
    	"viziare",
    	"voce",
    	"voga",
    	"volatile",
    	"volere",
    	"volpe",
    	"voragine",
    	"vulcano",
    	"zampogna",
    	"zanna",
    	"zappato",
    	"zattera",
    	"zavorra",
    	"zefiro",
    	"zelante",
    	"zelo",
    	"zenzero",
    	"zerbino",
    	"zibetto",
    	"zinco",
    	"zircone",
    	"zitto",
    	"zolla",
    	"zotico",
    	"zucchero",
    	"zufolo",
    	"zulu",
    	"zuppa"
    ];

    var require$$6 = [
    	"ábaco",
    	"abdomen",
    	"abeja",
    	"abierto",
    	"abogado",
    	"abono",
    	"aborto",
    	"abrazo",
    	"abrir",
    	"abuelo",
    	"abuso",
    	"acabar",
    	"academia",
    	"acceso",
    	"acción",
    	"aceite",
    	"acelga",
    	"acento",
    	"aceptar",
    	"ácido",
    	"aclarar",
    	"acné",
    	"acoger",
    	"acoso",
    	"activo",
    	"acto",
    	"actriz",
    	"actuar",
    	"acudir",
    	"acuerdo",
    	"acusar",
    	"adicto",
    	"admitir",
    	"adoptar",
    	"adorno",
    	"aduana",
    	"adulto",
    	"aéreo",
    	"afectar",
    	"afición",
    	"afinar",
    	"afirmar",
    	"ágil",
    	"agitar",
    	"agonía",
    	"agosto",
    	"agotar",
    	"agregar",
    	"agrio",
    	"agua",
    	"agudo",
    	"águila",
    	"aguja",
    	"ahogo",
    	"ahorro",
    	"aire",
    	"aislar",
    	"ajedrez",
    	"ajeno",
    	"ajuste",
    	"alacrán",
    	"alambre",
    	"alarma",
    	"alba",
    	"álbum",
    	"alcalde",
    	"aldea",
    	"alegre",
    	"alejar",
    	"alerta",
    	"aleta",
    	"alfiler",
    	"alga",
    	"algodón",
    	"aliado",
    	"aliento",
    	"alivio",
    	"alma",
    	"almeja",
    	"almíbar",
    	"altar",
    	"alteza",
    	"altivo",
    	"alto",
    	"altura",
    	"alumno",
    	"alzar",
    	"amable",
    	"amante",
    	"amapola",
    	"amargo",
    	"amasar",
    	"ámbar",
    	"ámbito",
    	"ameno",
    	"amigo",
    	"amistad",
    	"amor",
    	"amparo",
    	"amplio",
    	"ancho",
    	"anciano",
    	"ancla",
    	"andar",
    	"andén",
    	"anemia",
    	"ángulo",
    	"anillo",
    	"ánimo",
    	"anís",
    	"anotar",
    	"antena",
    	"antiguo",
    	"antojo",
    	"anual",
    	"anular",
    	"anuncio",
    	"añadir",
    	"añejo",
    	"año",
    	"apagar",
    	"aparato",
    	"apetito",
    	"apio",
    	"aplicar",
    	"apodo",
    	"aporte",
    	"apoyo",
    	"aprender",
    	"aprobar",
    	"apuesta",
    	"apuro",
    	"arado",
    	"araña",
    	"arar",
    	"árbitro",
    	"árbol",
    	"arbusto",
    	"archivo",
    	"arco",
    	"arder",
    	"ardilla",
    	"arduo",
    	"área",
    	"árido",
    	"aries",
    	"armonía",
    	"arnés",
    	"aroma",
    	"arpa",
    	"arpón",
    	"arreglo",
    	"arroz",
    	"arruga",
    	"arte",
    	"artista",
    	"asa",
    	"asado",
    	"asalto",
    	"ascenso",
    	"asegurar",
    	"aseo",
    	"asesor",
    	"asiento",
    	"asilo",
    	"asistir",
    	"asno",
    	"asombro",
    	"áspero",
    	"astilla",
    	"astro",
    	"astuto",
    	"asumir",
    	"asunto",
    	"atajo",
    	"ataque",
    	"atar",
    	"atento",
    	"ateo",
    	"ático",
    	"atleta",
    	"átomo",
    	"atraer",
    	"atroz",
    	"atún",
    	"audaz",
    	"audio",
    	"auge",
    	"aula",
    	"aumento",
    	"ausente",
    	"autor",
    	"aval",
    	"avance",
    	"avaro",
    	"ave",
    	"avellana",
    	"avena",
    	"avestruz",
    	"avión",
    	"aviso",
    	"ayer",
    	"ayuda",
    	"ayuno",
    	"azafrán",
    	"azar",
    	"azote",
    	"azúcar",
    	"azufre",
    	"azul",
    	"baba",
    	"babor",
    	"bache",
    	"bahía",
    	"baile",
    	"bajar",
    	"balanza",
    	"balcón",
    	"balde",
    	"bambú",
    	"banco",
    	"banda",
    	"baño",
    	"barba",
    	"barco",
    	"barniz",
    	"barro",
    	"báscula",
    	"bastón",
    	"basura",
    	"batalla",
    	"batería",
    	"batir",
    	"batuta",
    	"baúl",
    	"bazar",
    	"bebé",
    	"bebida",
    	"bello",
    	"besar",
    	"beso",
    	"bestia",
    	"bicho",
    	"bien",
    	"bingo",
    	"blanco",
    	"bloque",
    	"blusa",
    	"boa",
    	"bobina",
    	"bobo",
    	"boca",
    	"bocina",
    	"boda",
    	"bodega",
    	"boina",
    	"bola",
    	"bolero",
    	"bolsa",
    	"bomba",
    	"bondad",
    	"bonito",
    	"bono",
    	"bonsái",
    	"borde",
    	"borrar",
    	"bosque",
    	"bote",
    	"botín",
    	"bóveda",
    	"bozal",
    	"bravo",
    	"brazo",
    	"brecha",
    	"breve",
    	"brillo",
    	"brinco",
    	"brisa",
    	"broca",
    	"broma",
    	"bronce",
    	"brote",
    	"bruja",
    	"brusco",
    	"bruto",
    	"buceo",
    	"bucle",
    	"bueno",
    	"buey",
    	"bufanda",
    	"bufón",
    	"búho",
    	"buitre",
    	"bulto",
    	"burbuja",
    	"burla",
    	"burro",
    	"buscar",
    	"butaca",
    	"buzón",
    	"caballo",
    	"cabeza",
    	"cabina",
    	"cabra",
    	"cacao",
    	"cadáver",
    	"cadena",
    	"caer",
    	"café",
    	"caída",
    	"caimán",
    	"caja",
    	"cajón",
    	"cal",
    	"calamar",
    	"calcio",
    	"caldo",
    	"calidad",
    	"calle",
    	"calma",
    	"calor",
    	"calvo",
    	"cama",
    	"cambio",
    	"camello",
    	"camino",
    	"campo",
    	"cáncer",
    	"candil",
    	"canela",
    	"canguro",
    	"canica",
    	"canto",
    	"caña",
    	"cañón",
    	"caoba",
    	"caos",
    	"capaz",
    	"capitán",
    	"capote",
    	"captar",
    	"capucha",
    	"cara",
    	"carbón",
    	"cárcel",
    	"careta",
    	"carga",
    	"cariño",
    	"carne",
    	"carpeta",
    	"carro",
    	"carta",
    	"casa",
    	"casco",
    	"casero",
    	"caspa",
    	"castor",
    	"catorce",
    	"catre",
    	"caudal",
    	"causa",
    	"cazo",
    	"cebolla",
    	"ceder",
    	"cedro",
    	"celda",
    	"célebre",
    	"celoso",
    	"célula",
    	"cemento",
    	"ceniza",
    	"centro",
    	"cerca",
    	"cerdo",
    	"cereza",
    	"cero",
    	"cerrar",
    	"certeza",
    	"césped",
    	"cetro",
    	"chacal",
    	"chaleco",
    	"champú",
    	"chancla",
    	"chapa",
    	"charla",
    	"chico",
    	"chiste",
    	"chivo",
    	"choque",
    	"choza",
    	"chuleta",
    	"chupar",
    	"ciclón",
    	"ciego",
    	"cielo",
    	"cien",
    	"cierto",
    	"cifra",
    	"cigarro",
    	"cima",
    	"cinco",
    	"cine",
    	"cinta",
    	"ciprés",
    	"circo",
    	"ciruela",
    	"cisne",
    	"cita",
    	"ciudad",
    	"clamor",
    	"clan",
    	"claro",
    	"clase",
    	"clave",
    	"cliente",
    	"clima",
    	"clínica",
    	"cobre",
    	"cocción",
    	"cochino",
    	"cocina",
    	"coco",
    	"código",
    	"codo",
    	"cofre",
    	"coger",
    	"cohete",
    	"cojín",
    	"cojo",
    	"cola",
    	"colcha",
    	"colegio",
    	"colgar",
    	"colina",
    	"collar",
    	"colmo",
    	"columna",
    	"combate",
    	"comer",
    	"comida",
    	"cómodo",
    	"compra",
    	"conde",
    	"conejo",
    	"conga",
    	"conocer",
    	"consejo",
    	"contar",
    	"copa",
    	"copia",
    	"corazón",
    	"corbata",
    	"corcho",
    	"cordón",
    	"corona",
    	"correr",
    	"coser",
    	"cosmos",
    	"costa",
    	"cráneo",
    	"cráter",
    	"crear",
    	"crecer",
    	"creído",
    	"crema",
    	"cría",
    	"crimen",
    	"cripta",
    	"crisis",
    	"cromo",
    	"crónica",
    	"croqueta",
    	"crudo",
    	"cruz",
    	"cuadro",
    	"cuarto",
    	"cuatro",
    	"cubo",
    	"cubrir",
    	"cuchara",
    	"cuello",
    	"cuento",
    	"cuerda",
    	"cuesta",
    	"cueva",
    	"cuidar",
    	"culebra",
    	"culpa",
    	"culto",
    	"cumbre",
    	"cumplir",
    	"cuna",
    	"cuneta",
    	"cuota",
    	"cupón",
    	"cúpula",
    	"curar",
    	"curioso",
    	"curso",
    	"curva",
    	"cutis",
    	"dama",
    	"danza",
    	"dar",
    	"dardo",
    	"dátil",
    	"deber",
    	"débil",
    	"década",
    	"decir",
    	"dedo",
    	"defensa",
    	"definir",
    	"dejar",
    	"delfín",
    	"delgado",
    	"delito",
    	"demora",
    	"denso",
    	"dental",
    	"deporte",
    	"derecho",
    	"derrota",
    	"desayuno",
    	"deseo",
    	"desfile",
    	"desnudo",
    	"destino",
    	"desvío",
    	"detalle",
    	"detener",
    	"deuda",
    	"día",
    	"diablo",
    	"diadema",
    	"diamante",
    	"diana",
    	"diario",
    	"dibujo",
    	"dictar",
    	"diente",
    	"dieta",
    	"diez",
    	"difícil",
    	"digno",
    	"dilema",
    	"diluir",
    	"dinero",
    	"directo",
    	"dirigir",
    	"disco",
    	"diseño",
    	"disfraz",
    	"diva",
    	"divino",
    	"doble",
    	"doce",
    	"dolor",
    	"domingo",
    	"don",
    	"donar",
    	"dorado",
    	"dormir",
    	"dorso",
    	"dos",
    	"dosis",
    	"dragón",
    	"droga",
    	"ducha",
    	"duda",
    	"duelo",
    	"dueño",
    	"dulce",
    	"dúo",
    	"duque",
    	"durar",
    	"dureza",
    	"duro",
    	"ébano",
    	"ebrio",
    	"echar",
    	"eco",
    	"ecuador",
    	"edad",
    	"edición",
    	"edificio",
    	"editor",
    	"educar",
    	"efecto",
    	"eficaz",
    	"eje",
    	"ejemplo",
    	"elefante",
    	"elegir",
    	"elemento",
    	"elevar",
    	"elipse",
    	"élite",
    	"elixir",
    	"elogio",
    	"eludir",
    	"embudo",
    	"emitir",
    	"emoción",
    	"empate",
    	"empeño",
    	"empleo",
    	"empresa",
    	"enano",
    	"encargo",
    	"enchufe",
    	"encía",
    	"enemigo",
    	"enero",
    	"enfado",
    	"enfermo",
    	"engaño",
    	"enigma",
    	"enlace",
    	"enorme",
    	"enredo",
    	"ensayo",
    	"enseñar",
    	"entero",
    	"entrar",
    	"envase",
    	"envío",
    	"época",
    	"equipo",
    	"erizo",
    	"escala",
    	"escena",
    	"escolar",
    	"escribir",
    	"escudo",
    	"esencia",
    	"esfera",
    	"esfuerzo",
    	"espada",
    	"espejo",
    	"espía",
    	"esposa",
    	"espuma",
    	"esquí",
    	"estar",
    	"este",
    	"estilo",
    	"estufa",
    	"etapa",
    	"eterno",
    	"ética",
    	"etnia",
    	"evadir",
    	"evaluar",
    	"evento",
    	"evitar",
    	"exacto",
    	"examen",
    	"exceso",
    	"excusa",
    	"exento",
    	"exigir",
    	"exilio",
    	"existir",
    	"éxito",
    	"experto",
    	"explicar",
    	"exponer",
    	"extremo",
    	"fábrica",
    	"fábula",
    	"fachada",
    	"fácil",
    	"factor",
    	"faena",
    	"faja",
    	"falda",
    	"fallo",
    	"falso",
    	"faltar",
    	"fama",
    	"familia",
    	"famoso",
    	"faraón",
    	"farmacia",
    	"farol",
    	"farsa",
    	"fase",
    	"fatiga",
    	"fauna",
    	"favor",
    	"fax",
    	"febrero",
    	"fecha",
    	"feliz",
    	"feo",
    	"feria",
    	"feroz",
    	"fértil",
    	"fervor",
    	"festín",
    	"fiable",
    	"fianza",
    	"fiar",
    	"fibra",
    	"ficción",
    	"ficha",
    	"fideo",
    	"fiebre",
    	"fiel",
    	"fiera",
    	"fiesta",
    	"figura",
    	"fijar",
    	"fijo",
    	"fila",
    	"filete",
    	"filial",
    	"filtro",
    	"fin",
    	"finca",
    	"fingir",
    	"finito",
    	"firma",
    	"flaco",
    	"flauta",
    	"flecha",
    	"flor",
    	"flota",
    	"fluir",
    	"flujo",
    	"flúor",
    	"fobia",
    	"foca",
    	"fogata",
    	"fogón",
    	"folio",
    	"folleto",
    	"fondo",
    	"forma",
    	"forro",
    	"fortuna",
    	"forzar",
    	"fosa",
    	"foto",
    	"fracaso",
    	"frágil",
    	"franja",
    	"frase",
    	"fraude",
    	"freír",
    	"freno",
    	"fresa",
    	"frío",
    	"frito",
    	"fruta",
    	"fuego",
    	"fuente",
    	"fuerza",
    	"fuga",
    	"fumar",
    	"función",
    	"funda",
    	"furgón",
    	"furia",
    	"fusil",
    	"fútbol",
    	"futuro",
    	"gacela",
    	"gafas",
    	"gaita",
    	"gajo",
    	"gala",
    	"galería",
    	"gallo",
    	"gamba",
    	"ganar",
    	"gancho",
    	"ganga",
    	"ganso",
    	"garaje",
    	"garza",
    	"gasolina",
    	"gastar",
    	"gato",
    	"gavilán",
    	"gemelo",
    	"gemir",
    	"gen",
    	"género",
    	"genio",
    	"gente",
    	"geranio",
    	"gerente",
    	"germen",
    	"gesto",
    	"gigante",
    	"gimnasio",
    	"girar",
    	"giro",
    	"glaciar",
    	"globo",
    	"gloria",
    	"gol",
    	"golfo",
    	"goloso",
    	"golpe",
    	"goma",
    	"gordo",
    	"gorila",
    	"gorra",
    	"gota",
    	"goteo",
    	"gozar",
    	"grada",
    	"gráfico",
    	"grano",
    	"grasa",
    	"gratis",
    	"grave",
    	"grieta",
    	"grillo",
    	"gripe",
    	"gris",
    	"grito",
    	"grosor",
    	"grúa",
    	"grueso",
    	"grumo",
    	"grupo",
    	"guante",
    	"guapo",
    	"guardia",
    	"guerra",
    	"guía",
    	"guiño",
    	"guion",
    	"guiso",
    	"guitarra",
    	"gusano",
    	"gustar",
    	"haber",
    	"hábil",
    	"hablar",
    	"hacer",
    	"hacha",
    	"hada",
    	"hallar",
    	"hamaca",
    	"harina",
    	"haz",
    	"hazaña",
    	"hebilla",
    	"hebra",
    	"hecho",
    	"helado",
    	"helio",
    	"hembra",
    	"herir",
    	"hermano",
    	"héroe",
    	"hervir",
    	"hielo",
    	"hierro",
    	"hígado",
    	"higiene",
    	"hijo",
    	"himno",
    	"historia",
    	"hocico",
    	"hogar",
    	"hoguera",
    	"hoja",
    	"hombre",
    	"hongo",
    	"honor",
    	"honra",
    	"hora",
    	"hormiga",
    	"horno",
    	"hostil",
    	"hoyo",
    	"hueco",
    	"huelga",
    	"huerta",
    	"hueso",
    	"huevo",
    	"huida",
    	"huir",
    	"humano",
    	"húmedo",
    	"humilde",
    	"humo",
    	"hundir",
    	"huracán",
    	"hurto",
    	"icono",
    	"ideal",
    	"idioma",
    	"ídolo",
    	"iglesia",
    	"iglú",
    	"igual",
    	"ilegal",
    	"ilusión",
    	"imagen",
    	"imán",
    	"imitar",
    	"impar",
    	"imperio",
    	"imponer",
    	"impulso",
    	"incapaz",
    	"índice",
    	"inerte",
    	"infiel",
    	"informe",
    	"ingenio",
    	"inicio",
    	"inmenso",
    	"inmune",
    	"innato",
    	"insecto",
    	"instante",
    	"interés",
    	"íntimo",
    	"intuir",
    	"inútil",
    	"invierno",
    	"ira",
    	"iris",
    	"ironía",
    	"isla",
    	"islote",
    	"jabalí",
    	"jabón",
    	"jamón",
    	"jarabe",
    	"jardín",
    	"jarra",
    	"jaula",
    	"jazmín",
    	"jefe",
    	"jeringa",
    	"jinete",
    	"jornada",
    	"joroba",
    	"joven",
    	"joya",
    	"juerga",
    	"jueves",
    	"juez",
    	"jugador",
    	"jugo",
    	"juguete",
    	"juicio",
    	"junco",
    	"jungla",
    	"junio",
    	"juntar",
    	"júpiter",
    	"jurar",
    	"justo",
    	"juvenil",
    	"juzgar",
    	"kilo",
    	"koala",
    	"labio",
    	"lacio",
    	"lacra",
    	"lado",
    	"ladrón",
    	"lagarto",
    	"lágrima",
    	"laguna",
    	"laico",
    	"lamer",
    	"lámina",
    	"lámpara",
    	"lana",
    	"lancha",
    	"langosta",
    	"lanza",
    	"lápiz",
    	"largo",
    	"larva",
    	"lástima",
    	"lata",
    	"látex",
    	"latir",
    	"laurel",
    	"lavar",
    	"lazo",
    	"leal",
    	"lección",
    	"leche",
    	"lector",
    	"leer",
    	"legión",
    	"legumbre",
    	"lejano",
    	"lengua",
    	"lento",
    	"leña",
    	"león",
    	"leopardo",
    	"lesión",
    	"letal",
    	"letra",
    	"leve",
    	"leyenda",
    	"libertad",
    	"libro",
    	"licor",
    	"líder",
    	"lidiar",
    	"lienzo",
    	"liga",
    	"ligero",
    	"lima",
    	"límite",
    	"limón",
    	"limpio",
    	"lince",
    	"lindo",
    	"línea",
    	"lingote",
    	"lino",
    	"linterna",
    	"líquido",
    	"liso",
    	"lista",
    	"litera",
    	"litio",
    	"litro",
    	"llaga",
    	"llama",
    	"llanto",
    	"llave",
    	"llegar",
    	"llenar",
    	"llevar",
    	"llorar",
    	"llover",
    	"lluvia",
    	"lobo",
    	"loción",
    	"loco",
    	"locura",
    	"lógica",
    	"logro",
    	"lombriz",
    	"lomo",
    	"lonja",
    	"lote",
    	"lucha",
    	"lucir",
    	"lugar",
    	"lujo",
    	"luna",
    	"lunes",
    	"lupa",
    	"lustro",
    	"luto",
    	"luz",
    	"maceta",
    	"macho",
    	"madera",
    	"madre",
    	"maduro",
    	"maestro",
    	"mafia",
    	"magia",
    	"mago",
    	"maíz",
    	"maldad",
    	"maleta",
    	"malla",
    	"malo",
    	"mamá",
    	"mambo",
    	"mamut",
    	"manco",
    	"mando",
    	"manejar",
    	"manga",
    	"maniquí",
    	"manjar",
    	"mano",
    	"manso",
    	"manta",
    	"mañana",
    	"mapa",
    	"máquina",
    	"mar",
    	"marco",
    	"marea",
    	"marfil",
    	"margen",
    	"marido",
    	"mármol",
    	"marrón",
    	"martes",
    	"marzo",
    	"masa",
    	"máscara",
    	"masivo",
    	"matar",
    	"materia",
    	"matiz",
    	"matriz",
    	"máximo",
    	"mayor",
    	"mazorca",
    	"mecha",
    	"medalla",
    	"medio",
    	"médula",
    	"mejilla",
    	"mejor",
    	"melena",
    	"melón",
    	"memoria",
    	"menor",
    	"mensaje",
    	"mente",
    	"menú",
    	"mercado",
    	"merengue",
    	"mérito",
    	"mes",
    	"mesón",
    	"meta",
    	"meter",
    	"método",
    	"metro",
    	"mezcla",
    	"miedo",
    	"miel",
    	"miembro",
    	"miga",
    	"mil",
    	"milagro",
    	"militar",
    	"millón",
    	"mimo",
    	"mina",
    	"minero",
    	"mínimo",
    	"minuto",
    	"miope",
    	"mirar",
    	"misa",
    	"miseria",
    	"misil",
    	"mismo",
    	"mitad",
    	"mito",
    	"mochila",
    	"moción",
    	"moda",
    	"modelo",
    	"moho",
    	"mojar",
    	"molde",
    	"moler",
    	"molino",
    	"momento",
    	"momia",
    	"monarca",
    	"moneda",
    	"monja",
    	"monto",
    	"moño",
    	"morada",
    	"morder",
    	"moreno",
    	"morir",
    	"morro",
    	"morsa",
    	"mortal",
    	"mosca",
    	"mostrar",
    	"motivo",
    	"mover",
    	"móvil",
    	"mozo",
    	"mucho",
    	"mudar",
    	"mueble",
    	"muela",
    	"muerte",
    	"muestra",
    	"mugre",
    	"mujer",
    	"mula",
    	"muleta",
    	"multa",
    	"mundo",
    	"muñeca",
    	"mural",
    	"muro",
    	"músculo",
    	"museo",
    	"musgo",
    	"música",
    	"muslo",
    	"nácar",
    	"nación",
    	"nadar",
    	"naipe",
    	"naranja",
    	"nariz",
    	"narrar",
    	"nasal",
    	"natal",
    	"nativo",
    	"natural",
    	"náusea",
    	"naval",
    	"nave",
    	"navidad",
    	"necio",
    	"néctar",
    	"negar",
    	"negocio",
    	"negro",
    	"neón",
    	"nervio",
    	"neto",
    	"neutro",
    	"nevar",
    	"nevera",
    	"nicho",
    	"nido",
    	"niebla",
    	"nieto",
    	"niñez",
    	"niño",
    	"nítido",
    	"nivel",
    	"nobleza",
    	"noche",
    	"nómina",
    	"noria",
    	"norma",
    	"norte",
    	"nota",
    	"noticia",
    	"novato",
    	"novela",
    	"novio",
    	"nube",
    	"nuca",
    	"núcleo",
    	"nudillo",
    	"nudo",
    	"nuera",
    	"nueve",
    	"nuez",
    	"nulo",
    	"número",
    	"nutria",
    	"oasis",
    	"obeso",
    	"obispo",
    	"objeto",
    	"obra",
    	"obrero",
    	"observar",
    	"obtener",
    	"obvio",
    	"oca",
    	"ocaso",
    	"océano",
    	"ochenta",
    	"ocho",
    	"ocio",
    	"ocre",
    	"octavo",
    	"octubre",
    	"oculto",
    	"ocupar",
    	"ocurrir",
    	"odiar",
    	"odio",
    	"odisea",
    	"oeste",
    	"ofensa",
    	"oferta",
    	"oficio",
    	"ofrecer",
    	"ogro",
    	"oído",
    	"oír",
    	"ojo",
    	"ola",
    	"oleada",
    	"olfato",
    	"olivo",
    	"olla",
    	"olmo",
    	"olor",
    	"olvido",
    	"ombligo",
    	"onda",
    	"onza",
    	"opaco",
    	"opción",
    	"ópera",
    	"opinar",
    	"oponer",
    	"optar",
    	"óptica",
    	"opuesto",
    	"oración",
    	"orador",
    	"oral",
    	"órbita",
    	"orca",
    	"orden",
    	"oreja",
    	"órgano",
    	"orgía",
    	"orgullo",
    	"oriente",
    	"origen",
    	"orilla",
    	"oro",
    	"orquesta",
    	"oruga",
    	"osadía",
    	"oscuro",
    	"osezno",
    	"oso",
    	"ostra",
    	"otoño",
    	"otro",
    	"oveja",
    	"óvulo",
    	"óxido",
    	"oxígeno",
    	"oyente",
    	"ozono",
    	"pacto",
    	"padre",
    	"paella",
    	"página",
    	"pago",
    	"país",
    	"pájaro",
    	"palabra",
    	"palco",
    	"paleta",
    	"pálido",
    	"palma",
    	"paloma",
    	"palpar",
    	"pan",
    	"panal",
    	"pánico",
    	"pantera",
    	"pañuelo",
    	"papá",
    	"papel",
    	"papilla",
    	"paquete",
    	"parar",
    	"parcela",
    	"pared",
    	"parir",
    	"paro",
    	"párpado",
    	"parque",
    	"párrafo",
    	"parte",
    	"pasar",
    	"paseo",
    	"pasión",
    	"paso",
    	"pasta",
    	"pata",
    	"patio",
    	"patria",
    	"pausa",
    	"pauta",
    	"pavo",
    	"payaso",
    	"peatón",
    	"pecado",
    	"pecera",
    	"pecho",
    	"pedal",
    	"pedir",
    	"pegar",
    	"peine",
    	"pelar",
    	"peldaño",
    	"pelea",
    	"peligro",
    	"pellejo",
    	"pelo",
    	"peluca",
    	"pena",
    	"pensar",
    	"peñón",
    	"peón",
    	"peor",
    	"pepino",
    	"pequeño",
    	"pera",
    	"percha",
    	"perder",
    	"pereza",
    	"perfil",
    	"perico",
    	"perla",
    	"permiso",
    	"perro",
    	"persona",
    	"pesa",
    	"pesca",
    	"pésimo",
    	"pestaña",
    	"pétalo",
    	"petróleo",
    	"pez",
    	"pezuña",
    	"picar",
    	"pichón",
    	"pie",
    	"piedra",
    	"pierna",
    	"pieza",
    	"pijama",
    	"pilar",
    	"piloto",
    	"pimienta",
    	"pino",
    	"pintor",
    	"pinza",
    	"piña",
    	"piojo",
    	"pipa",
    	"pirata",
    	"pisar",
    	"piscina",
    	"piso",
    	"pista",
    	"pitón",
    	"pizca",
    	"placa",
    	"plan",
    	"plata",
    	"playa",
    	"plaza",
    	"pleito",
    	"pleno",
    	"plomo",
    	"pluma",
    	"plural",
    	"pobre",
    	"poco",
    	"poder",
    	"podio",
    	"poema",
    	"poesía",
    	"poeta",
    	"polen",
    	"policía",
    	"pollo",
    	"polvo",
    	"pomada",
    	"pomelo",
    	"pomo",
    	"pompa",
    	"poner",
    	"porción",
    	"portal",
    	"posada",
    	"poseer",
    	"posible",
    	"poste",
    	"potencia",
    	"potro",
    	"pozo",
    	"prado",
    	"precoz",
    	"pregunta",
    	"premio",
    	"prensa",
    	"preso",
    	"previo",
    	"primo",
    	"príncipe",
    	"prisión",
    	"privar",
    	"proa",
    	"probar",
    	"proceso",
    	"producto",
    	"proeza",
    	"profesor",
    	"programa",
    	"prole",
    	"promesa",
    	"pronto",
    	"propio",
    	"próximo",
    	"prueba",
    	"público",
    	"puchero",
    	"pudor",
    	"pueblo",
    	"puerta",
    	"puesto",
    	"pulga",
    	"pulir",
    	"pulmón",
    	"pulpo",
    	"pulso",
    	"puma",
    	"punto",
    	"puñal",
    	"puño",
    	"pupa",
    	"pupila",
    	"puré",
    	"quedar",
    	"queja",
    	"quemar",
    	"querer",
    	"queso",
    	"quieto",
    	"química",
    	"quince",
    	"quitar",
    	"rábano",
    	"rabia",
    	"rabo",
    	"ración",
    	"radical",
    	"raíz",
    	"rama",
    	"rampa",
    	"rancho",
    	"rango",
    	"rapaz",
    	"rápido",
    	"rapto",
    	"rasgo",
    	"raspa",
    	"rato",
    	"rayo",
    	"raza",
    	"razón",
    	"reacción",
    	"realidad",
    	"rebaño",
    	"rebote",
    	"recaer",
    	"receta",
    	"rechazo",
    	"recoger",
    	"recreo",
    	"recto",
    	"recurso",
    	"red",
    	"redondo",
    	"reducir",
    	"reflejo",
    	"reforma",
    	"refrán",
    	"refugio",
    	"regalo",
    	"regir",
    	"regla",
    	"regreso",
    	"rehén",
    	"reino",
    	"reír",
    	"reja",
    	"relato",
    	"relevo",
    	"relieve",
    	"relleno",
    	"reloj",
    	"remar",
    	"remedio",
    	"remo",
    	"rencor",
    	"rendir",
    	"renta",
    	"reparto",
    	"repetir",
    	"reposo",
    	"reptil",
    	"res",
    	"rescate",
    	"resina",
    	"respeto",
    	"resto",
    	"resumen",
    	"retiro",
    	"retorno",
    	"retrato",
    	"reunir",
    	"revés",
    	"revista",
    	"rey",
    	"rezar",
    	"rico",
    	"riego",
    	"rienda",
    	"riesgo",
    	"rifa",
    	"rígido",
    	"rigor",
    	"rincón",
    	"riñón",
    	"río",
    	"riqueza",
    	"risa",
    	"ritmo",
    	"rito",
    	"rizo",
    	"roble",
    	"roce",
    	"rociar",
    	"rodar",
    	"rodeo",
    	"rodilla",
    	"roer",
    	"rojizo",
    	"rojo",
    	"romero",
    	"romper",
    	"ron",
    	"ronco",
    	"ronda",
    	"ropa",
    	"ropero",
    	"rosa",
    	"rosca",
    	"rostro",
    	"rotar",
    	"rubí",
    	"rubor",
    	"rudo",
    	"rueda",
    	"rugir",
    	"ruido",
    	"ruina",
    	"ruleta",
    	"rulo",
    	"rumbo",
    	"rumor",
    	"ruptura",
    	"ruta",
    	"rutina",
    	"sábado",
    	"saber",
    	"sabio",
    	"sable",
    	"sacar",
    	"sagaz",
    	"sagrado",
    	"sala",
    	"saldo",
    	"salero",
    	"salir",
    	"salmón",
    	"salón",
    	"salsa",
    	"salto",
    	"salud",
    	"salvar",
    	"samba",
    	"sanción",
    	"sandía",
    	"sanear",
    	"sangre",
    	"sanidad",
    	"sano",
    	"santo",
    	"sapo",
    	"saque",
    	"sardina",
    	"sartén",
    	"sastre",
    	"satán",
    	"sauna",
    	"saxofón",
    	"sección",
    	"seco",
    	"secreto",
    	"secta",
    	"sed",
    	"seguir",
    	"seis",
    	"sello",
    	"selva",
    	"semana",
    	"semilla",
    	"senda",
    	"sensor",
    	"señal",
    	"señor",
    	"separar",
    	"sepia",
    	"sequía",
    	"ser",
    	"serie",
    	"sermón",
    	"servir",
    	"sesenta",
    	"sesión",
    	"seta",
    	"setenta",
    	"severo",
    	"sexo",
    	"sexto",
    	"sidra",
    	"siesta",
    	"siete",
    	"siglo",
    	"signo",
    	"sílaba",
    	"silbar",
    	"silencio",
    	"silla",
    	"símbolo",
    	"simio",
    	"sirena",
    	"sistema",
    	"sitio",
    	"situar",
    	"sobre",
    	"socio",
    	"sodio",
    	"sol",
    	"solapa",
    	"soldado",
    	"soledad",
    	"sólido",
    	"soltar",
    	"solución",
    	"sombra",
    	"sondeo",
    	"sonido",
    	"sonoro",
    	"sonrisa",
    	"sopa",
    	"soplar",
    	"soporte",
    	"sordo",
    	"sorpresa",
    	"sorteo",
    	"sostén",
    	"sótano",
    	"suave",
    	"subir",
    	"suceso",
    	"sudor",
    	"suegra",
    	"suelo",
    	"sueño",
    	"suerte",
    	"sufrir",
    	"sujeto",
    	"sultán",
    	"sumar",
    	"superar",
    	"suplir",
    	"suponer",
    	"supremo",
    	"sur",
    	"surco",
    	"sureño",
    	"surgir",
    	"susto",
    	"sutil",
    	"tabaco",
    	"tabique",
    	"tabla",
    	"tabú",
    	"taco",
    	"tacto",
    	"tajo",
    	"talar",
    	"talco",
    	"talento",
    	"talla",
    	"talón",
    	"tamaño",
    	"tambor",
    	"tango",
    	"tanque",
    	"tapa",
    	"tapete",
    	"tapia",
    	"tapón",
    	"taquilla",
    	"tarde",
    	"tarea",
    	"tarifa",
    	"tarjeta",
    	"tarot",
    	"tarro",
    	"tarta",
    	"tatuaje",
    	"tauro",
    	"taza",
    	"tazón",
    	"teatro",
    	"techo",
    	"tecla",
    	"técnica",
    	"tejado",
    	"tejer",
    	"tejido",
    	"tela",
    	"teléfono",
    	"tema",
    	"temor",
    	"templo",
    	"tenaz",
    	"tender",
    	"tener",
    	"tenis",
    	"tenso",
    	"teoría",
    	"terapia",
    	"terco",
    	"término",
    	"ternura",
    	"terror",
    	"tesis",
    	"tesoro",
    	"testigo",
    	"tetera",
    	"texto",
    	"tez",
    	"tibio",
    	"tiburón",
    	"tiempo",
    	"tienda",
    	"tierra",
    	"tieso",
    	"tigre",
    	"tijera",
    	"tilde",
    	"timbre",
    	"tímido",
    	"timo",
    	"tinta",
    	"tío",
    	"típico",
    	"tipo",
    	"tira",
    	"tirón",
    	"titán",
    	"títere",
    	"título",
    	"tiza",
    	"toalla",
    	"tobillo",
    	"tocar",
    	"tocino",
    	"todo",
    	"toga",
    	"toldo",
    	"tomar",
    	"tono",
    	"tonto",
    	"topar",
    	"tope",
    	"toque",
    	"tórax",
    	"torero",
    	"tormenta",
    	"torneo",
    	"toro",
    	"torpedo",
    	"torre",
    	"torso",
    	"tortuga",
    	"tos",
    	"tosco",
    	"toser",
    	"tóxico",
    	"trabajo",
    	"tractor",
    	"traer",
    	"tráfico",
    	"trago",
    	"traje",
    	"tramo",
    	"trance",
    	"trato",
    	"trauma",
    	"trazar",
    	"trébol",
    	"tregua",
    	"treinta",
    	"tren",
    	"trepar",
    	"tres",
    	"tribu",
    	"trigo",
    	"tripa",
    	"triste",
    	"triunfo",
    	"trofeo",
    	"trompa",
    	"tronco",
    	"tropa",
    	"trote",
    	"trozo",
    	"truco",
    	"trueno",
    	"trufa",
    	"tubería",
    	"tubo",
    	"tuerto",
    	"tumba",
    	"tumor",
    	"túnel",
    	"túnica",
    	"turbina",
    	"turismo",
    	"turno",
    	"tutor",
    	"ubicar",
    	"úlcera",
    	"umbral",
    	"unidad",
    	"unir",
    	"universo",
    	"uno",
    	"untar",
    	"uña",
    	"urbano",
    	"urbe",
    	"urgente",
    	"urna",
    	"usar",
    	"usuario",
    	"útil",
    	"utopía",
    	"uva",
    	"vaca",
    	"vacío",
    	"vacuna",
    	"vagar",
    	"vago",
    	"vaina",
    	"vajilla",
    	"vale",
    	"válido",
    	"valle",
    	"valor",
    	"válvula",
    	"vampiro",
    	"vara",
    	"variar",
    	"varón",
    	"vaso",
    	"vecino",
    	"vector",
    	"vehículo",
    	"veinte",
    	"vejez",
    	"vela",
    	"velero",
    	"veloz",
    	"vena",
    	"vencer",
    	"venda",
    	"veneno",
    	"vengar",
    	"venir",
    	"venta",
    	"venus",
    	"ver",
    	"verano",
    	"verbo",
    	"verde",
    	"vereda",
    	"verja",
    	"verso",
    	"verter",
    	"vía",
    	"viaje",
    	"vibrar",
    	"vicio",
    	"víctima",
    	"vida",
    	"vídeo",
    	"vidrio",
    	"viejo",
    	"viernes",
    	"vigor",
    	"vil",
    	"villa",
    	"vinagre",
    	"vino",
    	"viñedo",
    	"violín",
    	"viral",
    	"virgo",
    	"virtud",
    	"visor",
    	"víspera",
    	"vista",
    	"vitamina",
    	"viudo",
    	"vivaz",
    	"vivero",
    	"vivir",
    	"vivo",
    	"volcán",
    	"volumen",
    	"volver",
    	"voraz",
    	"votar",
    	"voto",
    	"voz",
    	"vuelo",
    	"vulgar",
    	"yacer",
    	"yate",
    	"yegua",
    	"yema",
    	"yerno",
    	"yeso",
    	"yodo",
    	"yoga",
    	"yogur",
    	"zafiro",
    	"zanja",
    	"zapato",
    	"zarza",
    	"zona",
    	"zorro",
    	"zumo",
    	"zurdo"
    ];

    var require$$7 = [
    	"あいこくしん",
    	"あいさつ",
    	"あいだ",
    	"あおぞら",
    	"あかちゃん",
    	"あきる",
    	"あけがた",
    	"あける",
    	"あこがれる",
    	"あさい",
    	"あさひ",
    	"あしあと",
    	"あじわう",
    	"あずかる",
    	"あずき",
    	"あそぶ",
    	"あたえる",
    	"あたためる",
    	"あたりまえ",
    	"あたる",
    	"あつい",
    	"あつかう",
    	"あっしゅく",
    	"あつまり",
    	"あつめる",
    	"あてな",
    	"あてはまる",
    	"あひる",
    	"あぶら",
    	"あぶる",
    	"あふれる",
    	"あまい",
    	"あまど",
    	"あまやかす",
    	"あまり",
    	"あみもの",
    	"あめりか",
    	"あやまる",
    	"あゆむ",
    	"あらいぐま",
    	"あらし",
    	"あらすじ",
    	"あらためる",
    	"あらゆる",
    	"あらわす",
    	"ありがとう",
    	"あわせる",
    	"あわてる",
    	"あんい",
    	"あんがい",
    	"あんこ",
    	"あんぜん",
    	"あんてい",
    	"あんない",
    	"あんまり",
    	"いいだす",
    	"いおん",
    	"いがい",
    	"いがく",
    	"いきおい",
    	"いきなり",
    	"いきもの",
    	"いきる",
    	"いくじ",
    	"いくぶん",
    	"いけばな",
    	"いけん",
    	"いこう",
    	"いこく",
    	"いこつ",
    	"いさましい",
    	"いさん",
    	"いしき",
    	"いじゅう",
    	"いじょう",
    	"いじわる",
    	"いずみ",
    	"いずれ",
    	"いせい",
    	"いせえび",
    	"いせかい",
    	"いせき",
    	"いぜん",
    	"いそうろう",
    	"いそがしい",
    	"いだい",
    	"いだく",
    	"いたずら",
    	"いたみ",
    	"いたりあ",
    	"いちおう",
    	"いちじ",
    	"いちど",
    	"いちば",
    	"いちぶ",
    	"いちりゅう",
    	"いつか",
    	"いっしゅん",
    	"いっせい",
    	"いっそう",
    	"いったん",
    	"いっち",
    	"いってい",
    	"いっぽう",
    	"いてざ",
    	"いてん",
    	"いどう",
    	"いとこ",
    	"いない",
    	"いなか",
    	"いねむり",
    	"いのち",
    	"いのる",
    	"いはつ",
    	"いばる",
    	"いはん",
    	"いびき",
    	"いひん",
    	"いふく",
    	"いへん",
    	"いほう",
    	"いみん",
    	"いもうと",
    	"いもたれ",
    	"いもり",
    	"いやがる",
    	"いやす",
    	"いよかん",
    	"いよく",
    	"いらい",
    	"いらすと",
    	"いりぐち",
    	"いりょう",
    	"いれい",
    	"いれもの",
    	"いれる",
    	"いろえんぴつ",
    	"いわい",
    	"いわう",
    	"いわかん",
    	"いわば",
    	"いわゆる",
    	"いんげんまめ",
    	"いんさつ",
    	"いんしょう",
    	"いんよう",
    	"うえき",
    	"うえる",
    	"うおざ",
    	"うがい",
    	"うかぶ",
    	"うかべる",
    	"うきわ",
    	"うくらいな",
    	"うくれれ",
    	"うけたまわる",
    	"うけつけ",
    	"うけとる",
    	"うけもつ",
    	"うける",
    	"うごかす",
    	"うごく",
    	"うこん",
    	"うさぎ",
    	"うしなう",
    	"うしろがみ",
    	"うすい",
    	"うすぎ",
    	"うすぐらい",
    	"うすめる",
    	"うせつ",
    	"うちあわせ",
    	"うちがわ",
    	"うちき",
    	"うちゅう",
    	"うっかり",
    	"うつくしい",
    	"うったえる",
    	"うつる",
    	"うどん",
    	"うなぎ",
    	"うなじ",
    	"うなずく",
    	"うなる",
    	"うねる",
    	"うのう",
    	"うぶげ",
    	"うぶごえ",
    	"うまれる",
    	"うめる",
    	"うもう",
    	"うやまう",
    	"うよく",
    	"うらがえす",
    	"うらぐち",
    	"うらない",
    	"うりあげ",
    	"うりきれ",
    	"うるさい",
    	"うれしい",
    	"うれゆき",
    	"うれる",
    	"うろこ",
    	"うわき",
    	"うわさ",
    	"うんこう",
    	"うんちん",
    	"うんてん",
    	"うんどう",
    	"えいえん",
    	"えいが",
    	"えいきょう",
    	"えいご",
    	"えいせい",
    	"えいぶん",
    	"えいよう",
    	"えいわ",
    	"えおり",
    	"えがお",
    	"えがく",
    	"えきたい",
    	"えくせる",
    	"えしゃく",
    	"えすて",
    	"えつらん",
    	"えのぐ",
    	"えほうまき",
    	"えほん",
    	"えまき",
    	"えもじ",
    	"えもの",
    	"えらい",
    	"えらぶ",
    	"えりあ",
    	"えんえん",
    	"えんかい",
    	"えんぎ",
    	"えんげき",
    	"えんしゅう",
    	"えんぜつ",
    	"えんそく",
    	"えんちょう",
    	"えんとつ",
    	"おいかける",
    	"おいこす",
    	"おいしい",
    	"おいつく",
    	"おうえん",
    	"おうさま",
    	"おうじ",
    	"おうせつ",
    	"おうたい",
    	"おうふく",
    	"おうべい",
    	"おうよう",
    	"おえる",
    	"おおい",
    	"おおう",
    	"おおどおり",
    	"おおや",
    	"おおよそ",
    	"おかえり",
    	"おかず",
    	"おがむ",
    	"おかわり",
    	"おぎなう",
    	"おきる",
    	"おくさま",
    	"おくじょう",
    	"おくりがな",
    	"おくる",
    	"おくれる",
    	"おこす",
    	"おこなう",
    	"おこる",
    	"おさえる",
    	"おさない",
    	"おさめる",
    	"おしいれ",
    	"おしえる",
    	"おじぎ",
    	"おじさん",
    	"おしゃれ",
    	"おそらく",
    	"おそわる",
    	"おたがい",
    	"おたく",
    	"おだやか",
    	"おちつく",
    	"おっと",
    	"おつり",
    	"おでかけ",
    	"おとしもの",
    	"おとなしい",
    	"おどり",
    	"おどろかす",
    	"おばさん",
    	"おまいり",
    	"おめでとう",
    	"おもいで",
    	"おもう",
    	"おもたい",
    	"おもちゃ",
    	"おやつ",
    	"おやゆび",
    	"およぼす",
    	"おらんだ",
    	"おろす",
    	"おんがく",
    	"おんけい",
    	"おんしゃ",
    	"おんせん",
    	"おんだん",
    	"おんちゅう",
    	"おんどけい",
    	"かあつ",
    	"かいが",
    	"がいき",
    	"がいけん",
    	"がいこう",
    	"かいさつ",
    	"かいしゃ",
    	"かいすいよく",
    	"かいぜん",
    	"かいぞうど",
    	"かいつう",
    	"かいてん",
    	"かいとう",
    	"かいふく",
    	"がいへき",
    	"かいほう",
    	"かいよう",
    	"がいらい",
    	"かいわ",
    	"かえる",
    	"かおり",
    	"かかえる",
    	"かがく",
    	"かがし",
    	"かがみ",
    	"かくご",
    	"かくとく",
    	"かざる",
    	"がぞう",
    	"かたい",
    	"かたち",
    	"がちょう",
    	"がっきゅう",
    	"がっこう",
    	"がっさん",
    	"がっしょう",
    	"かなざわし",
    	"かのう",
    	"がはく",
    	"かぶか",
    	"かほう",
    	"かほご",
    	"かまう",
    	"かまぼこ",
    	"かめれおん",
    	"かゆい",
    	"かようび",
    	"からい",
    	"かるい",
    	"かろう",
    	"かわく",
    	"かわら",
    	"がんか",
    	"かんけい",
    	"かんこう",
    	"かんしゃ",
    	"かんそう",
    	"かんたん",
    	"かんち",
    	"がんばる",
    	"きあい",
    	"きあつ",
    	"きいろ",
    	"ぎいん",
    	"きうい",
    	"きうん",
    	"きえる",
    	"きおう",
    	"きおく",
    	"きおち",
    	"きおん",
    	"きかい",
    	"きかく",
    	"きかんしゃ",
    	"ききて",
    	"きくばり",
    	"きくらげ",
    	"きけんせい",
    	"きこう",
    	"きこえる",
    	"きこく",
    	"きさい",
    	"きさく",
    	"きさま",
    	"きさらぎ",
    	"ぎじかがく",
    	"ぎしき",
    	"ぎじたいけん",
    	"ぎじにってい",
    	"ぎじゅつしゃ",
    	"きすう",
    	"きせい",
    	"きせき",
    	"きせつ",
    	"きそう",
    	"きぞく",
    	"きぞん",
    	"きたえる",
    	"きちょう",
    	"きつえん",
    	"ぎっちり",
    	"きつつき",
    	"きつね",
    	"きてい",
    	"きどう",
    	"きどく",
    	"きない",
    	"きなが",
    	"きなこ",
    	"きぬごし",
    	"きねん",
    	"きのう",
    	"きのした",
    	"きはく",
    	"きびしい",
    	"きひん",
    	"きふく",
    	"きぶん",
    	"きぼう",
    	"きほん",
    	"きまる",
    	"きみつ",
    	"きむずかしい",
    	"きめる",
    	"きもだめし",
    	"きもち",
    	"きもの",
    	"きゃく",
    	"きやく",
    	"ぎゅうにく",
    	"きよう",
    	"きょうりゅう",
    	"きらい",
    	"きらく",
    	"きりん",
    	"きれい",
    	"きれつ",
    	"きろく",
    	"ぎろん",
    	"きわめる",
    	"ぎんいろ",
    	"きんかくじ",
    	"きんじょ",
    	"きんようび",
    	"ぐあい",
    	"くいず",
    	"くうかん",
    	"くうき",
    	"くうぐん",
    	"くうこう",
    	"ぐうせい",
    	"くうそう",
    	"ぐうたら",
    	"くうふく",
    	"くうぼ",
    	"くかん",
    	"くきょう",
    	"くげん",
    	"ぐこう",
    	"くさい",
    	"くさき",
    	"くさばな",
    	"くさる",
    	"くしゃみ",
    	"くしょう",
    	"くすのき",
    	"くすりゆび",
    	"くせげ",
    	"くせん",
    	"ぐたいてき",
    	"くださる",
    	"くたびれる",
    	"くちこみ",
    	"くちさき",
    	"くつした",
    	"ぐっすり",
    	"くつろぐ",
    	"くとうてん",
    	"くどく",
    	"くなん",
    	"くねくね",
    	"くのう",
    	"くふう",
    	"くみあわせ",
    	"くみたてる",
    	"くめる",
    	"くやくしょ",
    	"くらす",
    	"くらべる",
    	"くるま",
    	"くれる",
    	"くろう",
    	"くわしい",
    	"ぐんかん",
    	"ぐんしょく",
    	"ぐんたい",
    	"ぐんて",
    	"けあな",
    	"けいかく",
    	"けいけん",
    	"けいこ",
    	"けいさつ",
    	"げいじゅつ",
    	"けいたい",
    	"げいのうじん",
    	"けいれき",
    	"けいろ",
    	"けおとす",
    	"けおりもの",
    	"げきか",
    	"げきげん",
    	"げきだん",
    	"げきちん",
    	"げきとつ",
    	"げきは",
    	"げきやく",
    	"げこう",
    	"げこくじょう",
    	"げざい",
    	"けさき",
    	"げざん",
    	"けしき",
    	"けしごむ",
    	"けしょう",
    	"げすと",
    	"けたば",
    	"けちゃっぷ",
    	"けちらす",
    	"けつあつ",
    	"けつい",
    	"けつえき",
    	"けっこん",
    	"けつじょ",
    	"けっせき",
    	"けってい",
    	"けつまつ",
    	"げつようび",
    	"げつれい",
    	"けつろん",
    	"げどく",
    	"けとばす",
    	"けとる",
    	"けなげ",
    	"けなす",
    	"けなみ",
    	"けぬき",
    	"げねつ",
    	"けねん",
    	"けはい",
    	"げひん",
    	"けぶかい",
    	"げぼく",
    	"けまり",
    	"けみかる",
    	"けむし",
    	"けむり",
    	"けもの",
    	"けらい",
    	"けろけろ",
    	"けわしい",
    	"けんい",
    	"けんえつ",
    	"けんお",
    	"けんか",
    	"げんき",
    	"けんげん",
    	"けんこう",
    	"けんさく",
    	"けんしゅう",
    	"けんすう",
    	"げんそう",
    	"けんちく",
    	"けんてい",
    	"けんとう",
    	"けんない",
    	"けんにん",
    	"げんぶつ",
    	"けんま",
    	"けんみん",
    	"けんめい",
    	"けんらん",
    	"けんり",
    	"こあくま",
    	"こいぬ",
    	"こいびと",
    	"ごうい",
    	"こうえん",
    	"こうおん",
    	"こうかん",
    	"ごうきゅう",
    	"ごうけい",
    	"こうこう",
    	"こうさい",
    	"こうじ",
    	"こうすい",
    	"ごうせい",
    	"こうそく",
    	"こうたい",
    	"こうちゃ",
    	"こうつう",
    	"こうてい",
    	"こうどう",
    	"こうない",
    	"こうはい",
    	"ごうほう",
    	"ごうまん",
    	"こうもく",
    	"こうりつ",
    	"こえる",
    	"こおり",
    	"ごかい",
    	"ごがつ",
    	"ごかん",
    	"こくご",
    	"こくさい",
    	"こくとう",
    	"こくない",
    	"こくはく",
    	"こぐま",
    	"こけい",
    	"こける",
    	"ここのか",
    	"こころ",
    	"こさめ",
    	"こしつ",
    	"こすう",
    	"こせい",
    	"こせき",
    	"こぜん",
    	"こそだて",
    	"こたい",
    	"こたえる",
    	"こたつ",
    	"こちょう",
    	"こっか",
    	"こつこつ",
    	"こつばん",
    	"こつぶ",
    	"こてい",
    	"こてん",
    	"ことがら",
    	"ことし",
    	"ことば",
    	"ことり",
    	"こなごな",
    	"こねこね",
    	"このまま",
    	"このみ",
    	"このよ",
    	"ごはん",
    	"こひつじ",
    	"こふう",
    	"こふん",
    	"こぼれる",
    	"ごまあぶら",
    	"こまかい",
    	"ごますり",
    	"こまつな",
    	"こまる",
    	"こむぎこ",
    	"こもじ",
    	"こもち",
    	"こもの",
    	"こもん",
    	"こやく",
    	"こやま",
    	"こゆう",
    	"こゆび",
    	"こよい",
    	"こよう",
    	"こりる",
    	"これくしょん",
    	"ころっけ",
    	"こわもて",
    	"こわれる",
    	"こんいん",
    	"こんかい",
    	"こんき",
    	"こんしゅう",
    	"こんすい",
    	"こんだて",
    	"こんとん",
    	"こんなん",
    	"こんびに",
    	"こんぽん",
    	"こんまけ",
    	"こんや",
    	"こんれい",
    	"こんわく",
    	"ざいえき",
    	"さいかい",
    	"さいきん",
    	"ざいげん",
    	"ざいこ",
    	"さいしょ",
    	"さいせい",
    	"ざいたく",
    	"ざいちゅう",
    	"さいてき",
    	"ざいりょう",
    	"さうな",
    	"さかいし",
    	"さがす",
    	"さかな",
    	"さかみち",
    	"さがる",
    	"さぎょう",
    	"さくし",
    	"さくひん",
    	"さくら",
    	"さこく",
    	"さこつ",
    	"さずかる",
    	"ざせき",
    	"さたん",
    	"さつえい",
    	"ざつおん",
    	"ざっか",
    	"ざつがく",
    	"さっきょく",
    	"ざっし",
    	"さつじん",
    	"ざっそう",
    	"さつたば",
    	"さつまいも",
    	"さてい",
    	"さといも",
    	"さとう",
    	"さとおや",
    	"さとし",
    	"さとる",
    	"さのう",
    	"さばく",
    	"さびしい",
    	"さべつ",
    	"さほう",
    	"さほど",
    	"さます",
    	"さみしい",
    	"さみだれ",
    	"さむけ",
    	"さめる",
    	"さやえんどう",
    	"さゆう",
    	"さよう",
    	"さよく",
    	"さらだ",
    	"ざるそば",
    	"さわやか",
    	"さわる",
    	"さんいん",
    	"さんか",
    	"さんきゃく",
    	"さんこう",
    	"さんさい",
    	"ざんしょ",
    	"さんすう",
    	"さんせい",
    	"さんそ",
    	"さんち",
    	"さんま",
    	"さんみ",
    	"さんらん",
    	"しあい",
    	"しあげ",
    	"しあさって",
    	"しあわせ",
    	"しいく",
    	"しいん",
    	"しうち",
    	"しえい",
    	"しおけ",
    	"しかい",
    	"しかく",
    	"じかん",
    	"しごと",
    	"しすう",
    	"じだい",
    	"したうけ",
    	"したぎ",
    	"したて",
    	"したみ",
    	"しちょう",
    	"しちりん",
    	"しっかり",
    	"しつじ",
    	"しつもん",
    	"してい",
    	"してき",
    	"してつ",
    	"じてん",
    	"じどう",
    	"しなぎれ",
    	"しなもの",
    	"しなん",
    	"しねま",
    	"しねん",
    	"しのぐ",
    	"しのぶ",
    	"しはい",
    	"しばかり",
    	"しはつ",
    	"しはらい",
    	"しはん",
    	"しひょう",
    	"しふく",
    	"じぶん",
    	"しへい",
    	"しほう",
    	"しほん",
    	"しまう",
    	"しまる",
    	"しみん",
    	"しむける",
    	"じむしょ",
    	"しめい",
    	"しめる",
    	"しもん",
    	"しゃいん",
    	"しゃうん",
    	"しゃおん",
    	"じゃがいも",
    	"しやくしょ",
    	"しゃくほう",
    	"しゃけん",
    	"しゃこ",
    	"しゃざい",
    	"しゃしん",
    	"しゃせん",
    	"しゃそう",
    	"しゃたい",
    	"しゃちょう",
    	"しゃっきん",
    	"じゃま",
    	"しゃりん",
    	"しゃれい",
    	"じゆう",
    	"じゅうしょ",
    	"しゅくはく",
    	"じゅしん",
    	"しゅっせき",
    	"しゅみ",
    	"しゅらば",
    	"じゅんばん",
    	"しょうかい",
    	"しょくたく",
    	"しょっけん",
    	"しょどう",
    	"しょもつ",
    	"しらせる",
    	"しらべる",
    	"しんか",
    	"しんこう",
    	"じんじゃ",
    	"しんせいじ",
    	"しんちく",
    	"しんりん",
    	"すあげ",
    	"すあし",
    	"すあな",
    	"ずあん",
    	"すいえい",
    	"すいか",
    	"すいとう",
    	"ずいぶん",
    	"すいようび",
    	"すうがく",
    	"すうじつ",
    	"すうせん",
    	"すおどり",
    	"すきま",
    	"すくう",
    	"すくない",
    	"すける",
    	"すごい",
    	"すこし",
    	"ずさん",
    	"すずしい",
    	"すすむ",
    	"すすめる",
    	"すっかり",
    	"ずっしり",
    	"ずっと",
    	"すてき",
    	"すてる",
    	"すねる",
    	"すのこ",
    	"すはだ",
    	"すばらしい",
    	"ずひょう",
    	"ずぶぬれ",
    	"すぶり",
    	"すふれ",
    	"すべて",
    	"すべる",
    	"ずほう",
    	"すぼん",
    	"すまい",
    	"すめし",
    	"すもう",
    	"すやき",
    	"すらすら",
    	"するめ",
    	"すれちがう",
    	"すろっと",
    	"すわる",
    	"すんぜん",
    	"すんぽう",
    	"せあぶら",
    	"せいかつ",
    	"せいげん",
    	"せいじ",
    	"せいよう",
    	"せおう",
    	"せかいかん",
    	"せきにん",
    	"せきむ",
    	"せきゆ",
    	"せきらんうん",
    	"せけん",
    	"せこう",
    	"せすじ",
    	"せたい",
    	"せたけ",
    	"せっかく",
    	"せっきゃく",
    	"ぜっく",
    	"せっけん",
    	"せっこつ",
    	"せっさたくま",
    	"せつぞく",
    	"せつだん",
    	"せつでん",
    	"せっぱん",
    	"せつび",
    	"せつぶん",
    	"せつめい",
    	"せつりつ",
    	"せなか",
    	"せのび",
    	"せはば",
    	"せびろ",
    	"せぼね",
    	"せまい",
    	"せまる",
    	"せめる",
    	"せもたれ",
    	"せりふ",
    	"ぜんあく",
    	"せんい",
    	"せんえい",
    	"せんか",
    	"せんきょ",
    	"せんく",
    	"せんげん",
    	"ぜんご",
    	"せんさい",
    	"せんしゅ",
    	"せんすい",
    	"せんせい",
    	"せんぞ",
    	"せんたく",
    	"せんちょう",
    	"せんてい",
    	"せんとう",
    	"せんぬき",
    	"せんねん",
    	"せんぱい",
    	"ぜんぶ",
    	"ぜんぽう",
    	"せんむ",
    	"せんめんじょ",
    	"せんもん",
    	"せんやく",
    	"せんゆう",
    	"せんよう",
    	"ぜんら",
    	"ぜんりゃく",
    	"せんれい",
    	"せんろ",
    	"そあく",
    	"そいとげる",
    	"そいね",
    	"そうがんきょう",
    	"そうき",
    	"そうご",
    	"そうしん",
    	"そうだん",
    	"そうなん",
    	"そうび",
    	"そうめん",
    	"そうり",
    	"そえもの",
    	"そえん",
    	"そがい",
    	"そげき",
    	"そこう",
    	"そこそこ",
    	"そざい",
    	"そしな",
    	"そせい",
    	"そせん",
    	"そそぐ",
    	"そだてる",
    	"そつう",
    	"そつえん",
    	"そっかん",
    	"そつぎょう",
    	"そっけつ",
    	"そっこう",
    	"そっせん",
    	"そっと",
    	"そとがわ",
    	"そとづら",
    	"そなえる",
    	"そなた",
    	"そふぼ",
    	"そぼく",
    	"そぼろ",
    	"そまつ",
    	"そまる",
    	"そむく",
    	"そむりえ",
    	"そめる",
    	"そもそも",
    	"そよかぜ",
    	"そらまめ",
    	"そろう",
    	"そんかい",
    	"そんけい",
    	"そんざい",
    	"そんしつ",
    	"そんぞく",
    	"そんちょう",
    	"ぞんび",
    	"ぞんぶん",
    	"そんみん",
    	"たあい",
    	"たいいん",
    	"たいうん",
    	"たいえき",
    	"たいおう",
    	"だいがく",
    	"たいき",
    	"たいぐう",
    	"たいけん",
    	"たいこ",
    	"たいざい",
    	"だいじょうぶ",
    	"だいすき",
    	"たいせつ",
    	"たいそう",
    	"だいたい",
    	"たいちょう",
    	"たいてい",
    	"だいどころ",
    	"たいない",
    	"たいねつ",
    	"たいのう",
    	"たいはん",
    	"だいひょう",
    	"たいふう",
    	"たいへん",
    	"たいほ",
    	"たいまつばな",
    	"たいみんぐ",
    	"たいむ",
    	"たいめん",
    	"たいやき",
    	"たいよう",
    	"たいら",
    	"たいりょく",
    	"たいる",
    	"たいわん",
    	"たうえ",
    	"たえる",
    	"たおす",
    	"たおる",
    	"たおれる",
    	"たかい",
    	"たかね",
    	"たきび",
    	"たくさん",
    	"たこく",
    	"たこやき",
    	"たさい",
    	"たしざん",
    	"だじゃれ",
    	"たすける",
    	"たずさわる",
    	"たそがれ",
    	"たたかう",
    	"たたく",
    	"ただしい",
    	"たたみ",
    	"たちばな",
    	"だっかい",
    	"だっきゃく",
    	"だっこ",
    	"だっしゅつ",
    	"だったい",
    	"たてる",
    	"たとえる",
    	"たなばた",
    	"たにん",
    	"たぬき",
    	"たのしみ",
    	"たはつ",
    	"たぶん",
    	"たべる",
    	"たぼう",
    	"たまご",
    	"たまる",
    	"だむる",
    	"ためいき",
    	"ためす",
    	"ためる",
    	"たもつ",
    	"たやすい",
    	"たよる",
    	"たらす",
    	"たりきほんがん",
    	"たりょう",
    	"たりる",
    	"たると",
    	"たれる",
    	"たれんと",
    	"たろっと",
    	"たわむれる",
    	"だんあつ",
    	"たんい",
    	"たんおん",
    	"たんか",
    	"たんき",
    	"たんけん",
    	"たんご",
    	"たんさん",
    	"たんじょうび",
    	"だんせい",
    	"たんそく",
    	"たんたい",
    	"だんち",
    	"たんてい",
    	"たんとう",
    	"だんな",
    	"たんにん",
    	"だんねつ",
    	"たんのう",
    	"たんぴん",
    	"だんぼう",
    	"たんまつ",
    	"たんめい",
    	"だんれつ",
    	"だんろ",
    	"だんわ",
    	"ちあい",
    	"ちあん",
    	"ちいき",
    	"ちいさい",
    	"ちえん",
    	"ちかい",
    	"ちから",
    	"ちきゅう",
    	"ちきん",
    	"ちけいず",
    	"ちけん",
    	"ちこく",
    	"ちさい",
    	"ちしき",
    	"ちしりょう",
    	"ちせい",
    	"ちそう",
    	"ちたい",
    	"ちたん",
    	"ちちおや",
    	"ちつじょ",
    	"ちてき",
    	"ちてん",
    	"ちぬき",
    	"ちぬり",
    	"ちのう",
    	"ちひょう",
    	"ちへいせん",
    	"ちほう",
    	"ちまた",
    	"ちみつ",
    	"ちみどろ",
    	"ちめいど",
    	"ちゃんこなべ",
    	"ちゅうい",
    	"ちゆりょく",
    	"ちょうし",
    	"ちょさくけん",
    	"ちらし",
    	"ちらみ",
    	"ちりがみ",
    	"ちりょう",
    	"ちるど",
    	"ちわわ",
    	"ちんたい",
    	"ちんもく",
    	"ついか",
    	"ついたち",
    	"つうか",
    	"つうじょう",
    	"つうはん",
    	"つうわ",
    	"つかう",
    	"つかれる",
    	"つくね",
    	"つくる",
    	"つけね",
    	"つける",
    	"つごう",
    	"つたえる",
    	"つづく",
    	"つつじ",
    	"つつむ",
    	"つとめる",
    	"つながる",
    	"つなみ",
    	"つねづね",
    	"つのる",
    	"つぶす",
    	"つまらない",
    	"つまる",
    	"つみき",
    	"つめたい",
    	"つもり",
    	"つもる",
    	"つよい",
    	"つるぼ",
    	"つるみく",
    	"つわもの",
    	"つわり",
    	"てあし",
    	"てあて",
    	"てあみ",
    	"ていおん",
    	"ていか",
    	"ていき",
    	"ていけい",
    	"ていこく",
    	"ていさつ",
    	"ていし",
    	"ていせい",
    	"ていたい",
    	"ていど",
    	"ていねい",
    	"ていひょう",
    	"ていへん",
    	"ていぼう",
    	"てうち",
    	"ておくれ",
    	"てきとう",
    	"てくび",
    	"でこぼこ",
    	"てさぎょう",
    	"てさげ",
    	"てすり",
    	"てそう",
    	"てちがい",
    	"てちょう",
    	"てつがく",
    	"てつづき",
    	"でっぱ",
    	"てつぼう",
    	"てつや",
    	"でぬかえ",
    	"てぬき",
    	"てぬぐい",
    	"てのひら",
    	"てはい",
    	"てぶくろ",
    	"てふだ",
    	"てほどき",
    	"てほん",
    	"てまえ",
    	"てまきずし",
    	"てみじか",
    	"てみやげ",
    	"てらす",
    	"てれび",
    	"てわけ",
    	"てわたし",
    	"でんあつ",
    	"てんいん",
    	"てんかい",
    	"てんき",
    	"てんぐ",
    	"てんけん",
    	"てんごく",
    	"てんさい",
    	"てんし",
    	"てんすう",
    	"でんち",
    	"てんてき",
    	"てんとう",
    	"てんない",
    	"てんぷら",
    	"てんぼうだい",
    	"てんめつ",
    	"てんらんかい",
    	"でんりょく",
    	"でんわ",
    	"どあい",
    	"といれ",
    	"どうかん",
    	"とうきゅう",
    	"どうぐ",
    	"とうし",
    	"とうむぎ",
    	"とおい",
    	"とおか",
    	"とおく",
    	"とおす",
    	"とおる",
    	"とかい",
    	"とかす",
    	"ときおり",
    	"ときどき",
    	"とくい",
    	"とくしゅう",
    	"とくてん",
    	"とくに",
    	"とくべつ",
    	"とけい",
    	"とける",
    	"とこや",
    	"とさか",
    	"としょかん",
    	"とそう",
    	"とたん",
    	"とちゅう",
    	"とっきゅう",
    	"とっくん",
    	"とつぜん",
    	"とつにゅう",
    	"とどける",
    	"ととのえる",
    	"とない",
    	"となえる",
    	"となり",
    	"とのさま",
    	"とばす",
    	"どぶがわ",
    	"とほう",
    	"とまる",
    	"とめる",
    	"ともだち",
    	"ともる",
    	"どようび",
    	"とらえる",
    	"とんかつ",
    	"どんぶり",
    	"ないかく",
    	"ないこう",
    	"ないしょ",
    	"ないす",
    	"ないせん",
    	"ないそう",
    	"なおす",
    	"ながい",
    	"なくす",
    	"なげる",
    	"なこうど",
    	"なさけ",
    	"なたでここ",
    	"なっとう",
    	"なつやすみ",
    	"ななおし",
    	"なにごと",
    	"なにもの",
    	"なにわ",
    	"なのか",
    	"なふだ",
    	"なまいき",
    	"なまえ",
    	"なまみ",
    	"なみだ",
    	"なめらか",
    	"なめる",
    	"なやむ",
    	"ならう",
    	"ならび",
    	"ならぶ",
    	"なれる",
    	"なわとび",
    	"なわばり",
    	"にあう",
    	"にいがた",
    	"にうけ",
    	"におい",
    	"にかい",
    	"にがて",
    	"にきび",
    	"にくしみ",
    	"にくまん",
    	"にげる",
    	"にさんかたんそ",
    	"にしき",
    	"にせもの",
    	"にちじょう",
    	"にちようび",
    	"にっか",
    	"にっき",
    	"にっけい",
    	"にっこう",
    	"にっさん",
    	"にっしょく",
    	"にっすう",
    	"にっせき",
    	"にってい",
    	"になう",
    	"にほん",
    	"にまめ",
    	"にもつ",
    	"にやり",
    	"にゅういん",
    	"にりんしゃ",
    	"にわとり",
    	"にんい",
    	"にんか",
    	"にんき",
    	"にんげん",
    	"にんしき",
    	"にんずう",
    	"にんそう",
    	"にんたい",
    	"にんち",
    	"にんてい",
    	"にんにく",
    	"にんぷ",
    	"にんまり",
    	"にんむ",
    	"にんめい",
    	"にんよう",
    	"ぬいくぎ",
    	"ぬかす",
    	"ぬぐいとる",
    	"ぬぐう",
    	"ぬくもり",
    	"ぬすむ",
    	"ぬまえび",
    	"ぬめり",
    	"ぬらす",
    	"ぬんちゃく",
    	"ねあげ",
    	"ねいき",
    	"ねいる",
    	"ねいろ",
    	"ねぐせ",
    	"ねくたい",
    	"ねくら",
    	"ねこぜ",
    	"ねこむ",
    	"ねさげ",
    	"ねすごす",
    	"ねそべる",
    	"ねだん",
    	"ねつい",
    	"ねっしん",
    	"ねつぞう",
    	"ねったいぎょ",
    	"ねぶそく",
    	"ねふだ",
    	"ねぼう",
    	"ねほりはほり",
    	"ねまき",
    	"ねまわし",
    	"ねみみ",
    	"ねむい",
    	"ねむたい",
    	"ねもと",
    	"ねらう",
    	"ねわざ",
    	"ねんいり",
    	"ねんおし",
    	"ねんかん",
    	"ねんきん",
    	"ねんぐ",
    	"ねんざ",
    	"ねんし",
    	"ねんちゃく",
    	"ねんど",
    	"ねんぴ",
    	"ねんぶつ",
    	"ねんまつ",
    	"ねんりょう",
    	"ねんれい",
    	"のいず",
    	"のおづま",
    	"のがす",
    	"のきなみ",
    	"のこぎり",
    	"のこす",
    	"のこる",
    	"のせる",
    	"のぞく",
    	"のぞむ",
    	"のたまう",
    	"のちほど",
    	"のっく",
    	"のばす",
    	"のはら",
    	"のべる",
    	"のぼる",
    	"のみもの",
    	"のやま",
    	"のらいぬ",
    	"のらねこ",
    	"のりもの",
    	"のりゆき",
    	"のれん",
    	"のんき",
    	"ばあい",
    	"はあく",
    	"ばあさん",
    	"ばいか",
    	"ばいく",
    	"はいけん",
    	"はいご",
    	"はいしん",
    	"はいすい",
    	"はいせん",
    	"はいそう",
    	"はいち",
    	"ばいばい",
    	"はいれつ",
    	"はえる",
    	"はおる",
    	"はかい",
    	"ばかり",
    	"はかる",
    	"はくしゅ",
    	"はけん",
    	"はこぶ",
    	"はさみ",
    	"はさん",
    	"はしご",
    	"ばしょ",
    	"はしる",
    	"はせる",
    	"ぱそこん",
    	"はそん",
    	"はたん",
    	"はちみつ",
    	"はつおん",
    	"はっかく",
    	"はづき",
    	"はっきり",
    	"はっくつ",
    	"はっけん",
    	"はっこう",
    	"はっさん",
    	"はっしん",
    	"はったつ",
    	"はっちゅう",
    	"はってん",
    	"はっぴょう",
    	"はっぽう",
    	"はなす",
    	"はなび",
    	"はにかむ",
    	"はぶらし",
    	"はみがき",
    	"はむかう",
    	"はめつ",
    	"はやい",
    	"はやし",
    	"はらう",
    	"はろうぃん",
    	"はわい",
    	"はんい",
    	"はんえい",
    	"はんおん",
    	"はんかく",
    	"はんきょう",
    	"ばんぐみ",
    	"はんこ",
    	"はんしゃ",
    	"はんすう",
    	"はんだん",
    	"ぱんち",
    	"ぱんつ",
    	"はんてい",
    	"はんとし",
    	"はんのう",
    	"はんぱ",
    	"はんぶん",
    	"はんぺん",
    	"はんぼうき",
    	"はんめい",
    	"はんらん",
    	"はんろん",
    	"ひいき",
    	"ひうん",
    	"ひえる",
    	"ひかく",
    	"ひかり",
    	"ひかる",
    	"ひかん",
    	"ひくい",
    	"ひけつ",
    	"ひこうき",
    	"ひこく",
    	"ひさい",
    	"ひさしぶり",
    	"ひさん",
    	"びじゅつかん",
    	"ひしょ",
    	"ひそか",
    	"ひそむ",
    	"ひたむき",
    	"ひだり",
    	"ひたる",
    	"ひつぎ",
    	"ひっこし",
    	"ひっし",
    	"ひつじゅひん",
    	"ひっす",
    	"ひつぜん",
    	"ぴったり",
    	"ぴっちり",
    	"ひつよう",
    	"ひてい",
    	"ひとごみ",
    	"ひなまつり",
    	"ひなん",
    	"ひねる",
    	"ひはん",
    	"ひびく",
    	"ひひょう",
    	"ひほう",
    	"ひまわり",
    	"ひまん",
    	"ひみつ",
    	"ひめい",
    	"ひめじし",
    	"ひやけ",
    	"ひやす",
    	"ひよう",
    	"びょうき",
    	"ひらがな",
    	"ひらく",
    	"ひりつ",
    	"ひりょう",
    	"ひるま",
    	"ひるやすみ",
    	"ひれい",
    	"ひろい",
    	"ひろう",
    	"ひろき",
    	"ひろゆき",
    	"ひんかく",
    	"ひんけつ",
    	"ひんこん",
    	"ひんしゅ",
    	"ひんそう",
    	"ぴんち",
    	"ひんぱん",
    	"びんぼう",
    	"ふあん",
    	"ふいうち",
    	"ふうけい",
    	"ふうせん",
    	"ぷうたろう",
    	"ふうとう",
    	"ふうふ",
    	"ふえる",
    	"ふおん",
    	"ふかい",
    	"ふきん",
    	"ふくざつ",
    	"ふくぶくろ",
    	"ふこう",
    	"ふさい",
    	"ふしぎ",
    	"ふじみ",
    	"ふすま",
    	"ふせい",
    	"ふせぐ",
    	"ふそく",
    	"ぶたにく",
    	"ふたん",
    	"ふちょう",
    	"ふつう",
    	"ふつか",
    	"ふっかつ",
    	"ふっき",
    	"ふっこく",
    	"ぶどう",
    	"ふとる",
    	"ふとん",
    	"ふのう",
    	"ふはい",
    	"ふひょう",
    	"ふへん",
    	"ふまん",
    	"ふみん",
    	"ふめつ",
    	"ふめん",
    	"ふよう",
    	"ふりこ",
    	"ふりる",
    	"ふるい",
    	"ふんいき",
    	"ぶんがく",
    	"ぶんぐ",
    	"ふんしつ",
    	"ぶんせき",
    	"ふんそう",
    	"ぶんぽう",
    	"へいあん",
    	"へいおん",
    	"へいがい",
    	"へいき",
    	"へいげん",
    	"へいこう",
    	"へいさ",
    	"へいしゃ",
    	"へいせつ",
    	"へいそ",
    	"へいたく",
    	"へいてん",
    	"へいねつ",
    	"へいわ",
    	"へきが",
    	"へこむ",
    	"べにいろ",
    	"べにしょうが",
    	"へらす",
    	"へんかん",
    	"べんきょう",
    	"べんごし",
    	"へんさい",
    	"へんたい",
    	"べんり",
    	"ほあん",
    	"ほいく",
    	"ぼうぎょ",
    	"ほうこく",
    	"ほうそう",
    	"ほうほう",
    	"ほうもん",
    	"ほうりつ",
    	"ほえる",
    	"ほおん",
    	"ほかん",
    	"ほきょう",
    	"ぼきん",
    	"ほくろ",
    	"ほけつ",
    	"ほけん",
    	"ほこう",
    	"ほこる",
    	"ほしい",
    	"ほしつ",
    	"ほしゅ",
    	"ほしょう",
    	"ほせい",
    	"ほそい",
    	"ほそく",
    	"ほたて",
    	"ほたる",
    	"ぽちぶくろ",
    	"ほっきょく",
    	"ほっさ",
    	"ほったん",
    	"ほとんど",
    	"ほめる",
    	"ほんい",
    	"ほんき",
    	"ほんけ",
    	"ほんしつ",
    	"ほんやく",
    	"まいにち",
    	"まかい",
    	"まかせる",
    	"まがる",
    	"まける",
    	"まこと",
    	"まさつ",
    	"まじめ",
    	"ますく",
    	"まぜる",
    	"まつり",
    	"まとめ",
    	"まなぶ",
    	"まぬけ",
    	"まねく",
    	"まほう",
    	"まもる",
    	"まゆげ",
    	"まよう",
    	"まろやか",
    	"まわす",
    	"まわり",
    	"まわる",
    	"まんが",
    	"まんきつ",
    	"まんぞく",
    	"まんなか",
    	"みいら",
    	"みうち",
    	"みえる",
    	"みがく",
    	"みかた",
    	"みかん",
    	"みけん",
    	"みこん",
    	"みじかい",
    	"みすい",
    	"みすえる",
    	"みせる",
    	"みっか",
    	"みつかる",
    	"みつける",
    	"みてい",
    	"みとめる",
    	"みなと",
    	"みなみかさい",
    	"みねらる",
    	"みのう",
    	"みのがす",
    	"みほん",
    	"みもと",
    	"みやげ",
    	"みらい",
    	"みりょく",
    	"みわく",
    	"みんか",
    	"みんぞく",
    	"むいか",
    	"むえき",
    	"むえん",
    	"むかい",
    	"むかう",
    	"むかえ",
    	"むかし",
    	"むぎちゃ",
    	"むける",
    	"むげん",
    	"むさぼる",
    	"むしあつい",
    	"むしば",
    	"むじゅん",
    	"むしろ",
    	"むすう",
    	"むすこ",
    	"むすぶ",
    	"むすめ",
    	"むせる",
    	"むせん",
    	"むちゅう",
    	"むなしい",
    	"むのう",
    	"むやみ",
    	"むよう",
    	"むらさき",
    	"むりょう",
    	"むろん",
    	"めいあん",
    	"めいうん",
    	"めいえん",
    	"めいかく",
    	"めいきょく",
    	"めいさい",
    	"めいし",
    	"めいそう",
    	"めいぶつ",
    	"めいれい",
    	"めいわく",
    	"めぐまれる",
    	"めざす",
    	"めした",
    	"めずらしい",
    	"めだつ",
    	"めまい",
    	"めやす",
    	"めんきょ",
    	"めんせき",
    	"めんどう",
    	"もうしあげる",
    	"もうどうけん",
    	"もえる",
    	"もくし",
    	"もくてき",
    	"もくようび",
    	"もちろん",
    	"もどる",
    	"もらう",
    	"もんく",
    	"もんだい",
    	"やおや",
    	"やける",
    	"やさい",
    	"やさしい",
    	"やすい",
    	"やすたろう",
    	"やすみ",
    	"やせる",
    	"やそう",
    	"やたい",
    	"やちん",
    	"やっと",
    	"やっぱり",
    	"やぶる",
    	"やめる",
    	"ややこしい",
    	"やよい",
    	"やわらかい",
    	"ゆうき",
    	"ゆうびんきょく",
    	"ゆうべ",
    	"ゆうめい",
    	"ゆけつ",
    	"ゆしゅつ",
    	"ゆせん",
    	"ゆそう",
    	"ゆたか",
    	"ゆちゃく",
    	"ゆでる",
    	"ゆにゅう",
    	"ゆびわ",
    	"ゆらい",
    	"ゆれる",
    	"ようい",
    	"ようか",
    	"ようきゅう",
    	"ようじ",
    	"ようす",
    	"ようちえん",
    	"よかぜ",
    	"よかん",
    	"よきん",
    	"よくせい",
    	"よくぼう",
    	"よけい",
    	"よごれる",
    	"よさん",
    	"よしゅう",
    	"よそう",
    	"よそく",
    	"よっか",
    	"よてい",
    	"よどがわく",
    	"よねつ",
    	"よやく",
    	"よゆう",
    	"よろこぶ",
    	"よろしい",
    	"らいう",
    	"らくがき",
    	"らくご",
    	"らくさつ",
    	"らくだ",
    	"らしんばん",
    	"らせん",
    	"らぞく",
    	"らたい",
    	"らっか",
    	"られつ",
    	"りえき",
    	"りかい",
    	"りきさく",
    	"りきせつ",
    	"りくぐん",
    	"りくつ",
    	"りけん",
    	"りこう",
    	"りせい",
    	"りそう",
    	"りそく",
    	"りてん",
    	"りねん",
    	"りゆう",
    	"りゅうがく",
    	"りよう",
    	"りょうり",
    	"りょかん",
    	"りょくちゃ",
    	"りょこう",
    	"りりく",
    	"りれき",
    	"りろん",
    	"りんご",
    	"るいけい",
    	"るいさい",
    	"るいじ",
    	"るいせき",
    	"るすばん",
    	"るりがわら",
    	"れいかん",
    	"れいぎ",
    	"れいせい",
    	"れいぞうこ",
    	"れいとう",
    	"れいぼう",
    	"れきし",
    	"れきだい",
    	"れんあい",
    	"れんけい",
    	"れんこん",
    	"れんさい",
    	"れんしゅう",
    	"れんぞく",
    	"れんらく",
    	"ろうか",
    	"ろうご",
    	"ろうじん",
    	"ろうそく",
    	"ろくが",
    	"ろこつ",
    	"ろじうら",
    	"ろしゅつ",
    	"ろせん",
    	"ろてん",
    	"ろめん",
    	"ろれつ",
    	"ろんぎ",
    	"ろんぱ",
    	"ろんぶん",
    	"ろんり",
    	"わかす",
    	"わかめ",
    	"わかやま",
    	"わかれる",
    	"わしつ",
    	"わじまし",
    	"わすれもの",
    	"わらう",
    	"われる"
    ];

    var require$$8 = [
    	"abandon",
    	"ability",
    	"able",
    	"about",
    	"above",
    	"absent",
    	"absorb",
    	"abstract",
    	"absurd",
    	"abuse",
    	"access",
    	"accident",
    	"account",
    	"accuse",
    	"achieve",
    	"acid",
    	"acoustic",
    	"acquire",
    	"across",
    	"act",
    	"action",
    	"actor",
    	"actress",
    	"actual",
    	"adapt",
    	"add",
    	"addict",
    	"address",
    	"adjust",
    	"admit",
    	"adult",
    	"advance",
    	"advice",
    	"aerobic",
    	"affair",
    	"afford",
    	"afraid",
    	"again",
    	"age",
    	"agent",
    	"agree",
    	"ahead",
    	"aim",
    	"air",
    	"airport",
    	"aisle",
    	"alarm",
    	"album",
    	"alcohol",
    	"alert",
    	"alien",
    	"all",
    	"alley",
    	"allow",
    	"almost",
    	"alone",
    	"alpha",
    	"already",
    	"also",
    	"alter",
    	"always",
    	"amateur",
    	"amazing",
    	"among",
    	"amount",
    	"amused",
    	"analyst",
    	"anchor",
    	"ancient",
    	"anger",
    	"angle",
    	"angry",
    	"animal",
    	"ankle",
    	"announce",
    	"annual",
    	"another",
    	"answer",
    	"antenna",
    	"antique",
    	"anxiety",
    	"any",
    	"apart",
    	"apology",
    	"appear",
    	"apple",
    	"approve",
    	"april",
    	"arch",
    	"arctic",
    	"area",
    	"arena",
    	"argue",
    	"arm",
    	"armed",
    	"armor",
    	"army",
    	"around",
    	"arrange",
    	"arrest",
    	"arrive",
    	"arrow",
    	"art",
    	"artefact",
    	"artist",
    	"artwork",
    	"ask",
    	"aspect",
    	"assault",
    	"asset",
    	"assist",
    	"assume",
    	"asthma",
    	"athlete",
    	"atom",
    	"attack",
    	"attend",
    	"attitude",
    	"attract",
    	"auction",
    	"audit",
    	"august",
    	"aunt",
    	"author",
    	"auto",
    	"autumn",
    	"average",
    	"avocado",
    	"avoid",
    	"awake",
    	"aware",
    	"away",
    	"awesome",
    	"awful",
    	"awkward",
    	"axis",
    	"baby",
    	"bachelor",
    	"bacon",
    	"badge",
    	"bag",
    	"balance",
    	"balcony",
    	"ball",
    	"bamboo",
    	"banana",
    	"banner",
    	"bar",
    	"barely",
    	"bargain",
    	"barrel",
    	"base",
    	"basic",
    	"basket",
    	"battle",
    	"beach",
    	"bean",
    	"beauty",
    	"because",
    	"become",
    	"beef",
    	"before",
    	"begin",
    	"behave",
    	"behind",
    	"believe",
    	"below",
    	"belt",
    	"bench",
    	"benefit",
    	"best",
    	"betray",
    	"better",
    	"between",
    	"beyond",
    	"bicycle",
    	"bid",
    	"bike",
    	"bind",
    	"biology",
    	"bird",
    	"birth",
    	"bitter",
    	"black",
    	"blade",
    	"blame",
    	"blanket",
    	"blast",
    	"bleak",
    	"bless",
    	"blind",
    	"blood",
    	"blossom",
    	"blouse",
    	"blue",
    	"blur",
    	"blush",
    	"board",
    	"boat",
    	"body",
    	"boil",
    	"bomb",
    	"bone",
    	"bonus",
    	"book",
    	"boost",
    	"border",
    	"boring",
    	"borrow",
    	"boss",
    	"bottom",
    	"bounce",
    	"box",
    	"boy",
    	"bracket",
    	"brain",
    	"brand",
    	"brass",
    	"brave",
    	"bread",
    	"breeze",
    	"brick",
    	"bridge",
    	"brief",
    	"bright",
    	"bring",
    	"brisk",
    	"broccoli",
    	"broken",
    	"bronze",
    	"broom",
    	"brother",
    	"brown",
    	"brush",
    	"bubble",
    	"buddy",
    	"budget",
    	"buffalo",
    	"build",
    	"bulb",
    	"bulk",
    	"bullet",
    	"bundle",
    	"bunker",
    	"burden",
    	"burger",
    	"burst",
    	"bus",
    	"business",
    	"busy",
    	"butter",
    	"buyer",
    	"buzz",
    	"cabbage",
    	"cabin",
    	"cable",
    	"cactus",
    	"cage",
    	"cake",
    	"call",
    	"calm",
    	"camera",
    	"camp",
    	"can",
    	"canal",
    	"cancel",
    	"candy",
    	"cannon",
    	"canoe",
    	"canvas",
    	"canyon",
    	"capable",
    	"capital",
    	"captain",
    	"car",
    	"carbon",
    	"card",
    	"cargo",
    	"carpet",
    	"carry",
    	"cart",
    	"case",
    	"cash",
    	"casino",
    	"castle",
    	"casual",
    	"cat",
    	"catalog",
    	"catch",
    	"category",
    	"cattle",
    	"caught",
    	"cause",
    	"caution",
    	"cave",
    	"ceiling",
    	"celery",
    	"cement",
    	"census",
    	"century",
    	"cereal",
    	"certain",
    	"chair",
    	"chalk",
    	"champion",
    	"change",
    	"chaos",
    	"chapter",
    	"charge",
    	"chase",
    	"chat",
    	"cheap",
    	"check",
    	"cheese",
    	"chef",
    	"cherry",
    	"chest",
    	"chicken",
    	"chief",
    	"child",
    	"chimney",
    	"choice",
    	"choose",
    	"chronic",
    	"chuckle",
    	"chunk",
    	"churn",
    	"cigar",
    	"cinnamon",
    	"circle",
    	"citizen",
    	"city",
    	"civil",
    	"claim",
    	"clap",
    	"clarify",
    	"claw",
    	"clay",
    	"clean",
    	"clerk",
    	"clever",
    	"click",
    	"client",
    	"cliff",
    	"climb",
    	"clinic",
    	"clip",
    	"clock",
    	"clog",
    	"close",
    	"cloth",
    	"cloud",
    	"clown",
    	"club",
    	"clump",
    	"cluster",
    	"clutch",
    	"coach",
    	"coast",
    	"coconut",
    	"code",
    	"coffee",
    	"coil",
    	"coin",
    	"collect",
    	"color",
    	"column",
    	"combine",
    	"come",
    	"comfort",
    	"comic",
    	"common",
    	"company",
    	"concert",
    	"conduct",
    	"confirm",
    	"congress",
    	"connect",
    	"consider",
    	"control",
    	"convince",
    	"cook",
    	"cool",
    	"copper",
    	"copy",
    	"coral",
    	"core",
    	"corn",
    	"correct",
    	"cost",
    	"cotton",
    	"couch",
    	"country",
    	"couple",
    	"course",
    	"cousin",
    	"cover",
    	"coyote",
    	"crack",
    	"cradle",
    	"craft",
    	"cram",
    	"crane",
    	"crash",
    	"crater",
    	"crawl",
    	"crazy",
    	"cream",
    	"credit",
    	"creek",
    	"crew",
    	"cricket",
    	"crime",
    	"crisp",
    	"critic",
    	"crop",
    	"cross",
    	"crouch",
    	"crowd",
    	"crucial",
    	"cruel",
    	"cruise",
    	"crumble",
    	"crunch",
    	"crush",
    	"cry",
    	"crystal",
    	"cube",
    	"culture",
    	"cup",
    	"cupboard",
    	"curious",
    	"current",
    	"curtain",
    	"curve",
    	"cushion",
    	"custom",
    	"cute",
    	"cycle",
    	"dad",
    	"damage",
    	"damp",
    	"dance",
    	"danger",
    	"daring",
    	"dash",
    	"daughter",
    	"dawn",
    	"day",
    	"deal",
    	"debate",
    	"debris",
    	"decade",
    	"december",
    	"decide",
    	"decline",
    	"decorate",
    	"decrease",
    	"deer",
    	"defense",
    	"define",
    	"defy",
    	"degree",
    	"delay",
    	"deliver",
    	"demand",
    	"demise",
    	"denial",
    	"dentist",
    	"deny",
    	"depart",
    	"depend",
    	"deposit",
    	"depth",
    	"deputy",
    	"derive",
    	"describe",
    	"desert",
    	"design",
    	"desk",
    	"despair",
    	"destroy",
    	"detail",
    	"detect",
    	"develop",
    	"device",
    	"devote",
    	"diagram",
    	"dial",
    	"diamond",
    	"diary",
    	"dice",
    	"diesel",
    	"diet",
    	"differ",
    	"digital",
    	"dignity",
    	"dilemma",
    	"dinner",
    	"dinosaur",
    	"direct",
    	"dirt",
    	"disagree",
    	"discover",
    	"disease",
    	"dish",
    	"dismiss",
    	"disorder",
    	"display",
    	"distance",
    	"divert",
    	"divide",
    	"divorce",
    	"dizzy",
    	"doctor",
    	"document",
    	"dog",
    	"doll",
    	"dolphin",
    	"domain",
    	"donate",
    	"donkey",
    	"donor",
    	"door",
    	"dose",
    	"double",
    	"dove",
    	"draft",
    	"dragon",
    	"drama",
    	"drastic",
    	"draw",
    	"dream",
    	"dress",
    	"drift",
    	"drill",
    	"drink",
    	"drip",
    	"drive",
    	"drop",
    	"drum",
    	"dry",
    	"duck",
    	"dumb",
    	"dune",
    	"during",
    	"dust",
    	"dutch",
    	"duty",
    	"dwarf",
    	"dynamic",
    	"eager",
    	"eagle",
    	"early",
    	"earn",
    	"earth",
    	"easily",
    	"east",
    	"easy",
    	"echo",
    	"ecology",
    	"economy",
    	"edge",
    	"edit",
    	"educate",
    	"effort",
    	"egg",
    	"eight",
    	"either",
    	"elbow",
    	"elder",
    	"electric",
    	"elegant",
    	"element",
    	"elephant",
    	"elevator",
    	"elite",
    	"else",
    	"embark",
    	"embody",
    	"embrace",
    	"emerge",
    	"emotion",
    	"employ",
    	"empower",
    	"empty",
    	"enable",
    	"enact",
    	"end",
    	"endless",
    	"endorse",
    	"enemy",
    	"energy",
    	"enforce",
    	"engage",
    	"engine",
    	"enhance",
    	"enjoy",
    	"enlist",
    	"enough",
    	"enrich",
    	"enroll",
    	"ensure",
    	"enter",
    	"entire",
    	"entry",
    	"envelope",
    	"episode",
    	"equal",
    	"equip",
    	"era",
    	"erase",
    	"erode",
    	"erosion",
    	"error",
    	"erupt",
    	"escape",
    	"essay",
    	"essence",
    	"estate",
    	"eternal",
    	"ethics",
    	"evidence",
    	"evil",
    	"evoke",
    	"evolve",
    	"exact",
    	"example",
    	"excess",
    	"exchange",
    	"excite",
    	"exclude",
    	"excuse",
    	"execute",
    	"exercise",
    	"exhaust",
    	"exhibit",
    	"exile",
    	"exist",
    	"exit",
    	"exotic",
    	"expand",
    	"expect",
    	"expire",
    	"explain",
    	"expose",
    	"express",
    	"extend",
    	"extra",
    	"eye",
    	"eyebrow",
    	"fabric",
    	"face",
    	"faculty",
    	"fade",
    	"faint",
    	"faith",
    	"fall",
    	"false",
    	"fame",
    	"family",
    	"famous",
    	"fan",
    	"fancy",
    	"fantasy",
    	"farm",
    	"fashion",
    	"fat",
    	"fatal",
    	"father",
    	"fatigue",
    	"fault",
    	"favorite",
    	"feature",
    	"february",
    	"federal",
    	"fee",
    	"feed",
    	"feel",
    	"female",
    	"fence",
    	"festival",
    	"fetch",
    	"fever",
    	"few",
    	"fiber",
    	"fiction",
    	"field",
    	"figure",
    	"file",
    	"film",
    	"filter",
    	"final",
    	"find",
    	"fine",
    	"finger",
    	"finish",
    	"fire",
    	"firm",
    	"first",
    	"fiscal",
    	"fish",
    	"fit",
    	"fitness",
    	"fix",
    	"flag",
    	"flame",
    	"flash",
    	"flat",
    	"flavor",
    	"flee",
    	"flight",
    	"flip",
    	"float",
    	"flock",
    	"floor",
    	"flower",
    	"fluid",
    	"flush",
    	"fly",
    	"foam",
    	"focus",
    	"fog",
    	"foil",
    	"fold",
    	"follow",
    	"food",
    	"foot",
    	"force",
    	"forest",
    	"forget",
    	"fork",
    	"fortune",
    	"forum",
    	"forward",
    	"fossil",
    	"foster",
    	"found",
    	"fox",
    	"fragile",
    	"frame",
    	"frequent",
    	"fresh",
    	"friend",
    	"fringe",
    	"frog",
    	"front",
    	"frost",
    	"frown",
    	"frozen",
    	"fruit",
    	"fuel",
    	"fun",
    	"funny",
    	"furnace",
    	"fury",
    	"future",
    	"gadget",
    	"gain",
    	"galaxy",
    	"gallery",
    	"game",
    	"gap",
    	"garage",
    	"garbage",
    	"garden",
    	"garlic",
    	"garment",
    	"gas",
    	"gasp",
    	"gate",
    	"gather",
    	"gauge",
    	"gaze",
    	"general",
    	"genius",
    	"genre",
    	"gentle",
    	"genuine",
    	"gesture",
    	"ghost",
    	"giant",
    	"gift",
    	"giggle",
    	"ginger",
    	"giraffe",
    	"girl",
    	"give",
    	"glad",
    	"glance",
    	"glare",
    	"glass",
    	"glide",
    	"glimpse",
    	"globe",
    	"gloom",
    	"glory",
    	"glove",
    	"glow",
    	"glue",
    	"goat",
    	"goddess",
    	"gold",
    	"good",
    	"goose",
    	"gorilla",
    	"gospel",
    	"gossip",
    	"govern",
    	"gown",
    	"grab",
    	"grace",
    	"grain",
    	"grant",
    	"grape",
    	"grass",
    	"gravity",
    	"great",
    	"green",
    	"grid",
    	"grief",
    	"grit",
    	"grocery",
    	"group",
    	"grow",
    	"grunt",
    	"guard",
    	"guess",
    	"guide",
    	"guilt",
    	"guitar",
    	"gun",
    	"gym",
    	"habit",
    	"hair",
    	"half",
    	"hammer",
    	"hamster",
    	"hand",
    	"happy",
    	"harbor",
    	"hard",
    	"harsh",
    	"harvest",
    	"hat",
    	"have",
    	"hawk",
    	"hazard",
    	"head",
    	"health",
    	"heart",
    	"heavy",
    	"hedgehog",
    	"height",
    	"hello",
    	"helmet",
    	"help",
    	"hen",
    	"hero",
    	"hidden",
    	"high",
    	"hill",
    	"hint",
    	"hip",
    	"hire",
    	"history",
    	"hobby",
    	"hockey",
    	"hold",
    	"hole",
    	"holiday",
    	"hollow",
    	"home",
    	"honey",
    	"hood",
    	"hope",
    	"horn",
    	"horror",
    	"horse",
    	"hospital",
    	"host",
    	"hotel",
    	"hour",
    	"hover",
    	"hub",
    	"huge",
    	"human",
    	"humble",
    	"humor",
    	"hundred",
    	"hungry",
    	"hunt",
    	"hurdle",
    	"hurry",
    	"hurt",
    	"husband",
    	"hybrid",
    	"ice",
    	"icon",
    	"idea",
    	"identify",
    	"idle",
    	"ignore",
    	"ill",
    	"illegal",
    	"illness",
    	"image",
    	"imitate",
    	"immense",
    	"immune",
    	"impact",
    	"impose",
    	"improve",
    	"impulse",
    	"inch",
    	"include",
    	"income",
    	"increase",
    	"index",
    	"indicate",
    	"indoor",
    	"industry",
    	"infant",
    	"inflict",
    	"inform",
    	"inhale",
    	"inherit",
    	"initial",
    	"inject",
    	"injury",
    	"inmate",
    	"inner",
    	"innocent",
    	"input",
    	"inquiry",
    	"insane",
    	"insect",
    	"inside",
    	"inspire",
    	"install",
    	"intact",
    	"interest",
    	"into",
    	"invest",
    	"invite",
    	"involve",
    	"iron",
    	"island",
    	"isolate",
    	"issue",
    	"item",
    	"ivory",
    	"jacket",
    	"jaguar",
    	"jar",
    	"jazz",
    	"jealous",
    	"jeans",
    	"jelly",
    	"jewel",
    	"job",
    	"join",
    	"joke",
    	"journey",
    	"joy",
    	"judge",
    	"juice",
    	"jump",
    	"jungle",
    	"junior",
    	"junk",
    	"just",
    	"kangaroo",
    	"keen",
    	"keep",
    	"ketchup",
    	"key",
    	"kick",
    	"kid",
    	"kidney",
    	"kind",
    	"kingdom",
    	"kiss",
    	"kit",
    	"kitchen",
    	"kite",
    	"kitten",
    	"kiwi",
    	"knee",
    	"knife",
    	"knock",
    	"know",
    	"lab",
    	"label",
    	"labor",
    	"ladder",
    	"lady",
    	"lake",
    	"lamp",
    	"language",
    	"laptop",
    	"large",
    	"later",
    	"latin",
    	"laugh",
    	"laundry",
    	"lava",
    	"law",
    	"lawn",
    	"lawsuit",
    	"layer",
    	"lazy",
    	"leader",
    	"leaf",
    	"learn",
    	"leave",
    	"lecture",
    	"left",
    	"leg",
    	"legal",
    	"legend",
    	"leisure",
    	"lemon",
    	"lend",
    	"length",
    	"lens",
    	"leopard",
    	"lesson",
    	"letter",
    	"level",
    	"liar",
    	"liberty",
    	"library",
    	"license",
    	"life",
    	"lift",
    	"light",
    	"like",
    	"limb",
    	"limit",
    	"link",
    	"lion",
    	"liquid",
    	"list",
    	"little",
    	"live",
    	"lizard",
    	"load",
    	"loan",
    	"lobster",
    	"local",
    	"lock",
    	"logic",
    	"lonely",
    	"long",
    	"loop",
    	"lottery",
    	"loud",
    	"lounge",
    	"love",
    	"loyal",
    	"lucky",
    	"luggage",
    	"lumber",
    	"lunar",
    	"lunch",
    	"luxury",
    	"lyrics",
    	"machine",
    	"mad",
    	"magic",
    	"magnet",
    	"maid",
    	"mail",
    	"main",
    	"major",
    	"make",
    	"mammal",
    	"man",
    	"manage",
    	"mandate",
    	"mango",
    	"mansion",
    	"manual",
    	"maple",
    	"marble",
    	"march",
    	"margin",
    	"marine",
    	"market",
    	"marriage",
    	"mask",
    	"mass",
    	"master",
    	"match",
    	"material",
    	"math",
    	"matrix",
    	"matter",
    	"maximum",
    	"maze",
    	"meadow",
    	"mean",
    	"measure",
    	"meat",
    	"mechanic",
    	"medal",
    	"media",
    	"melody",
    	"melt",
    	"member",
    	"memory",
    	"mention",
    	"menu",
    	"mercy",
    	"merge",
    	"merit",
    	"merry",
    	"mesh",
    	"message",
    	"metal",
    	"method",
    	"middle",
    	"midnight",
    	"milk",
    	"million",
    	"mimic",
    	"mind",
    	"minimum",
    	"minor",
    	"minute",
    	"miracle",
    	"mirror",
    	"misery",
    	"miss",
    	"mistake",
    	"mix",
    	"mixed",
    	"mixture",
    	"mobile",
    	"model",
    	"modify",
    	"mom",
    	"moment",
    	"monitor",
    	"monkey",
    	"monster",
    	"month",
    	"moon",
    	"moral",
    	"more",
    	"morning",
    	"mosquito",
    	"mother",
    	"motion",
    	"motor",
    	"mountain",
    	"mouse",
    	"move",
    	"movie",
    	"much",
    	"muffin",
    	"mule",
    	"multiply",
    	"muscle",
    	"museum",
    	"mushroom",
    	"music",
    	"must",
    	"mutual",
    	"myself",
    	"mystery",
    	"myth",
    	"naive",
    	"name",
    	"napkin",
    	"narrow",
    	"nasty",
    	"nation",
    	"nature",
    	"near",
    	"neck",
    	"need",
    	"negative",
    	"neglect",
    	"neither",
    	"nephew",
    	"nerve",
    	"nest",
    	"net",
    	"network",
    	"neutral",
    	"never",
    	"news",
    	"next",
    	"nice",
    	"night",
    	"noble",
    	"noise",
    	"nominee",
    	"noodle",
    	"normal",
    	"north",
    	"nose",
    	"notable",
    	"note",
    	"nothing",
    	"notice",
    	"novel",
    	"now",
    	"nuclear",
    	"number",
    	"nurse",
    	"nut",
    	"oak",
    	"obey",
    	"object",
    	"oblige",
    	"obscure",
    	"observe",
    	"obtain",
    	"obvious",
    	"occur",
    	"ocean",
    	"october",
    	"odor",
    	"off",
    	"offer",
    	"office",
    	"often",
    	"oil",
    	"okay",
    	"old",
    	"olive",
    	"olympic",
    	"omit",
    	"once",
    	"one",
    	"onion",
    	"online",
    	"only",
    	"open",
    	"opera",
    	"opinion",
    	"oppose",
    	"option",
    	"orange",
    	"orbit",
    	"orchard",
    	"order",
    	"ordinary",
    	"organ",
    	"orient",
    	"original",
    	"orphan",
    	"ostrich",
    	"other",
    	"outdoor",
    	"outer",
    	"output",
    	"outside",
    	"oval",
    	"oven",
    	"over",
    	"own",
    	"owner",
    	"oxygen",
    	"oyster",
    	"ozone",
    	"pact",
    	"paddle",
    	"page",
    	"pair",
    	"palace",
    	"palm",
    	"panda",
    	"panel",
    	"panic",
    	"panther",
    	"paper",
    	"parade",
    	"parent",
    	"park",
    	"parrot",
    	"party",
    	"pass",
    	"patch",
    	"path",
    	"patient",
    	"patrol",
    	"pattern",
    	"pause",
    	"pave",
    	"payment",
    	"peace",
    	"peanut",
    	"pear",
    	"peasant",
    	"pelican",
    	"pen",
    	"penalty",
    	"pencil",
    	"people",
    	"pepper",
    	"perfect",
    	"permit",
    	"person",
    	"pet",
    	"phone",
    	"photo",
    	"phrase",
    	"physical",
    	"piano",
    	"picnic",
    	"picture",
    	"piece",
    	"pig",
    	"pigeon",
    	"pill",
    	"pilot",
    	"pink",
    	"pioneer",
    	"pipe",
    	"pistol",
    	"pitch",
    	"pizza",
    	"place",
    	"planet",
    	"plastic",
    	"plate",
    	"play",
    	"please",
    	"pledge",
    	"pluck",
    	"plug",
    	"plunge",
    	"poem",
    	"poet",
    	"point",
    	"polar",
    	"pole",
    	"police",
    	"pond",
    	"pony",
    	"pool",
    	"popular",
    	"portion",
    	"position",
    	"possible",
    	"post",
    	"potato",
    	"pottery",
    	"poverty",
    	"powder",
    	"power",
    	"practice",
    	"praise",
    	"predict",
    	"prefer",
    	"prepare",
    	"present",
    	"pretty",
    	"prevent",
    	"price",
    	"pride",
    	"primary",
    	"print",
    	"priority",
    	"prison",
    	"private",
    	"prize",
    	"problem",
    	"process",
    	"produce",
    	"profit",
    	"program",
    	"project",
    	"promote",
    	"proof",
    	"property",
    	"prosper",
    	"protect",
    	"proud",
    	"provide",
    	"public",
    	"pudding",
    	"pull",
    	"pulp",
    	"pulse",
    	"pumpkin",
    	"punch",
    	"pupil",
    	"puppy",
    	"purchase",
    	"purity",
    	"purpose",
    	"purse",
    	"push",
    	"put",
    	"puzzle",
    	"pyramid",
    	"quality",
    	"quantum",
    	"quarter",
    	"question",
    	"quick",
    	"quit",
    	"quiz",
    	"quote",
    	"rabbit",
    	"raccoon",
    	"race",
    	"rack",
    	"radar",
    	"radio",
    	"rail",
    	"rain",
    	"raise",
    	"rally",
    	"ramp",
    	"ranch",
    	"random",
    	"range",
    	"rapid",
    	"rare",
    	"rate",
    	"rather",
    	"raven",
    	"raw",
    	"razor",
    	"ready",
    	"real",
    	"reason",
    	"rebel",
    	"rebuild",
    	"recall",
    	"receive",
    	"recipe",
    	"record",
    	"recycle",
    	"reduce",
    	"reflect",
    	"reform",
    	"refuse",
    	"region",
    	"regret",
    	"regular",
    	"reject",
    	"relax",
    	"release",
    	"relief",
    	"rely",
    	"remain",
    	"remember",
    	"remind",
    	"remove",
    	"render",
    	"renew",
    	"rent",
    	"reopen",
    	"repair",
    	"repeat",
    	"replace",
    	"report",
    	"require",
    	"rescue",
    	"resemble",
    	"resist",
    	"resource",
    	"response",
    	"result",
    	"retire",
    	"retreat",
    	"return",
    	"reunion",
    	"reveal",
    	"review",
    	"reward",
    	"rhythm",
    	"rib",
    	"ribbon",
    	"rice",
    	"rich",
    	"ride",
    	"ridge",
    	"rifle",
    	"right",
    	"rigid",
    	"ring",
    	"riot",
    	"ripple",
    	"risk",
    	"ritual",
    	"rival",
    	"river",
    	"road",
    	"roast",
    	"robot",
    	"robust",
    	"rocket",
    	"romance",
    	"roof",
    	"rookie",
    	"room",
    	"rose",
    	"rotate",
    	"rough",
    	"round",
    	"route",
    	"royal",
    	"rubber",
    	"rude",
    	"rug",
    	"rule",
    	"run",
    	"runway",
    	"rural",
    	"sad",
    	"saddle",
    	"sadness",
    	"safe",
    	"sail",
    	"salad",
    	"salmon",
    	"salon",
    	"salt",
    	"salute",
    	"same",
    	"sample",
    	"sand",
    	"satisfy",
    	"satoshi",
    	"sauce",
    	"sausage",
    	"save",
    	"say",
    	"scale",
    	"scan",
    	"scare",
    	"scatter",
    	"scene",
    	"scheme",
    	"school",
    	"science",
    	"scissors",
    	"scorpion",
    	"scout",
    	"scrap",
    	"screen",
    	"script",
    	"scrub",
    	"sea",
    	"search",
    	"season",
    	"seat",
    	"second",
    	"secret",
    	"section",
    	"security",
    	"seed",
    	"seek",
    	"segment",
    	"select",
    	"sell",
    	"seminar",
    	"senior",
    	"sense",
    	"sentence",
    	"series",
    	"service",
    	"session",
    	"settle",
    	"setup",
    	"seven",
    	"shadow",
    	"shaft",
    	"shallow",
    	"share",
    	"shed",
    	"shell",
    	"sheriff",
    	"shield",
    	"shift",
    	"shine",
    	"ship",
    	"shiver",
    	"shock",
    	"shoe",
    	"shoot",
    	"shop",
    	"short",
    	"shoulder",
    	"shove",
    	"shrimp",
    	"shrug",
    	"shuffle",
    	"shy",
    	"sibling",
    	"sick",
    	"side",
    	"siege",
    	"sight",
    	"sign",
    	"silent",
    	"silk",
    	"silly",
    	"silver",
    	"similar",
    	"simple",
    	"since",
    	"sing",
    	"siren",
    	"sister",
    	"situate",
    	"six",
    	"size",
    	"skate",
    	"sketch",
    	"ski",
    	"skill",
    	"skin",
    	"skirt",
    	"skull",
    	"slab",
    	"slam",
    	"sleep",
    	"slender",
    	"slice",
    	"slide",
    	"slight",
    	"slim",
    	"slogan",
    	"slot",
    	"slow",
    	"slush",
    	"small",
    	"smart",
    	"smile",
    	"smoke",
    	"smooth",
    	"snack",
    	"snake",
    	"snap",
    	"sniff",
    	"snow",
    	"soap",
    	"soccer",
    	"social",
    	"sock",
    	"soda",
    	"soft",
    	"solar",
    	"soldier",
    	"solid",
    	"solution",
    	"solve",
    	"someone",
    	"song",
    	"soon",
    	"sorry",
    	"sort",
    	"soul",
    	"sound",
    	"soup",
    	"source",
    	"south",
    	"space",
    	"spare",
    	"spatial",
    	"spawn",
    	"speak",
    	"special",
    	"speed",
    	"spell",
    	"spend",
    	"sphere",
    	"spice",
    	"spider",
    	"spike",
    	"spin",
    	"spirit",
    	"split",
    	"spoil",
    	"sponsor",
    	"spoon",
    	"sport",
    	"spot",
    	"spray",
    	"spread",
    	"spring",
    	"spy",
    	"square",
    	"squeeze",
    	"squirrel",
    	"stable",
    	"stadium",
    	"staff",
    	"stage",
    	"stairs",
    	"stamp",
    	"stand",
    	"start",
    	"state",
    	"stay",
    	"steak",
    	"steel",
    	"stem",
    	"step",
    	"stereo",
    	"stick",
    	"still",
    	"sting",
    	"stock",
    	"stomach",
    	"stone",
    	"stool",
    	"story",
    	"stove",
    	"strategy",
    	"street",
    	"strike",
    	"strong",
    	"struggle",
    	"student",
    	"stuff",
    	"stumble",
    	"style",
    	"subject",
    	"submit",
    	"subway",
    	"success",
    	"such",
    	"sudden",
    	"suffer",
    	"sugar",
    	"suggest",
    	"suit",
    	"summer",
    	"sun",
    	"sunny",
    	"sunset",
    	"super",
    	"supply",
    	"supreme",
    	"sure",
    	"surface",
    	"surge",
    	"surprise",
    	"surround",
    	"survey",
    	"suspect",
    	"sustain",
    	"swallow",
    	"swamp",
    	"swap",
    	"swarm",
    	"swear",
    	"sweet",
    	"swift",
    	"swim",
    	"swing",
    	"switch",
    	"sword",
    	"symbol",
    	"symptom",
    	"syrup",
    	"system",
    	"table",
    	"tackle",
    	"tag",
    	"tail",
    	"talent",
    	"talk",
    	"tank",
    	"tape",
    	"target",
    	"task",
    	"taste",
    	"tattoo",
    	"taxi",
    	"teach",
    	"team",
    	"tell",
    	"ten",
    	"tenant",
    	"tennis",
    	"tent",
    	"term",
    	"test",
    	"text",
    	"thank",
    	"that",
    	"theme",
    	"then",
    	"theory",
    	"there",
    	"they",
    	"thing",
    	"this",
    	"thought",
    	"three",
    	"thrive",
    	"throw",
    	"thumb",
    	"thunder",
    	"ticket",
    	"tide",
    	"tiger",
    	"tilt",
    	"timber",
    	"time",
    	"tiny",
    	"tip",
    	"tired",
    	"tissue",
    	"title",
    	"toast",
    	"tobacco",
    	"today",
    	"toddler",
    	"toe",
    	"together",
    	"toilet",
    	"token",
    	"tomato",
    	"tomorrow",
    	"tone",
    	"tongue",
    	"tonight",
    	"tool",
    	"tooth",
    	"top",
    	"topic",
    	"topple",
    	"torch",
    	"tornado",
    	"tortoise",
    	"toss",
    	"total",
    	"tourist",
    	"toward",
    	"tower",
    	"town",
    	"toy",
    	"track",
    	"trade",
    	"traffic",
    	"tragic",
    	"train",
    	"transfer",
    	"trap",
    	"trash",
    	"travel",
    	"tray",
    	"treat",
    	"tree",
    	"trend",
    	"trial",
    	"tribe",
    	"trick",
    	"trigger",
    	"trim",
    	"trip",
    	"trophy",
    	"trouble",
    	"truck",
    	"true",
    	"truly",
    	"trumpet",
    	"trust",
    	"truth",
    	"try",
    	"tube",
    	"tuition",
    	"tumble",
    	"tuna",
    	"tunnel",
    	"turkey",
    	"turn",
    	"turtle",
    	"twelve",
    	"twenty",
    	"twice",
    	"twin",
    	"twist",
    	"two",
    	"type",
    	"typical",
    	"ugly",
    	"umbrella",
    	"unable",
    	"unaware",
    	"uncle",
    	"uncover",
    	"under",
    	"undo",
    	"unfair",
    	"unfold",
    	"unhappy",
    	"uniform",
    	"unique",
    	"unit",
    	"universe",
    	"unknown",
    	"unlock",
    	"until",
    	"unusual",
    	"unveil",
    	"update",
    	"upgrade",
    	"uphold",
    	"upon",
    	"upper",
    	"upset",
    	"urban",
    	"urge",
    	"usage",
    	"use",
    	"used",
    	"useful",
    	"useless",
    	"usual",
    	"utility",
    	"vacant",
    	"vacuum",
    	"vague",
    	"valid",
    	"valley",
    	"valve",
    	"van",
    	"vanish",
    	"vapor",
    	"various",
    	"vast",
    	"vault",
    	"vehicle",
    	"velvet",
    	"vendor",
    	"venture",
    	"venue",
    	"verb",
    	"verify",
    	"version",
    	"very",
    	"vessel",
    	"veteran",
    	"viable",
    	"vibrant",
    	"vicious",
    	"victory",
    	"video",
    	"view",
    	"village",
    	"vintage",
    	"violin",
    	"virtual",
    	"virus",
    	"visa",
    	"visit",
    	"visual",
    	"vital",
    	"vivid",
    	"vocal",
    	"voice",
    	"void",
    	"volcano",
    	"volume",
    	"vote",
    	"voyage",
    	"wage",
    	"wagon",
    	"wait",
    	"walk",
    	"wall",
    	"walnut",
    	"want",
    	"warfare",
    	"warm",
    	"warrior",
    	"wash",
    	"wasp",
    	"waste",
    	"water",
    	"wave",
    	"way",
    	"wealth",
    	"weapon",
    	"wear",
    	"weasel",
    	"weather",
    	"web",
    	"wedding",
    	"weekend",
    	"weird",
    	"welcome",
    	"west",
    	"wet",
    	"whale",
    	"what",
    	"wheat",
    	"wheel",
    	"when",
    	"where",
    	"whip",
    	"whisper",
    	"wide",
    	"width",
    	"wife",
    	"wild",
    	"will",
    	"win",
    	"window",
    	"wine",
    	"wing",
    	"wink",
    	"winner",
    	"winter",
    	"wire",
    	"wisdom",
    	"wise",
    	"wish",
    	"witness",
    	"wolf",
    	"woman",
    	"wonder",
    	"wood",
    	"wool",
    	"word",
    	"work",
    	"world",
    	"worry",
    	"worth",
    	"wrap",
    	"wreck",
    	"wrestle",
    	"wrist",
    	"write",
    	"wrong",
    	"yard",
    	"year",
    	"yellow",
    	"you",
    	"young",
    	"youth",
    	"zebra",
    	"zero",
    	"zone",
    	"zoo"
    ];

    var _wordlists = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    // browserify by default only pulls in files that are hard coded in requires
    // In order of last to first in this file, the default wordlist will be chosen
    // based on what is present. (Bundles may remove wordlists they don't need)
    const wordlists = {};
    exports.wordlists = wordlists;
    let _default;
    exports._default = _default;
    try {
        exports._default = _default = require$$0$2;
        wordlists.czech = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$1$1;
        wordlists.chinese_simplified = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$2$1;
        wordlists.chinese_traditional = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$3;
        wordlists.korean = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$4;
        wordlists.french = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$5;
        wordlists.italian = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$6;
        wordlists.spanish = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$7;
        wordlists.japanese = _default;
        wordlists.JA = _default;
    }
    catch (err) { }
    try {
        exports._default = _default = require$$8;
        wordlists.english = _default;
        wordlists.EN = _default;
    }
    catch (err) { }
    });

    let DEFAULT_WORDLIST = _wordlists._default;
    const INVALID_MNEMONIC = 'Invalid mnemonic';
    const INVALID_ENTROPY = 'Invalid entropy';
    const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
    const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
        'Please explicitly pass a 2048 word array explicitly.';
    function normalize(str) {
        return (str || '').normalize('NFKD');
    }
    function lpad(str, padString, length) {
        while (str.length < length) {
            str = padString + str;
        }
        return str;
    }
    function binaryToByte(bin) {
        return parseInt(bin, 2);
    }
    function bytesToBinary(bytes) {
        return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
    }
    function deriveChecksumBits(entropyBuffer) {
        const ENT = entropyBuffer.length * 8;
        const CS = ENT / 32;
        const hash = browser$2('sha256')
            .update(entropyBuffer)
            .digest();
        return bytesToBinary(Array.from(hash)).slice(0, CS);
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
        wordlist = wordlist || DEFAULT_WORDLIST;
        if (!wordlist) {
            throw new Error(WORDLIST_REQUIRED);
        }
        const words = normalize(mnemonic).split(' ');
        if (words.length % 3 !== 0) {
            throw new Error(INVALID_MNEMONIC);
        }
        // convert word indices to 11 bit binary strings
        const bits = words
            .map((word) => {
            const index = wordlist.indexOf(word);
            if (index === -1) {
                throw new Error(INVALID_MNEMONIC);
            }
            return lpad(index.toString(2), '0', 11);
        })
            .join('');
        // split the binary string into ENT/CS
        const dividerIndex = Math.floor(bits.length / 33) * 32;
        const entropyBits = bits.slice(0, dividerIndex);
        const checksumBits = bits.slice(dividerIndex);
        // calculate the checksum and compare
        const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
        if (entropyBytes.length < 16) {
            throw new Error(INVALID_ENTROPY);
        }
        if (entropyBytes.length > 32) {
            throw new Error(INVALID_ENTROPY);
        }
        if (entropyBytes.length % 4 !== 0) {
            throw new Error(INVALID_ENTROPY);
        }
        const entropy = Buffer.from(entropyBytes);
        const newChecksum = deriveChecksumBits(entropy);
        if (newChecksum !== checksumBits) {
            throw new Error(INVALID_CHECKSUM);
        }
        return entropy.toString('hex');
    }
    function entropyToMnemonic(entropy, wordlist) {
        if (!isBuffer(entropy)) {
            entropy = Buffer.from(entropy, 'hex');
        }
        wordlist = wordlist || DEFAULT_WORDLIST;
        if (!wordlist) {
            throw new Error(WORDLIST_REQUIRED);
        }
        // 128 <= ENT <= 256
        if (entropy.length < 16) {
            throw new TypeError(INVALID_ENTROPY);
        }
        if (entropy.length > 32) {
            throw new TypeError(INVALID_ENTROPY);
        }
        if (entropy.length % 4 !== 0) {
            throw new TypeError(INVALID_ENTROPY);
        }
        const entropyBits = bytesToBinary(Array.from(entropy));
        const checksumBits = deriveChecksumBits(entropy);
        const bits = entropyBits + checksumBits;
        const chunks = bits.match(/(.{1,11})/g);
        const words = chunks.map((binary) => {
            const index = binaryToByte(binary);
            return wordlist[index];
        });
        return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
            ? words.join('\u3000')
            : words.join(' ');
    }
    function generateMnemonic(strength, rng, wordlist) {
        strength = strength || 128;
        if (strength % 32 !== 0) {
            throw new TypeError(INVALID_ENTROPY);
        }
        rng = rng || browser$3;
        return entropyToMnemonic(rng(strength / 8), wordlist);
    }
    var generateMnemonic_1 = generateMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
        try {
            mnemonicToEntropy(mnemonic, wordlist);
        }
        catch (e) {
            return false;
        }
        return true;
    }
    var validateMnemonic_1 = validateMnemonic;
    var _wordlists_2 = _wordlists;
    var wordlists = _wordlists_2.wordlists;

    var empty$1 = {};

    var empty$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': empty$1
    });

    var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(empty$2);

    var naclFast = createCommonjsModule(function (module) {
    (function(nacl) {

    // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
    // Public domain.
    //
    // Implementation derived from TweetNaCl version 20140427.
    // See for details: http://tweetnacl.cr.yp.to/

    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };

    //  Pluggable, initialized in high-level API below.
    var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32); _9[0] = 9;

    var gf0 = gf(),
        gf1 = gf([1]),
        _121665 = gf([0xdb41, 1]),
        D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
        D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
        X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
        Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
        I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

    function ts64(x, i, h, l) {
      x[i]   = (h >> 24) & 0xff;
      x[i+1] = (h >> 16) & 0xff;
      x[i+2] = (h >>  8) & 0xff;
      x[i+3] = h & 0xff;
      x[i+4] = (l >> 24)  & 0xff;
      x[i+5] = (l >> 16)  & 0xff;
      x[i+6] = (l >>  8)  & 0xff;
      x[i+7] = l & 0xff;
    }

    function vn(x, xi, y, yi, n) {
      var i,d = 0;
      for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
      return (1 & ((d - 1) >>> 8)) - 1;
    }

    function crypto_verify_16(x, xi, y, yi) {
      return vn(x,xi,y,yi,16);
    }

    function crypto_verify_32(x, xi, y, yi) {
      return vn(x,xi,y,yi,32);
    }

    function core_salsa20(o, p, k, c) {
      var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
          j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
          j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
          j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
          j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
          j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
          j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
          j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
          j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
          j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
          j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
          j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
          j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
          j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
          j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
          j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
          x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
          x15 = j15, u;

      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u<<7 | u>>>(32-7);
        u = x4 + x0 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x4 | 0;
        x12 ^= u<<13 | u>>>(32-13);
        u = x12 + x8 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x1 | 0;
        x9 ^= u<<7 | u>>>(32-7);
        u = x9 + x5 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x9 | 0;
        x1 ^= u<<13 | u>>>(32-13);
        u = x1 + x13 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x6 | 0;
        x14 ^= u<<7 | u>>>(32-7);
        u = x14 + x10 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x14 | 0;
        x6 ^= u<<13 | u>>>(32-13);
        u = x6 + x2 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x11 | 0;
        x3 ^= u<<7 | u>>>(32-7);
        u = x3 + x15 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x3 | 0;
        x11 ^= u<<13 | u>>>(32-13);
        u = x11 + x7 | 0;
        x15 ^= u<<18 | u>>>(32-18);

        u = x0 + x3 | 0;
        x1 ^= u<<7 | u>>>(32-7);
        u = x1 + x0 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x1 | 0;
        x3 ^= u<<13 | u>>>(32-13);
        u = x3 + x2 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x4 | 0;
        x6 ^= u<<7 | u>>>(32-7);
        u = x6 + x5 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x6 | 0;
        x4 ^= u<<13 | u>>>(32-13);
        u = x4 + x7 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x9 | 0;
        x11 ^= u<<7 | u>>>(32-7);
        u = x11 + x10 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x11 | 0;
        x9 ^= u<<13 | u>>>(32-13);
        u = x9 + x8 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x14 | 0;
        x12 ^= u<<7 | u>>>(32-7);
        u = x12 + x15 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x12 | 0;
        x14 ^= u<<13 | u>>>(32-13);
        u = x14 + x13 | 0;
        x15 ^= u<<18 | u>>>(32-18);
      }
       x0 =  x0 +  j0 | 0;
       x1 =  x1 +  j1 | 0;
       x2 =  x2 +  j2 | 0;
       x3 =  x3 +  j3 | 0;
       x4 =  x4 +  j4 | 0;
       x5 =  x5 +  j5 | 0;
       x6 =  x6 +  j6 | 0;
       x7 =  x7 +  j7 | 0;
       x8 =  x8 +  j8 | 0;
       x9 =  x9 +  j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;

      o[ 0] = x0 >>>  0 & 0xff;
      o[ 1] = x0 >>>  8 & 0xff;
      o[ 2] = x0 >>> 16 & 0xff;
      o[ 3] = x0 >>> 24 & 0xff;

      o[ 4] = x1 >>>  0 & 0xff;
      o[ 5] = x1 >>>  8 & 0xff;
      o[ 6] = x1 >>> 16 & 0xff;
      o[ 7] = x1 >>> 24 & 0xff;

      o[ 8] = x2 >>>  0 & 0xff;
      o[ 9] = x2 >>>  8 & 0xff;
      o[10] = x2 >>> 16 & 0xff;
      o[11] = x2 >>> 24 & 0xff;

      o[12] = x3 >>>  0 & 0xff;
      o[13] = x3 >>>  8 & 0xff;
      o[14] = x3 >>> 16 & 0xff;
      o[15] = x3 >>> 24 & 0xff;

      o[16] = x4 >>>  0 & 0xff;
      o[17] = x4 >>>  8 & 0xff;
      o[18] = x4 >>> 16 & 0xff;
      o[19] = x4 >>> 24 & 0xff;

      o[20] = x5 >>>  0 & 0xff;
      o[21] = x5 >>>  8 & 0xff;
      o[22] = x5 >>> 16 & 0xff;
      o[23] = x5 >>> 24 & 0xff;

      o[24] = x6 >>>  0 & 0xff;
      o[25] = x6 >>>  8 & 0xff;
      o[26] = x6 >>> 16 & 0xff;
      o[27] = x6 >>> 24 & 0xff;

      o[28] = x7 >>>  0 & 0xff;
      o[29] = x7 >>>  8 & 0xff;
      o[30] = x7 >>> 16 & 0xff;
      o[31] = x7 >>> 24 & 0xff;

      o[32] = x8 >>>  0 & 0xff;
      o[33] = x8 >>>  8 & 0xff;
      o[34] = x8 >>> 16 & 0xff;
      o[35] = x8 >>> 24 & 0xff;

      o[36] = x9 >>>  0 & 0xff;
      o[37] = x9 >>>  8 & 0xff;
      o[38] = x9 >>> 16 & 0xff;
      o[39] = x9 >>> 24 & 0xff;

      o[40] = x10 >>>  0 & 0xff;
      o[41] = x10 >>>  8 & 0xff;
      o[42] = x10 >>> 16 & 0xff;
      o[43] = x10 >>> 24 & 0xff;

      o[44] = x11 >>>  0 & 0xff;
      o[45] = x11 >>>  8 & 0xff;
      o[46] = x11 >>> 16 & 0xff;
      o[47] = x11 >>> 24 & 0xff;

      o[48] = x12 >>>  0 & 0xff;
      o[49] = x12 >>>  8 & 0xff;
      o[50] = x12 >>> 16 & 0xff;
      o[51] = x12 >>> 24 & 0xff;

      o[52] = x13 >>>  0 & 0xff;
      o[53] = x13 >>>  8 & 0xff;
      o[54] = x13 >>> 16 & 0xff;
      o[55] = x13 >>> 24 & 0xff;

      o[56] = x14 >>>  0 & 0xff;
      o[57] = x14 >>>  8 & 0xff;
      o[58] = x14 >>> 16 & 0xff;
      o[59] = x14 >>> 24 & 0xff;

      o[60] = x15 >>>  0 & 0xff;
      o[61] = x15 >>>  8 & 0xff;
      o[62] = x15 >>> 16 & 0xff;
      o[63] = x15 >>> 24 & 0xff;
    }

    function core_hsalsa20(o,p,k,c) {
      var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
          j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
          j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
          j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
          j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
          j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
          j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
          j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
          j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
          j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
          j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
          j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
          j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
          j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
          j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
          j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
          x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
          x15 = j15, u;

      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u<<7 | u>>>(32-7);
        u = x4 + x0 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x4 | 0;
        x12 ^= u<<13 | u>>>(32-13);
        u = x12 + x8 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x1 | 0;
        x9 ^= u<<7 | u>>>(32-7);
        u = x9 + x5 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x9 | 0;
        x1 ^= u<<13 | u>>>(32-13);
        u = x1 + x13 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x6 | 0;
        x14 ^= u<<7 | u>>>(32-7);
        u = x14 + x10 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x14 | 0;
        x6 ^= u<<13 | u>>>(32-13);
        u = x6 + x2 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x11 | 0;
        x3 ^= u<<7 | u>>>(32-7);
        u = x3 + x15 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x3 | 0;
        x11 ^= u<<13 | u>>>(32-13);
        u = x11 + x7 | 0;
        x15 ^= u<<18 | u>>>(32-18);

        u = x0 + x3 | 0;
        x1 ^= u<<7 | u>>>(32-7);
        u = x1 + x0 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x1 | 0;
        x3 ^= u<<13 | u>>>(32-13);
        u = x3 + x2 | 0;
        x0 ^= u<<18 | u>>>(32-18);

        u = x5 + x4 | 0;
        x6 ^= u<<7 | u>>>(32-7);
        u = x6 + x5 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x6 | 0;
        x4 ^= u<<13 | u>>>(32-13);
        u = x4 + x7 | 0;
        x5 ^= u<<18 | u>>>(32-18);

        u = x10 + x9 | 0;
        x11 ^= u<<7 | u>>>(32-7);
        u = x11 + x10 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x11 | 0;
        x9 ^= u<<13 | u>>>(32-13);
        u = x9 + x8 | 0;
        x10 ^= u<<18 | u>>>(32-18);

        u = x15 + x14 | 0;
        x12 ^= u<<7 | u>>>(32-7);
        u = x12 + x15 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x12 | 0;
        x14 ^= u<<13 | u>>>(32-13);
        u = x14 + x13 | 0;
        x15 ^= u<<18 | u>>>(32-18);
      }

      o[ 0] = x0 >>>  0 & 0xff;
      o[ 1] = x0 >>>  8 & 0xff;
      o[ 2] = x0 >>> 16 & 0xff;
      o[ 3] = x0 >>> 24 & 0xff;

      o[ 4] = x5 >>>  0 & 0xff;
      o[ 5] = x5 >>>  8 & 0xff;
      o[ 6] = x5 >>> 16 & 0xff;
      o[ 7] = x5 >>> 24 & 0xff;

      o[ 8] = x10 >>>  0 & 0xff;
      o[ 9] = x10 >>>  8 & 0xff;
      o[10] = x10 >>> 16 & 0xff;
      o[11] = x10 >>> 24 & 0xff;

      o[12] = x15 >>>  0 & 0xff;
      o[13] = x15 >>>  8 & 0xff;
      o[14] = x15 >>> 16 & 0xff;
      o[15] = x15 >>> 24 & 0xff;

      o[16] = x6 >>>  0 & 0xff;
      o[17] = x6 >>>  8 & 0xff;
      o[18] = x6 >>> 16 & 0xff;
      o[19] = x6 >>> 24 & 0xff;

      o[20] = x7 >>>  0 & 0xff;
      o[21] = x7 >>>  8 & 0xff;
      o[22] = x7 >>> 16 & 0xff;
      o[23] = x7 >>> 24 & 0xff;

      o[24] = x8 >>>  0 & 0xff;
      o[25] = x8 >>>  8 & 0xff;
      o[26] = x8 >>> 16 & 0xff;
      o[27] = x8 >>> 24 & 0xff;

      o[28] = x9 >>>  0 & 0xff;
      o[29] = x9 >>>  8 & 0xff;
      o[30] = x9 >>> 16 & 0xff;
      o[31] = x9 >>> 24 & 0xff;
    }

    function crypto_core_salsa20(out,inp,k,c) {
      core_salsa20(out,inp,k,c);
    }

    function crypto_core_hsalsa20(out,inp,k,c) {
      core_hsalsa20(out,inp,k,c);
    }

    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
                // "expand 32-byte k"

    function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
      }
      return 0;
    }

    function crypto_stream_salsa20(c,cpos,b,n,k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < 64; i++) c[cpos+i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < b; i++) c[cpos+i] = x[i];
      }
      return 0;
    }

    function crypto_stream(c,cpos,d,n,k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s,n,k,sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i+16];
      return crypto_stream_salsa20(c,cpos,d,sn,s);
    }

    function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s,n,k,sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i+16];
      return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
    }

    /*
    * Port of Andrew Moon's Poly1305-donna-16. Public domain.
    * https://github.com/floodyberry/poly1305-donna
    */

    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;

      var t0, t1, t2, t3, t4, t5, t6, t7;

      t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
      t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
      t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
      t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
      t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
      this.r[5] = ((t4 >>>  1)) & 0x1ffe;
      t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
      t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
      t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
      this.r[9] = ((t7 >>>  5)) & 0x007f;

      this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
      this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
      this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
      this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
      this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
      this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
      this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
      this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    };

    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : (1 << 11);
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

      var h0 = this.h[0],
          h1 = this.h[1],
          h2 = this.h[2],
          h3 = this.h[3],
          h4 = this.h[4],
          h5 = this.h[5],
          h6 = this.h[6],
          h7 = this.h[7],
          h8 = this.h[8],
          h9 = this.h[9];

      var r0 = this.r[0],
          r1 = this.r[1],
          r2 = this.r[2],
          r3 = this.r[3],
          r4 = this.r[4],
          r5 = this.r[5],
          r6 = this.r[6],
          r7 = this.r[7],
          r8 = this.r[8],
          r9 = this.r[9];

      while (bytes >= 16) {
        t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
        t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
        t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
        t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
        t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
        h5 += ((t4 >>>  1)) & 0x1fff;
        t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
        t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
        t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
        h9 += ((t7 >>> 5)) | hibit;

        c = 0;

        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = (d0 >>> 13); d0 &= 0x1fff;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += (d0 >>> 13); d0 &= 0x1fff;

        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = (d1 >>> 13); d1 &= 0x1fff;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += (d1 >>> 13); d1 &= 0x1fff;

        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = (d2 >>> 13); d2 &= 0x1fff;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += (d2 >>> 13); d2 &= 0x1fff;

        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = (d3 >>> 13); d3 &= 0x1fff;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += (d3 >>> 13); d3 &= 0x1fff;

        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = (d4 >>> 13); d4 &= 0x1fff;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += (d4 >>> 13); d4 &= 0x1fff;

        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = (d5 >>> 13); d5 &= 0x1fff;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += (d5 >>> 13); d5 &= 0x1fff;

        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = (d6 >>> 13); d6 &= 0x1fff;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += (d6 >>> 13); d6 &= 0x1fff;

        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = (d7 >>> 13); d7 &= 0x1fff;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += (d7 >>> 13); d7 &= 0x1fff;

        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = (d8 >>> 13); d8 &= 0x1fff;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += (d8 >>> 13); d8 &= 0x1fff;

        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = (d9 >>> 13); d9 &= 0x1fff;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += (d9 >>> 13); d9 &= 0x1fff;

        c = (((c << 2) + c)) | 0;
        c = (c + d0) | 0;
        d0 = c & 0x1fff;
        c = (c >>> 13);
        d1 += c;

        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;

        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };

    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;

      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++) this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }

      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 0x1fff;
      }
      this.h[0] += (c * 5);
      c = this.h[0] >>> 13;
      this.h[0] &= 0x1fff;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;
      this.h[2] += c;

      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 0x1fff;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 0x1fff;
      }
      g[9] -= (1 << 13);

      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++) g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

      this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
      this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
      this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
      this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
      this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
      this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
      this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
      this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

      f = this.h[0] + this.pad[0];
      this.h[0] = f & 0xffff;
      for (i = 1; i < 8; i++) {
        f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
        this.h[i] = f & 0xffff;
      }

      mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
      mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
      mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
      mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
      mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
      mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
      mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
      mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
      mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
      mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
      mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
      mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
      mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
      mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
      mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
      mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
    };

    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;

      if (this.leftover) {
        want = (16 - this.leftover);
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m[mpos+i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }

      if (bytes >= 16) {
        want = bytes - (bytes % 16);
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }

      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos+i];
        this.leftover += bytes;
      }
    };

    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }

    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x,0,m,mpos,n,k);
      return crypto_verify_16(h,hpos,x,0);
    }

    function crypto_secretbox(c,m,d,n,k) {
      var i;
      if (d < 32) return -1;
      crypto_stream_xor(c,0,m,0,d,n,k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++) c[i] = 0;
      return 0;
    }

    function crypto_secretbox_open(m,c,d,n,k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32) return -1;
      crypto_stream(x,0,32,n,k);
      if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
      crypto_stream_xor(m,0,c,0,d,n,k);
      for (i = 0; i < 32; i++) m[i] = 0;
      return 0;
    }

    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) r[i] = a[i]|0;
    }

    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c-1 + 37 * (c-1);
    }

    function sel25519(p, q, b) {
      var t, c = ~(b-1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }

    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
          m[i-1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
        b = (m[15]>>16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1-b);
      }
      for (i = 0; i < 16; i++) {
        o[2*i] = t[i] & 0xff;
        o[2*i+1] = t[i]>>8;
      }
    }

    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }

    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }

    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
      o[15] &= 0x7fff;
    }

    function A(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }

    function Z(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }

    function M(o, a, b) {
      var v, c,
         t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
         t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
        t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
        t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
        b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11],
        b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];

      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;

      t0  += 38 * t16;
      t1  += 38 * t17;
      t2  += 38 * t18;
      t3  += 38 * t19;
      t4  += 38 * t20;
      t5  += 38 * t21;
      t6  += 38 * t22;
      t7  += 38 * t23;
      t8  += 38 * t24;
      t9  += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      // t15 left as is

      // first car
      c = 1;
      v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
      v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
      v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
      v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
      v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
      v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
      v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
      v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
      v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
      v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
      v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
      v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
      v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
      v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
      v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
      v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
      t0 += c-1 + 37 * (c-1);

      // second car
      c = 1;
      v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
      v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
      v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
      v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
      v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
      v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
      v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
      v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
      v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
      v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
      v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
      v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
      v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
      v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
      v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
      v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
      t0 += c-1 + 37 * (c-1);

      o[ 0] = t0;
      o[ 1] = t1;
      o[ 2] = t2;
      o[ 3] = t3;
      o[ 4] = t4;
      o[ 5] = t5;
      o[ 6] = t6;
      o[ 7] = t7;
      o[ 8] = t8;
      o[ 9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }

    function S(o, a) {
      M(o, a, a);
    }

    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if(a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }

    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 250; a >= 0; a--) {
          S(c, c);
          if(a !== 1) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }

    function crypto_scalarmult(q, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(),
          d = gf(), e = gf(), f = gf();
      for (i = 0; i < 31; i++) z[i] = n[i];
      z[31]=(n[31]&127)|64;
      z[0]&=248;
      unpack25519(x,p);
      for (i = 0; i < 16; i++) {
        b[i]=x[i];
        d[i]=a[i]=c[i]=0;
      }
      a[0]=d[0]=1;
      for (i=254; i>=0; --i) {
        r=(z[i>>>3]>>>(i&7))&1;
        sel25519(a,b,r);
        sel25519(c,d,r);
        A(e,a,c);
        Z(a,a,c);
        A(c,b,d);
        Z(b,b,d);
        S(d,e);
        S(f,a);
        M(a,c,a);
        M(c,b,e);
        A(e,a,c);
        Z(a,a,c);
        S(b,a);
        Z(c,d,f);
        M(a,c,_121665);
        A(a,a,d);
        M(c,c,a);
        M(a,d,f);
        M(d,b,x);
        S(b,e);
        sel25519(a,b,r);
        sel25519(c,d,r);
      }
      for (i = 0; i < 16; i++) {
        x[i+16]=a[i];
        x[i+32]=c[i];
        x[i+48]=b[i];
        x[i+64]=d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32,x32);
      M(x16,x16,x32);
      pack25519(q,x16);
      return 0;
    }

    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }

    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }

    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }

    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;

    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }

    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }

    var K = [
      0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
      0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
      0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
      0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
      0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
      0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
      0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
      0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
      0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
      0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
      0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
      0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
      0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
      0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
      0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
      0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
      0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
      0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
      0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
      0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
      0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
      0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
      0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
      0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
      0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
      0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
      0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
      0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
      0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
      0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
      0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
      0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
      0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
      0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
      0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
      0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
      0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
      0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
      0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
      0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    ];

    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16),
          bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
          bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
          th, tl, i, j, h, l, a, b, c, d;

      var ah0 = hh[0],
          ah1 = hh[1],
          ah2 = hh[2],
          ah3 = hh[3],
          ah4 = hh[4],
          ah5 = hh[5],
          ah6 = hh[6],
          ah7 = hh[7],

          al0 = hl[0],
          al1 = hl[1],
          al2 = hl[2],
          al3 = hl[3],
          al4 = hl[4],
          al5 = hl[5],
          al6 = hl[6],
          al7 = hl[7];

      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
          wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;

          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;

          // add
          h = ah7;
          l = al7;

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          // Sigma1
          h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
          l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // Ch
          h = (ah4 & ah5) ^ (~ah4 & ah6);
          l = (al4 & al5) ^ (~al4 & al6);

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // K
          h = K[i*2];
          l = K[i*2+1];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // w
          h = wh[i%16];
          l = wl[i%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          th = c & 0xffff | d << 16;
          tl = a & 0xffff | b << 16;

          // add
          h = th;
          l = tl;

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          // Sigma0
          h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
          l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // Maj
          h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
          l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          bh7 = (c & 0xffff) | (d << 16);
          bl7 = (a & 0xffff) | (b << 16);

          // add
          h = bh3;
          l = bl3;

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = th;
          l = tl;

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          bh3 = (c & 0xffff) | (d << 16);
          bl3 = (a & 0xffff) | (b << 16);

          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;

          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;

          if (i%16 === 15) {
            for (j = 0; j < 16; j++) {
              // add
              h = wh[j];
              l = wl[j];

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = wh[(j+9)%16];
              l = wl[(j+9)%16];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              // sigma0
              th = wh[(j+1)%16];
              tl = wl[(j+1)%16];
              h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
              l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              // sigma1
              th = wh[(j+14)%16];
              tl = wl[(j+14)%16];
              h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
              l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              wh[j] = (c & 0xffff) | (d << 16);
              wl[j] = (a & 0xffff) | (b << 16);
            }
          }
        }

        // add
        h = ah0;
        l = al0;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[0];
        l = hl[0];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[0] = ah0 = (c & 0xffff) | (d << 16);
        hl[0] = al0 = (a & 0xffff) | (b << 16);

        h = ah1;
        l = al1;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[1];
        l = hl[1];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[1] = ah1 = (c & 0xffff) | (d << 16);
        hl[1] = al1 = (a & 0xffff) | (b << 16);

        h = ah2;
        l = al2;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[2];
        l = hl[2];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[2] = ah2 = (c & 0xffff) | (d << 16);
        hl[2] = al2 = (a & 0xffff) | (b << 16);

        h = ah3;
        l = al3;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[3];
        l = hl[3];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[3] = ah3 = (c & 0xffff) | (d << 16);
        hl[3] = al3 = (a & 0xffff) | (b << 16);

        h = ah4;
        l = al4;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[4];
        l = hl[4];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[4] = ah4 = (c & 0xffff) | (d << 16);
        hl[4] = al4 = (a & 0xffff) | (b << 16);

        h = ah5;
        l = al5;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[5];
        l = hl[5];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[5] = ah5 = (c & 0xffff) | (d << 16);
        hl[5] = al5 = (a & 0xffff) | (b << 16);

        h = ah6;
        l = al6;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[6];
        l = hl[6];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[6] = ah6 = (c & 0xffff) | (d << 16);
        hl[6] = al6 = (a & 0xffff) | (b << 16);

        h = ah7;
        l = al7;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = hh[7];
        l = hl[7];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        hh[7] = ah7 = (c & 0xffff) | (d << 16);
        hl[7] = al7 = (a & 0xffff) | (b << 16);

        pos += 128;
        n -= 128;
      }

      return n;
    }

    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8),
          hl = new Int32Array(8),
          x = new Uint8Array(256),
          i, b = n;

      hh[0] = 0x6a09e667;
      hh[1] = 0xbb67ae85;
      hh[2] = 0x3c6ef372;
      hh[3] = 0xa54ff53a;
      hh[4] = 0x510e527f;
      hh[5] = 0x9b05688c;
      hh[6] = 0x1f83d9ab;
      hh[7] = 0x5be0cd19;

      hl[0] = 0xf3bcc908;
      hl[1] = 0x84caa73b;
      hl[2] = 0xfe94f82b;
      hl[3] = 0x5f1d36f1;
      hl[4] = 0xade682d1;
      hl[5] = 0x2b3e6c1f;
      hl[6] = 0xfb41bd6b;
      hl[7] = 0x137e2179;

      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;

      for (i = 0; i < n; i++) x[i] = m[b-n+i];
      x[n] = 128;

      n = 256-128*(n<112?1:0);
      x[n-9] = 0;
      ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);

      for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

      return 0;
    }

    function add(p, q) {
      var a = gf(), b = gf(), c = gf(),
          d = gf(), e = gf(), f = gf(),
          g = gf(), h = gf(), t = gf();

      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);

      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }

    function cswap(p, q, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }

    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }

    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = (s[(i/8)|0] >> (i&7)) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }

    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }

    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;

      if (!seeded) randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;

      scalarbase(p, d);
      pack(pk, p);

      for (i = 0; i < 32; i++) sk[i+32] = pk[i];
      return 0;
    }

    var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i+1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }

    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }

    // Note: difference from C - smlen returned, not passed as argument.
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];

      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;

      var smlen = n + 64;
      for (i = 0; i < n; i++) sm[64 + i] = m[i];
      for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

      crypto_hash(r, sm.subarray(32), n+32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);

      for (i = 32; i < 64; i++) sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);

      for (i = 0; i < 64; i++) x[i] = 0;
      for (i = 0; i < 32; i++) x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i+j] += h[i] * d[j];
        }
      }

      modL(sm.subarray(32), x);
      return smlen;
    }

    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(),
          den = gf(), den2 = gf(), den4 = gf(),
          den6 = gf();

      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);

      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);

      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);

      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) M(r[0], r[0], I);

      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) return -1;

      if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

      M(r[3], r[0], r[1]);
      return 0;
    }

    function crypto_sign_open(m, sm, n, pk) {
      var i;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()],
          q = [gf(), gf(), gf(), gf()];

      if (n < 64) return -1;

      if (unpackneg(q, pk)) return -1;

      for (i = 0; i < n; i++) m[i] = sm[i];
      for (i = 0; i < 32; i++) m[i+32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);

      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack(t, p);

      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++) m[i] = 0;
        return -1;
      }

      for (i = 0; i < n; i++) m[i] = sm[i + 64];
      return n;
    }

    var crypto_secretbox_KEYBYTES = 32,
        crypto_secretbox_NONCEBYTES = 24,
        crypto_secretbox_ZEROBYTES = 32,
        crypto_secretbox_BOXZEROBYTES = 16,
        crypto_scalarmult_BYTES = 32,
        crypto_scalarmult_SCALARBYTES = 32,
        crypto_box_PUBLICKEYBYTES = 32,
        crypto_box_SECRETKEYBYTES = 32,
        crypto_box_BEFORENMBYTES = 32,
        crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
        crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
        crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
        crypto_sign_BYTES = 64,
        crypto_sign_PUBLICKEYBYTES = 32,
        crypto_sign_SECRETKEYBYTES = 64,
        crypto_sign_SEEDBYTES = 32,
        crypto_hash_BYTES = 64;

    nacl.lowlevel = {
      crypto_core_hsalsa20: crypto_core_hsalsa20,
      crypto_stream_xor: crypto_stream_xor,
      crypto_stream: crypto_stream,
      crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
      crypto_stream_salsa20: crypto_stream_salsa20,
      crypto_onetimeauth: crypto_onetimeauth,
      crypto_onetimeauth_verify: crypto_onetimeauth_verify,
      crypto_verify_16: crypto_verify_16,
      crypto_verify_32: crypto_verify_32,
      crypto_secretbox: crypto_secretbox,
      crypto_secretbox_open: crypto_secretbox_open,
      crypto_scalarmult: crypto_scalarmult,
      crypto_scalarmult_base: crypto_scalarmult_base,
      crypto_box_beforenm: crypto_box_beforenm,
      crypto_box_afternm: crypto_box_afternm,
      crypto_box: crypto_box,
      crypto_box_open: crypto_box_open,
      crypto_box_keypair: crypto_box_keypair,
      crypto_hash: crypto_hash,
      crypto_sign: crypto_sign,
      crypto_sign_keypair: crypto_sign_keypair,
      crypto_sign_open: crypto_sign_open,

      crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES: crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
      crypto_hash_BYTES: crypto_hash_BYTES,

      gf: gf,
      D: D,
      L: L,
      pack25519: pack25519,
      unpack25519: unpack25519,
      M: M,
      A: A,
      S: S,
      Z: Z,
      pow2523: pow2523,
      add: add,
      set25519: set25519,
      modL: modL,
      scalarmult: scalarmult,
      scalarbase: scalarbase,
    };

    /* High-level API */

    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
      if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
    }

    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
      if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
    }

    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError('unexpected type, use Uint8Array');
      }
    }

    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++) arr[i] = 0;
    }

    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };

    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };

    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32) return null;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };

    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };

    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };

    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };

    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };

    nacl.box.after = nacl.secretbox;

    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };

    nacl.box.open.after = nacl.secretbox.open;

    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };

    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };

    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;

    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };

    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0) return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++) m[i] = tmp[i];
      return m;
    };

    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
      return sig;
    };

    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error('bad signature size');
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
      for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
      return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
    };

    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };

    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };

    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error('bad seed size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++) sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return {publicKey: pk, secretKey: sk};
    };

    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;

    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };

    nacl.hash.hashLength = crypto_hash_BYTES;

    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      // Zero length arguments are considered not equal.
      if (x.length === 0 || y.length === 0) return false;
      if (x.length !== y.length) return false;
      return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
    };

    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };

    (function() {
      // Initialize PRNG if environment provides CSPRNG.
      // If not, methods calling randombytes will throw.
      var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
      if (crypto && crypto.getRandomValues) {
        // Browsers.
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      } else if (typeof commonjsRequire !== 'undefined') {
        // Node.js.
        crypto = require$$0$3;
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto.randomBytes(n);
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();

    })( module.exports ? module.exports : (self.nacl = self.nacl || {}));
    });

    var rngBrowser = createCommonjsModule(function (module) {
    // Unique ID creation requires a high quality random # generator.  In the
    // browser this is a little complicated due to unknown quality of Math.random()
    // and inconsistent support for the `crypto` API.  We do the best we can via
    // feature-detection

    // getRandomValues needs to be invoked in a context where "this" is a Crypto
    // implementation. Also, find the complete implementation of crypto on IE11.
    var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                          (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

    if (getRandomValues) {
      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
      var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var rnds = new Array(16);

      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
          rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return rnds;
      };
    }
    });

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    var byteToHex = [];
    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 0x100).toString(16).substr(1);
    }

    function bytesToUuid(buf, offset) {
      var i = offset || 0;
      var bth = byteToHex;
      // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
      return ([
        bth[buf[i++]], bth[buf[i++]],
        bth[buf[i++]], bth[buf[i++]], '-',
        bth[buf[i++]], bth[buf[i++]], '-',
        bth[buf[i++]], bth[buf[i++]], '-',
        bth[buf[i++]], bth[buf[i++]], '-',
        bth[buf[i++]], bth[buf[i++]],
        bth[buf[i++]], bth[buf[i++]],
        bth[buf[i++]], bth[buf[i++]]
      ]).join('');
    }

    var bytesToUuid_1 = bytesToUuid;

    function v4(options, buf, offset) {
      var i = buf && offset || 0;

      if (typeof(options) == 'string') {
        buf = options === 'binary' ? new Array(16) : null;
        options = null;
      }
      options = options || {};

      var rnds = options.random || (options.rng || rngBrowser)();

      // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
      rnds[6] = (rnds[6] & 0x0f) | 0x40;
      rnds[8] = (rnds[8] & 0x3f) | 0x80;

      // Copy bytes to buffer, if provided
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }

      return buf || bytesToUuid_1(rnds);
    }

    var v4_1 = v4;

    /**
     *  Generates a JSON-RPC 1.0 or 2.0 request
     *  @param {String} method Name of method to call
     *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
     *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
     *  @param {Object} [options]
     *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
     *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
     *  @throws {TypeError} If any of the parameters are invalid
     *  @return {Object} A JSON-RPC 1.0 or 2.0 request
     *  @memberOf Utils
     */
    const generateRequest = function(method, params, id, options) {
      if(typeof method !== 'string') {
        throw new TypeError(method + ' must be a string');
      }

      options = options || {};

      const request = {
        method: method
      };

      // assume that we are doing a 2.0 request unless specified differently
      if(typeof options.version === 'undefined' || options.version !== 1) {
        request.jsonrpc = '2.0';
      }

      if(params) {

        // params given, but invalid?
        if(typeof params !== 'object' && !Array.isArray(params)) {
          throw new TypeError(params + ' must be an object, array or omitted');
        }

        request.params = params;

      }

      // if id was left out, generate one (null means explicit notification)
      if(typeof(id) === 'undefined') {
        const generator = typeof options.generator === 'function' ? options.generator : function() { return v4_1(); };
        request.id = generator(request, options);
      } else {
        request.id = id;
      }

      return request;
    };

    var generateRequest_1 = generateRequest;

    /**
     * Constructor for a Jayson Browser Client that does not depend any node.js core libraries
     * @class ClientBrowser
     * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
     * @param {Object} [options]
     * @param {Function} [options.reviver] Reviver function for JSON
     * @param {Function} [options.replacer] Replacer function for JSON
     * @param {Number} [options.version=2] JSON-RPC version to use (1|2)
     * @param {Function} [options.generator] Function to use for generating request IDs
     * @return {ClientBrowser}
     */
    const ClientBrowser = function(callServer, options) {
      if(!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }

      if (!options) {
        options = {};
      }

      this.options = {
        reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,
        replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,
        generator: typeof options.generator !== 'undefined' ? options.generator : function() { return v4_1(); },
        version: typeof options.version !== 'undefined' ? options.version : 2,
      };

      this.callServer = callServer;
    };

    var browser$4 = ClientBrowser;

    /**
     *  Creates a request and dispatches it if given a callback.
     *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
     *  @param {Array|Object} [params] Parameters for the method
     *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
     *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
     *  @throws {TypeError} Invalid parameters
     *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
     */
    ClientBrowser.prototype.request = function(method, params, id, callback) {
      const self = this;
      let request = null;

      // is this a batch request?
      const isBatch = Array.isArray(method) && typeof params === 'function';

      if (this.options.version === 1 && isBatch) {
        throw new TypeError('JSON-RPC 1.0 does not support batching');
      }

      // is this a raw request?
      const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';

      if(isBatch || isRaw) {
        callback = params;
        request = method;
      } else {
        if(typeof id === 'function') {
          callback = id;
          // specifically undefined because "null" is a notification request
          id = undefined;
        }

        const hasCallback = typeof callback === 'function';

        try {
          request = generateRequest_1(method, params, id, {
            generator: this.options.generator,
            version: this.options.version
          });
        } catch(err) {
          if(hasCallback) {
            return callback(err);
          }
          throw err;
        }

        // no callback means we should just return a raw request
        if(!hasCallback) {
          return request;
        }

      }

      let message;
      try {
        message = JSON.stringify(request, this.options.replacer);
      } catch(err) {
        return callback(err);
      }

      this.callServer(message, function(err, response) {
        self._parseResponse(err, response, callback);
      });

      // always return the raw request
      return request;
    };

    /**
     * Parses a response from a server
     * @param {Object} err Error to pass on that is unrelated to the actual response
     * @param {String} responseText JSON-RPC 1.0 or 2.0 response
     * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
     * @private
     */
    ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
      if(err) {
        callback(err);
        return;
      }

      if(!responseText) {
        // empty response text, assume that is correct because it could be a
        // notification which jayson does not give any body for
        return callback();
      }

      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch(err) {
        return callback(err);
      }

      if(callback.length === 3) {
        // if callback length is 3, we split callback arguments on error and response

        // is batch response?
        if(Array.isArray(response)) {

          // neccesary to split strictly on validity according to spec here
          const isError = function(res) {
            return typeof res.error !== 'undefined';
          };

          const isNotError = function (res) {
            return !isError(res);
          };

          return callback(null, response.filter(isError), response.filter(isNotError));
        
        } else {

          // split regardless of validity
          return callback(null, response.error, response.result);
        
        }
      
      }

      callback(null, response);
    };

    function getEndpoint() {
      const { protocol, hostname } = window.location;
      if (hostname === "localhost") {
        return `${protocol}//${hostname}:8001`;
      } else {
        return `${protocol}//${hostname}/rpc`;
      }
    }

    const ENDPOINT = getEndpoint();

    const callServer = (keyPair) => (request, callback) => {
      let signatureHeaders = {};
      if (keyPair) {
        signatureHeaders["psst-public-key"] = Buffer.from(
          keyPair.publicKey
        ).toString("hex");
        signatureHeaders["psst-signature"] = Buffer.from(
          naclFast.sign.detached(new TextEncoder().encode(request), keyPair.secretKey)
        ).toString("hex");
      }
      const options = {
        method: "POST",
        body: request,
        headers: {
          "Content-Type": "application/json",
          ...signatureHeaders,
        },
      };

      fetch(ENDPOINT, options)
        .then(function (res) {
          return res.text();
        })
        .then(function (val) {
          callback(null, val);
        })
        .catch(function (err) {
          callback(err);
        });
    };

    function call$1(method, ...args) {
      return {
        send: (keyPair) => {
          const client = browser$4(callServer(keyPair), {});
          return new Promise((resolve, reject) => {
            client.request(method, args, (error, result) => {
              if (error) {
                reject(error);
              } else {
                if (result.error) {
                  reject(result.error);
                } else {
                  resolve(result.result);
                }
              }
            });
          });
        },
      };
    }

    function rpcJoinSpace(userName, invite) {
      return call$1("joinSpace", userName, invite);
    }

    function rpcGetSpace() {
      return call$1("getSpace");
    }

    function rpcVerifyInvite(invite) {
      return call$1("verifyInvite", invite);
    }

    function rpcGetInviteDetails(user) {
      return call$1("getInviteDetails", user);
    }

    function rpcHasSpace(spaceName) {
      return call$1("hasSpace", spaceName);
    }

    function rpcCreateSpace(spaceName, userName) {
      return call$1("createSpace", spaceName, userName);
    }

    function rpcAddPost(parentId, title, body) {
      return call$1("addPost", parentId, title, body);
    }

    function rpcGetPost(id) {
      return call$1("getPost", id);
    }

    function rpcMarkPostAsSeen(id) {
      return call$1("markPostAsSeen", id);
    }

    function rpcGetPosts(parentId, limit, offset) {
      return call$1("getPosts", parentId, limit, offset);
    }

    function rpcGetVapidPublicKey() {
      return call$1("getVapidPublicKey");
    }

    function rpcAddSubscription(subscription) {
      return call$1("addSubscription", subscription);
    }

    function uint8ArrayToHexString(i) {
      return Buffer.from(i).toString("hex");
    }

    function uint32toUint8Array(n) {
      if (n < 0 || n >= 2 ** 32) {
        throw new RangeError("Number should be between 0 and 4294967296");
      }
      return Uint8Array.from([
        (n >> 24) & 0xff,
        (n >> 16) & 0xff,
        (n >> 8) & 0xff,
        n & 0xff,
      ]);
    }

    function invite(secretKey, isAdmin, expiry) {
      const { publicKey } = naclFast.sign.keyPair.fromSecretKey(secretKey);
      const nonce = naclFast.randomBytes(32);
      const roleByte = Uint8Array.from([isAdmin ? 1 : 0]);
      const expiryBytes = uint32toUint8Array(Math.floor(expiry.getTime() / 1000));
      // For whatever reason the buffer shim doesn't recognize
      // native Uint8Array as a Buffer, so we call Buffer again
      const message = Buffer.concat(
        [nonce, roleByte, expiryBytes].map(Buffer.from)
      );
      const signature = naclFast.sign.detached(message, secretKey);
      return Uint8Array.from(
        Buffer.concat([message, signature, publicKey].map(Buffer.from))
      );
    }

    function getSignerFromInvite(invite) {
      return invite.substr(invite.length - 64);
    }

    function generateDeterministicSeed(mnemonic, path = "") {
      const textSeed = mnemonic + path;
      const byteSeed = new TextEncoder().encode(textSeed);
      return naclFast.hash(byteSeed).slice(0, 32);
    }

    const SPACE_NAME = "psst";
    const PATH_SPACE_NAME = "/space/" + SPACE_NAME;

    // ACTIONS

    async function login(m) {
      if (!setMnemonic(m)) {
        throw new Error("Invalid mnemonic");
      }
      const spaceKeyPair = naclFast.sign.keyPair.fromSeed(
        generateDeterministicSeed(m, "/space/" + SPACE_NAME)
      );
      const space = await rpcGetSpace().send(spaceKeyPair);
      if (!space) {
        throw new Error("Not authorized");
      }
    }

    function logout() {
      localStorage.removeItem("mnemonic");
      setMnemonic(getMnemonic());
    }

    function getMnemonic() {
      let m = localStorage.getItem("mnemonic");
      if (!validateMnemonic_1(m)) {
        m = generateMnemonic_1();
        localStorage.setItem("mnemonic", m);
      }
      return m;
    }

    function setMnemonic(m) {
      m = m
        .split(" ")
        .filter((token) => token.length)
        .join(" ");
      if (validateMnemonic_1(m)) {
        localStorage.setItem("mnemonic", m);
        mnemonic.set(m);
        return true;
      } else {
        return false;
      }
    }

    function reloadUser() {
      reload.set(Math.random());
    }

    async function joinSpace(spaceName, userName, invite) {
      const mnemonic = getMnemonic();
      const keyPair = naclFast.sign.keyPair.fromSeed(
        generateDeterministicSeed(mnemonic, spaceName ? "/space/" + spaceName : "")
      );
      await rpcJoinSpace(userName, invite).send(keyPair);
      reloadUser();
    }

    async function createSpace(spaceName, userName) {
      await rpcCreateSpace(spaceName, userName).send(get_store_value(keyPair));
      reloadUser();
    }

    async function verifyInvite(invite) {
      return await rpcVerifyInvite(invite).send(get_store_value(keyPair));
    }

    async function getInviteDetails(invite) {
      const signer = getSignerFromInvite(invite);
      return await rpcGetInviteDetails(signer).send(get_store_value(keyPair));
    }

    async function addPost(parentId, title, body) {
      const mnemonic = getMnemonic();
      const keyPair = naclFast.sign.keyPair.fromSeed(
        generateDeterministicSeed(mnemonic, PATH_SPACE_NAME)
      );
      return await rpcAddPost(parentId, title, body).send(keyPair);
    }

    async function getPost(id) {
      const mnemonic = getMnemonic();
      const keyPair = naclFast.sign.keyPair.fromSeed(
        generateDeterministicSeed(mnemonic, PATH_SPACE_NAME)
      );
      return await rpcGetPost(id).send(keyPair);
    }

    async function markPostAsSeen(id) {
      const mnemonic = getMnemonic();
      const keyPair = naclFast.sign.keyPair.fromSeed(
        generateDeterministicSeed(mnemonic, PATH_SPACE_NAME)
      );
      return await rpcMarkPostAsSeen(id).send(keyPair);
    }

    async function getPosts(parentId, limit, offset) {
      const mnemonic = getMnemonic();
      const keyPair = naclFast.sign.keyPair.fromSeed(
        generateDeterministicSeed(mnemonic, PATH_SPACE_NAME)
      );
      return await rpcGetPosts(parentId, limit, offset).send(keyPair);
    }

    async function requestNotificationPermission() {
      const permission = await window.Notification.requestPermission();
      // value of permission can be 'granted', 'default', 'denied'
      // granted: user has accepted the request
      // default: user has dismissed the notification permission popup by clicking on x
      // denied: user has denied the request.
      console.log("Notification permission", permission);
      if (permission !== "granted") {
        throw new Error("Permission not granted for Notification");
      }
    }

    async function subscribeToNotifications() {
      const worker = navigator.serviceWorker.controller;
      const mnemonic = getMnemonic();
      const keyPair = naclFast.sign.keyPair.fromSeed(
        generateDeterministicSeed(mnemonic, PATH_SPACE_NAME)
      );

      await requestNotificationPermission();
      const publicKey = await rpcGetVapidPublicKey().send(keyPair);

      const messageChannel = new MessageChannel();
      messageChannel.port1.onmessage = (event) => {
        console.log("Reply from Service Worker", event.data); // this comes from the ServiceWorker
        if (event.data.subscription) {
          rpcAddSubscription(event.data.subscription).send(keyPair);
        }
      };
      worker.postMessage({ action: "subscribe", publicKey }, [
        messageChannel.port2,
      ]);
    }

    // STORES
    const mnemonic = writable(getMnemonic());
    const reload = writable();

    const spaceName = readable(SPACE_NAME);

    //export const spaceName = derived(location, ($location) => {
    //  const match = /^\/space\/([^\/]+)/.exec($location);
    //  if (match) {
    //    return decodeURIComponent(match[1]);
    //  } else {
    //    return null;
    //  }
    //});

    const keyPair = derived(
      [mnemonic, spaceName, reload],
      ([$mnemonic, $spaceName, $reload]) =>
        naclFast.sign.keyPair.fromSeed(
          generateDeterministicSeed(
            $mnemonic,
            $spaceName ? "/space/" + $spaceName : ""
          )
        )
    );

    const publicKey = derived(keyPair, ($keyPair) =>
      Buffer.from($keyPair.publicKey).toString("hex")
    );

    const space$1 = derived(
      [keyPair, spaceName],
      async ([$keyPair, $spaceName], set) => {
        if (!$spaceName) {
          set(undefined);
        } else {
          let record = await rpcGetSpace().send($keyPair);
          if (record === undefined) {
            const hasSpace = await rpcHasSpace($spaceName).send($keyPair);
            if (!hasSpace) {
              await createSpace($spaceName, "admin");
            } else {
              set(false);
            }
          } else {
            set(record);
          }
        }
      }
    );

    const inMeeting = writable(false);

    const notifications = writable(undefined, async (set) => {
      await navigator.serviceWorker.ready;
      const worker = navigator.serviceWorker.controller;
      const messageChannel = new MessageChannel();
      messageChannel.port1.onmessage = (event) => {
        console.log("Reply from Service Worker", event.data); // this comes from the ServiceWorker
        set(!!event.data.subscription);
      };
      worker.postMessage({ action: "getSubscription" }, [messageChannel.port2]);
    });

    /* src/components/EnableNotifications.svelte generated by Svelte v3.31.0 */
    const file = "src/components/EnableNotifications.svelte";

    // (5:0) {#if !$notifications}
    function create_if_block$1(ctx) {
    	let section;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			section = element("section");
    			button = element("button");
    			button.textContent = "Enable web notifications";
    			add_location(button, file, 6, 8, 136);
    			add_location(section, file, 5, 4, 118);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", subscribeToNotifications, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(5:0) {#if !$notifications}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let if_block = !/*$notifications*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*$notifications*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $notifications;
    	validate_store(notifications, "notifications");
    	component_subscribe($$self, notifications, $$value => $$invalidate(0, $notifications = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EnableNotifications", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EnableNotifications> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		subscribeToNotifications,
    		notifications,
    		$notifications
    	});

    	return [$notifications];
    }

    class EnableNotifications extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EnableNotifications",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/components/header/Mnemonic.svelte generated by Svelte v3.31.0 */

    const { console: console_1$1 } = globals;
    const file$1 = "src/components/header/Mnemonic.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[11] = list;
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (42:2) {#each inputs as _, i}
    function create_each_block(ctx) {
    	let input;
    	let i = /*i*/ ctx[12];
    	let mounted;
    	let dispose;
    	const assign_input = () => /*input_binding*/ ctx[7](input, i);
    	const unassign_input = () => /*input_binding*/ ctx[7](null, i);

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[8].call(input, /*i*/ ctx[12]);
    	}

    	function input_handler(...args) {
    		return /*input_handler*/ ctx[9](/*i*/ ctx[12], ...args);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "svelte-chl7k0");
    			add_location(input, file$1, 42, 4, 882);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			assign_input();
    			set_input_value(input, /*values*/ ctx[2][/*i*/ ctx[12]]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", input_input_handler),
    					listen_dev(input, "input", input_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (i !== /*i*/ ctx[12]) {
    				unassign_input();
    				i = /*i*/ ctx[12];
    				assign_input();
    			}

    			if (dirty & /*values*/ 4 && input.value !== /*values*/ ctx[2][/*i*/ ctx[12]]) {
    				set_input_value(input, /*values*/ ctx[2][/*i*/ ctx[12]]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			unassign_input();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(42:2) {#each inputs as _, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let form;
    	let t0;
    	let button0;
    	let t2;
    	let hr;
    	let t3;
    	let button1;
    	let mounted;
    	let dispose;
    	let each_value = /*inputs*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			form = element("form");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			button0 = element("button");
    			button0.textContent = "Submit";
    			t2 = space();
    			hr = element("hr");
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Cancel";
    			attr_dev(button0, "type", "submit");
    			attr_dev(button0, "class", "svelte-chl7k0");
    			add_location(button0, file$1, 47, 2, 1001);
    			add_location(hr, file$1, 48, 2, 1041);
    			attr_dev(button1, "type", "reset");
    			attr_dev(button1, "class", "neutral svelte-chl7k0");
    			add_location(button1, file$1, 49, 2, 1050);
    			add_location(form, file$1, 40, 0, 787);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(form, null);
    			}

    			append_dev(form, t0);
    			append_dev(form, button0);
    			append_dev(form, t2);
    			append_dev(form, hr);
    			append_dev(form, t3);
    			append_dev(form, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[5]), false, true, false),
    					listen_dev(
    						form,
    						"reset",
    						function () {
    							if (is_function(/*onReset*/ ctx[0])) /*onReset*/ ctx[0].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*elements, values, onValue*/ 22) {
    				each_value = /*inputs*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(form, t0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Mnemonic", slots, []);
    	let { onReset } = $$props;
    	let { onError } = $$props;
    	let inputs = [,,,,,,,,,,,,];
    	let elements = [,,,,,,,,,,,,];
    	let values = [,,,,,,,,,,,,];

    	function onValue(event, index) {
    		const words = values[index].split(" ").filter(x => x);

    		words.forEach((word, i) => {
    			const pos = index + i;

    			if (pos < values.length) {
    				$$invalidate(2, values[pos] = word, values);
    				elements[pos].focus();
    			}
    		});
    	}

    	async function handleSubmit() {
    		try {
    			console.log(values);
    			await login(values.join(" "));
    		} catch(e) {
    			console.error(e);
    			onError(e.toString());
    		}
    	}

    	const writable_props = ["onReset", "onError"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Mnemonic> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value, i) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			elements[i] = $$value;
    			$$invalidate(1, elements);
    		});
    	}

    	function input_input_handler(i) {
    		values[i] = this.value;
    		$$invalidate(2, values);
    	}

    	const input_handler = (i, e) => onValue(e, i);

    	$$self.$$set = $$props => {
    		if ("onReset" in $$props) $$invalidate(0, onReset = $$props.onReset);
    		if ("onError" in $$props) $$invalidate(6, onError = $$props.onError);
    	};

    	$$self.$capture_state = () => ({
    		login,
    		onReset,
    		onError,
    		inputs,
    		elements,
    		values,
    		onValue,
    		handleSubmit
    	});

    	$$self.$inject_state = $$props => {
    		if ("onReset" in $$props) $$invalidate(0, onReset = $$props.onReset);
    		if ("onError" in $$props) $$invalidate(6, onError = $$props.onError);
    		if ("inputs" in $$props) $$invalidate(3, inputs = $$props.inputs);
    		if ("elements" in $$props) $$invalidate(1, elements = $$props.elements);
    		if ("values" in $$props) $$invalidate(2, values = $$props.values);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		onReset,
    		elements,
    		values,
    		inputs,
    		onValue,
    		handleSubmit,
    		onError,
    		input_binding,
    		input_input_handler,
    		input_handler
    	];
    }

    class Mnemonic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { onReset: 0, onError: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Mnemonic",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onReset*/ ctx[0] === undefined && !("onReset" in props)) {
    			console_1$1.warn("<Mnemonic> was created without expected prop 'onReset'");
    		}

    		if (/*onError*/ ctx[6] === undefined && !("onError" in props)) {
    			console_1$1.warn("<Mnemonic> was created without expected prop 'onError'");
    		}
    	}

    	get onReset() {
    		throw new Error("<Mnemonic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onReset(value) {
    		throw new Error("<Mnemonic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onError() {
    		throw new Error("<Mnemonic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onError(value) {
    		throw new Error("<Mnemonic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/header/Header.svelte generated by Svelte v3.31.0 */
    const file$2 = "src/components/header/Header.svelte";

    // (85:0) {#if showHeader}
    function create_if_block$2(ctx) {
    	let section;
    	let header;
    	let t;
    	let div;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let if_block0 = /*space*/ ctx[0] && create_if_block_4(ctx);
    	const if_block_creators = [create_if_block_1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*space*/ ctx[0] === false) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			header = element("header");
    			if (if_block0) if_block0.c();
    			t = space();
    			div = element("div");
    			if_block1.c();
    			attr_dev(div, "class", "group svelte-oa35yz");
    			add_location(div, file$2, 92, 6, 1671);
    			attr_dev(header, "class", "svelte-oa35yz");
    			add_location(header, file$2, 86, 4, 1515);
    			add_location(section, file$2, 85, 2, 1501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, header);
    			if (if_block0) if_block0.m(header, null);
    			append_dev(header, t);
    			append_dev(header, div);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*space*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					if_block0.m(header, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(85:0) {#if showHeader}",
    		ctx
    	});

    	return block;
    }

    // (88:6) {#if space}
    function create_if_block_4(ctx) {
    	let h1;
    	let a;
    	let span;
    	let t1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			a = element("a");
    			span = element("span");
    			span.textContent = "←";
    			t1 = text("psst");
    			attr_dev(span, "class", "arrow svelte-oa35yz");
    			add_location(span, file$2, 89, 34, 1602);
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "svelte-oa35yz");
    			toggle_class(a, "home", /*home*/ ctx[2]);
    			add_location(a, file$2, 89, 10, 1578);
    			attr_dev(h1, "class", "logo svelte-oa35yz");
    			add_location(h1, file$2, 88, 8, 1550);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, a);
    			append_dev(a, span);
    			append_dev(a, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*home*/ 4) {
    				toggle_class(a, "home", /*home*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(88:6) {#if space}",
    		ctx
    	});

    	return block;
    }

    // (104:8) {:else}
    function create_else_block_1(ctx) {
    	let t0;
    	let a;
    	let mounted;
    	let dispose;
    	let if_block = /*space*/ ctx[0].isAdmin && create_if_block_3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			a = element("a");
    			a.textContent = "Exit Space";
    			attr_dev(a, "class", "button svelte-oa35yz");
    			attr_dev(a, "href", "#/logout");
    			add_location(a, file$2, 108, 10, 2213);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*handleLogout*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*space*/ ctx[0].isAdmin) {
    				if (if_block) ; else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(104:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (94:8) {#if space === false}
    function create_if_block_1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*showMagicWords*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(94:8) {#if space === false}",
    		ctx
    	});

    	return block;
    }

    // (105:10) {#if space.isAdmin}
    function create_if_block_3(ctx) {
    	let a;
    	let t1;
    	let hr;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "Admin";
    			t1 = space();
    			hr = element("hr");
    			attr_dev(a, "class", "button admin svelte-oa35yz");
    			attr_dev(a, "href", "#/admin");
    			add_location(a, file$2, 105, 12, 2119);
    			add_location(hr, file$2, 106, 12, 2180);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, hr, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(hr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(105:10) {#if space.isAdmin}",
    		ctx
    	});

    	return block;
    }

    // (97:10) {:else}
    function create_else_block$1(ctx) {
    	let button;
    	let t1;
    	let hr;
    	let t2;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Enter Magic\n              Words";
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			a = element("a");
    			a.textContent = "Make\n              Contact";
    			attr_dev(button, "class", "mnemonic svelte-oa35yz");
    			add_location(button, file$2, 97, 12, 1827);
    			add_location(hr, file$2, 99, 12, 1937);
    			attr_dev(a, "class", "button contact svelte-oa35yz");
    			attr_dev(a, "href", "mailto:admin@example.org");
    			add_location(a, file$2, 100, 12, 1956);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleShowMagicWords*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(97:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (95:10) {#if showMagicWords}
    function create_if_block_2(ctx) {
    	let mnemonic;
    	let current;

    	mnemonic = new Mnemonic({
    			props: {
    				onReset: /*onReset*/ ctx[5],
    				onError: /*onError*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mnemonic.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mnemonic, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mnemonic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mnemonic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mnemonic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(95:10) {#if showMagicWords}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*showHeader*/ ctx[3] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showHeader*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showHeader*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $location;
    	let $inMeeting;
    	validate_store(location, "location");
    	component_subscribe($$self, location, $$value => $$invalidate(8, $location = $$value));
    	validate_store(inMeeting, "inMeeting");
    	component_subscribe($$self, inMeeting, $$value => $$invalidate(10, $inMeeting = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Header", slots, []);
    	let { space } = $$props;
    	let showMagicWords;
    	let error;

    	function handleShowMagicWords() {
    		$$invalidate(1, showMagicWords = true);
    	}

    	function onReset() {
    		$$invalidate(1, showMagicWords = false);
    	}

    	function onError(e) {
    		error = e;
    	}

    	function handleLogout(e) {
    		if ($inMeeting) {
    			if (confirm("Leave the meeting?")) {
    				set_store_value(inMeeting, $inMeeting = false, $inMeeting);
    			} else {
    				e.preventDefault();
    			}
    		}
    	}

    	const writable_props = ["space"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("space" in $$props) $$invalidate(0, space = $$props.space);
    	};

    	$$self.$capture_state = () => ({
    		location,
    		inMeeting,
    		Mnemonic,
    		space,
    		showMagicWords,
    		error,
    		handleShowMagicWords,
    		onReset,
    		onError,
    		handleLogout,
    		home,
    		$location,
    		showHeader,
    		$inMeeting
    	});

    	$$self.$inject_state = $$props => {
    		if ("space" in $$props) $$invalidate(0, space = $$props.space);
    		if ("showMagicWords" in $$props) $$invalidate(1, showMagicWords = $$props.showMagicWords);
    		if ("error" in $$props) error = $$props.error;
    		if ("home" in $$props) $$invalidate(2, home = $$props.home);
    		if ("showHeader" in $$props) $$invalidate(3, showHeader = $$props.showHeader);
    	};

    	let home;
    	let showHeader;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$location*/ 256) {
    			 $$invalidate(2, home = $location === "/");
    		}

    		if ($$self.$$.dirty & /*$location*/ 256) {
    			// FIXME: there must be a better way!
    			 $$invalidate(3, showHeader = !$location.startsWith("/join") && !$location.startsWith("/logout"));
    		}
    	};

    	return [
    		space,
    		showMagicWords,
    		home,
    		showHeader,
    		handleShowMagicWords,
    		onReset,
    		onError,
    		handleLogout,
    		$location
    	];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { space: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*space*/ ctx[0] === undefined && !("space" in props)) {
    			console.warn("<Header> was created without expected prop 'space'");
    		}
    	}

    	get space() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set space(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/jitsi/Index.svelte generated by Svelte v3.31.0 */
    const file$3 = "src/components/jitsi/Index.svelte";

    // (150:2) {#if showPlaceholder}
    function create_if_block$3(ctx) {
    	let div;
    	let p;
    	let t1;
    	let button0;
    	let t3;
    	let ul;
    	let li0;
    	let button1;
    	let t4;
    	let button1_disabled_value;
    	let t5;
    	let li1;
    	let button2;
    	let t6;
    	let button2_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "The meeting room has been detached.";
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Reattach";
    			t3 = space();
    			ul = element("ul");
    			li0 = element("li");
    			button1 = element("button");
    			t4 = text("Leave Meeting");
    			t5 = space();
    			li1 = element("li");
    			button2 = element("button");
    			t6 = text("Detach");
    			add_location(p, file$3, 151, 6, 3328);
    			add_location(button0, file$3, 152, 6, 3377);
    			attr_dev(div, "class", "placeholder svelte-1cbs3nv");
    			set_style(div, "width", /*width*/ ctx[2]);
    			set_style(div, "height", /*height*/ ctx[3]);
    			add_location(div, file$3, 150, 4, 3255);
    			button1.disabled = button1_disabled_value = !/*api*/ ctx[6];
    			add_location(button1, file$3, 156, 8, 3466);
    			attr_dev(li0, "class", "svelte-1cbs3nv");
    			add_location(li0, file$3, 155, 6, 3453);
    			button2.disabled = button2_disabled_value = !/*api*/ ctx[6];
    			add_location(button2, file$3, 158, 10, 3558);
    			attr_dev(li1, "class", "svelte-1cbs3nv");
    			add_location(li1, file$3, 158, 6, 3554);
    			attr_dev(ul, "class", "svelte-1cbs3nv");
    			add_location(ul, file$3, 154, 4, 3442);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(div, t1);
    			append_dev(div, button0);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, button1);
    			append_dev(button1, t4);
    			append_dev(ul, t5);
    			append_dev(ul, li1);
    			append_dev(li1, button2);
    			append_dev(button2, t6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleDetach*/ ctx[8], false, false, false),
    					listen_dev(button1, "click", /*handleLeave*/ ctx[9], false, false, false),
    					listen_dev(button2, "click", /*handleDetach*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*width*/ 4) {
    				set_style(div, "width", /*width*/ ctx[2]);
    			}

    			if (dirty & /*height*/ 8) {
    				set_style(div, "height", /*height*/ ctx[3]);
    			}

    			if (dirty & /*api*/ 64 && button1_disabled_value !== (button1_disabled_value = !/*api*/ ctx[6])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*api*/ 64 && button2_disabled_value !== (button2_disabled_value = !/*api*/ ctx[6])) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(150:2) {#if showPlaceholder}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t;
    	let if_block = /*showPlaceholder*/ ctx[1] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			add_location(div0, file$3, 147, 4, 3185);
    			attr_dev(div1, "class", "meeting svelte-1cbs3nv");

    			set_style(div1, "width", /*detached*/ ctx[0]
    			? /*detachedWidth*/ ctx[4]
    			: /*width*/ ctx[2]);

    			set_style(div1, "height", /*detached*/ ctx[0]
    			? /*detachedHeight*/ ctx[5]
    			: /*height*/ ctx[3]);

    			add_location(div1, file$3, 144, 2, 3055);
    			attr_dev(div2, "class", "container svelte-1cbs3nv");
    			toggle_class(div2, "detached", /*detached*/ ctx[0]);
    			add_location(div2, file$3, 143, 0, 3014);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			/*div0_binding*/ ctx[15](div0);
    			append_dev(div2, t);
    			if (if_block) if_block.m(div2, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*detached, detachedWidth, width*/ 21) {
    				set_style(div1, "width", /*detached*/ ctx[0]
    				? /*detachedWidth*/ ctx[4]
    				: /*width*/ ctx[2]);
    			}

    			if (dirty & /*detached, detachedHeight, height*/ 41) {
    				set_style(div1, "height", /*detached*/ ctx[0]
    				? /*detachedHeight*/ ctx[5]
    				: /*height*/ ctx[3]);
    			}

    			if (/*showPlaceholder*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*detached*/ 1) {
    				toggle_class(div2, "detached", /*detached*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			/*div0_binding*/ ctx[15](null);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);
    	let { name } = $$props;
    	let { key } = $$props;
    	let { detached = false } = $$props;
    	let { showPlaceholder = true } = $$props;
    	let { width = "100%" } = $$props;
    	let { height = "500px" } = $$props;
    	let { detachedWidth = "250px" } = $$props;
    	let { detachedHeight = "250px" } = $$props;
    	let { onLeave } = $$props;
    	let api;
    	let jitsiElement;
    	let tileView;

    	function handleDetach() {
    		$$invalidate(0, detached = !detached);
    	}

    	function handleLeave() {
    		api.executeCommand("hangup");
    		if (onLeave) onLeave();
    	}

    	onMount(() => {
    		function tileViewListener({ enabled }) {
    			$$invalidate(13, tileView = enabled);
    		}

    		const domain = "meet.jit.si";

    		const options = {
    			roomName: key,
    			width,
    			height,
    			parentNode: jitsiElement,
    			userInfo: { displayName: name },
    			configOverwrite: { prejoinPageEnabled: false },
    			interfaceConfigOverwrite: {
    				HIDE_INVITE_MORE_HEADER: true,
    				TOOLBAR_BUTTONS: [
    					"microphone",
    					"camera",
    					"closedcaptions",
    					"desktop",
    					"embedmeeting",
    					"fullscreen",
    					"fodeviceselection",
    					//"hangup",
    					//"profile",
    					"chat",
    					//"recording",
    					//"livestreaming",
    					"etherpad",
    					"sharedvideo",
    					"settings",
    					"raisehand",
    					"videoquality",
    					"filmstrip",
    					"feedback",
    					"stats",
    					"shortcuts",
    					"tileview",
    					"videobackgroundblur",
    					"download",
    					"help",
    					"mute-everyone"
    				], //"security",
    				
    			}
    		};

    		$$invalidate(6, api = new JitsiMeetExternalAPI(domain, options));
    		api.executeCommand("toggleTileView");
    		api.addEventListener("tileViewChanged", tileViewListener);
    		window.jitsiAPI = api;

    		return () => {
    			api.removeEventListener("tileViewListener", tileViewListener);
    		};
    	});

    	const writable_props = [
    		"name",
    		"key",
    		"detached",
    		"showPlaceholder",
    		"width",
    		"height",
    		"detachedWidth",
    		"detachedHeight",
    		"onLeave"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			jitsiElement = $$value;
    			(((((($$invalidate(7, jitsiElement), $$invalidate(6, api)), $$invalidate(0, detached)), $$invalidate(13, tileView)), $$invalidate(14, currentHeight)), $$invalidate(5, detachedHeight)), $$invalidate(3, height));
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("name" in $$props) $$invalidate(10, name = $$props.name);
    		if ("key" in $$props) $$invalidate(11, key = $$props.key);
    		if ("detached" in $$props) $$invalidate(0, detached = $$props.detached);
    		if ("showPlaceholder" in $$props) $$invalidate(1, showPlaceholder = $$props.showPlaceholder);
    		if ("width" in $$props) $$invalidate(2, width = $$props.width);
    		if ("height" in $$props) $$invalidate(3, height = $$props.height);
    		if ("detachedWidth" in $$props) $$invalidate(4, detachedWidth = $$props.detachedWidth);
    		if ("detachedHeight" in $$props) $$invalidate(5, detachedHeight = $$props.detachedHeight);
    		if ("onLeave" in $$props) $$invalidate(12, onLeave = $$props.onLeave);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		name,
    		key,
    		detached,
    		showPlaceholder,
    		width,
    		height,
    		detachedWidth,
    		detachedHeight,
    		onLeave,
    		api,
    		jitsiElement,
    		tileView,
    		handleDetach,
    		handleLeave,
    		currentHeight
    	});

    	$$self.$inject_state = $$props => {
    		if ("name" in $$props) $$invalidate(10, name = $$props.name);
    		if ("key" in $$props) $$invalidate(11, key = $$props.key);
    		if ("detached" in $$props) $$invalidate(0, detached = $$props.detached);
    		if ("showPlaceholder" in $$props) $$invalidate(1, showPlaceholder = $$props.showPlaceholder);
    		if ("width" in $$props) $$invalidate(2, width = $$props.width);
    		if ("height" in $$props) $$invalidate(3, height = $$props.height);
    		if ("detachedWidth" in $$props) $$invalidate(4, detachedWidth = $$props.detachedWidth);
    		if ("detachedHeight" in $$props) $$invalidate(5, detachedHeight = $$props.detachedHeight);
    		if ("onLeave" in $$props) $$invalidate(12, onLeave = $$props.onLeave);
    		if ("api" in $$props) $$invalidate(6, api = $$props.api);
    		if ("jitsiElement" in $$props) $$invalidate(7, jitsiElement = $$props.jitsiElement);
    		if ("tileView" in $$props) $$invalidate(13, tileView = $$props.tileView);
    		if ("currentHeight" in $$props) $$invalidate(14, currentHeight = $$props.currentHeight);
    	};

    	let currentHeight;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*detached, detachedHeight, height*/ 41) {
    			 $$invalidate(14, currentHeight = detached ? detachedHeight : height);
    		}

    		if ($$self.$$.dirty & /*api, detached, tileView, currentHeight, jitsiElement*/ 24769) {
    			 {
    				if (api) {
    					if (detached) {
    						if (tileView) {
    							api.executeCommand("toggleTileView");
    						}

    						$$invalidate(7, jitsiElement.style.height = currentHeight, jitsiElement);
    						jitsiElement.querySelector("iframe").style.height = currentHeight;
    					} else {
    						$$invalidate(7, jitsiElement.style.height = currentHeight, jitsiElement);
    						jitsiElement.querySelector("iframe").style.height = currentHeight;
    					}
    				}
    			}
    		}
    	};

    	return [
    		detached,
    		showPlaceholder,
    		width,
    		height,
    		detachedWidth,
    		detachedHeight,
    		api,
    		jitsiElement,
    		handleDetach,
    		handleLeave,
    		name,
    		key,
    		onLeave,
    		tileView,
    		currentHeight,
    		div0_binding
    	];
    }

    class Index extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			name: 10,
    			key: 11,
    			detached: 0,
    			showPlaceholder: 1,
    			width: 2,
    			height: 3,
    			detachedWidth: 4,
    			detachedHeight: 5,
    			onLeave: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[10] === undefined && !("name" in props)) {
    			console.warn("<Index> was created without expected prop 'name'");
    		}

    		if (/*key*/ ctx[11] === undefined && !("key" in props)) {
    			console.warn("<Index> was created without expected prop 'key'");
    		}

    		if (/*onLeave*/ ctx[12] === undefined && !("onLeave" in props)) {
    			console.warn("<Index> was created without expected prop 'onLeave'");
    		}
    	}

    	get name() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get detached() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set detached(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showPlaceholder() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showPlaceholder(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get detachedWidth() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set detachedWidth(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get detachedHeight() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set detachedHeight(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onLeave() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onLeave(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/JitsiController.svelte generated by Svelte v3.31.0 */
    const file$4 = "src/components/JitsiController.svelte";

    // (61:0) {#if show}
    function create_if_block$4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$1, create_if_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$inMeeting*/ ctx[4]) return 0;
    		if (/*showPlaceholder*/ ctx[3]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(61:0) {#if show}",
    		ctx
    	});

    	return block;
    }

    // (75:28) 
    function create_if_block_2$1(ctx) {
    	let section;
    	let div1;
    	let h1;
    	let t1;
    	let div0;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "meeting room";
    			t1 = space();
    			div0 = element("div");
    			button = element("button");
    			button.textContent = "Join meeting";
    			attr_dev(h1, "class", "svelte-1c19zox");
    			add_location(h1, file$4, 77, 8, 1609);
    			attr_dev(button, "class", "svelte-1c19zox");
    			add_location(button, file$4, 78, 13, 1644);
    			add_location(div0, file$4, 78, 8, 1639);
    			attr_dev(div1, "class", "placeholder svelte-1c19zox");
    			set_style(div1, "width", /*width*/ ctx[5]);
    			set_style(div1, "height", /*height*/ ctx[6]);
    			add_location(div1, file$4, 76, 6, 1534);
    			attr_dev(section, "class", "svelte-1c19zox");
    			add_location(section, file$4, 75, 4, 1518);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div1);
    			append_dev(div1, h1);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleJoin*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(75:28) ",
    		ctx
    	});

    	return block;
    }

    // (62:2) {#if $inMeeting}
    function create_if_block_1$1(ctx) {
    	let section;
    	let jitsi;
    	let updating_detached;
    	let current;

    	function jitsi_detached_binding(value) {
    		/*jitsi_detached_binding*/ ctx[12].call(null, value);
    	}

    	let jitsi_props = {
    		name: /*$space*/ ctx[1].name,
    		key: /*$space*/ ctx[1].jitsiKey,
    		showPlaceholder: /*showPlaceholder*/ ctx[3],
    		width: /*width*/ ctx[5],
    		height: /*height*/ ctx[6],
    		detachedWidth: /*detachedWidth*/ ctx[7],
    		detachedHeight: /*detachedHeight*/ ctx[8],
    		onLeave: /*onLeave*/ ctx[10]
    	};

    	if (/*detached*/ ctx[0] !== void 0) {
    		jitsi_props.detached = /*detached*/ ctx[0];
    	}

    	jitsi = new Index({ props: jitsi_props, $$inline: true });
    	binding_callbacks.push(() => bind(jitsi, "detached", jitsi_detached_binding));

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(jitsi.$$.fragment);
    			attr_dev(section, "class", "svelte-1c19zox");
    			add_location(section, file$4, 62, 4, 1239);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(jitsi, section, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const jitsi_changes = {};
    			if (dirty & /*$space*/ 2) jitsi_changes.name = /*$space*/ ctx[1].name;
    			if (dirty & /*$space*/ 2) jitsi_changes.key = /*$space*/ ctx[1].jitsiKey;
    			if (dirty & /*showPlaceholder*/ 8) jitsi_changes.showPlaceholder = /*showPlaceholder*/ ctx[3];

    			if (!updating_detached && dirty & /*detached*/ 1) {
    				updating_detached = true;
    				jitsi_changes.detached = /*detached*/ ctx[0];
    				add_flush_callback(() => updating_detached = false);
    			}

    			jitsi.$set(jitsi_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(jitsi.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(jitsi.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(jitsi);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(62:2) {#if $inMeeting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*show*/ ctx[2] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*show*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*show*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $space;
    	let $location;
    	let $inMeeting;
    	validate_store(space$1, "space");
    	component_subscribe($$self, space$1, $$value => $$invalidate(1, $space = $$value));
    	validate_store(location, "location");
    	component_subscribe($$self, location, $$value => $$invalidate(11, $location = $$value));
    	validate_store(inMeeting, "inMeeting");
    	component_subscribe($$self, inMeeting, $$value => $$invalidate(4, $inMeeting = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("JitsiController", slots, []);
    	let width = "100%";
    	let height = "500px";
    	let detachedWidth = "250px";
    	let detachedHeight = "150px";
    	let detached;

    	function handleJoin() {
    		set_store_value(inMeeting, $inMeeting = true, $inMeeting);
    	}

    	function onLeave() {
    		set_store_value(inMeeting, $inMeeting = false, $inMeeting);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<JitsiController> was created with unknown prop '${key}'`);
    	});

    	function jitsi_detached_binding(value) {
    		detached = value;
    		($$invalidate(0, detached), $$invalidate(11, $location));
    	}

    	$$self.$capture_state = () => ({
    		space: space$1,
    		inMeeting,
    		location,
    		Jitsi: Index,
    		width,
    		height,
    		detachedWidth,
    		detachedHeight,
    		detached,
    		handleJoin,
    		onLeave,
    		show,
    		$space,
    		$location,
    		showPlaceholder,
    		$inMeeting
    	});

    	$$self.$inject_state = $$props => {
    		if ("width" in $$props) $$invalidate(5, width = $$props.width);
    		if ("height" in $$props) $$invalidate(6, height = $$props.height);
    		if ("detachedWidth" in $$props) $$invalidate(7, detachedWidth = $$props.detachedWidth);
    		if ("detachedHeight" in $$props) $$invalidate(8, detachedHeight = $$props.detachedHeight);
    		if ("detached" in $$props) $$invalidate(0, detached = $$props.detached);
    		if ("show" in $$props) $$invalidate(2, show = $$props.show);
    		if ("showPlaceholder" in $$props) $$invalidate(3, showPlaceholder = $$props.showPlaceholder);
    	};

    	let show;
    	let showPlaceholder;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$space, $location*/ 2050) {
    			 $$invalidate(2, show = $space && (["/", "/admin"].includes($location) || $location.startsWith("/forum")));
    		}

    		if ($$self.$$.dirty & /*detached, $location*/ 2049) {
    			 {
    				$$invalidate(0, detached = detached || $location.startsWith("/forum") || $location === "/admin");
    			}
    		}

    		if ($$self.$$.dirty & /*$location*/ 2048) {
    			 $$invalidate(3, showPlaceholder = $location === "/");
    		}
    	};

    	return [
    		detached,
    		$space,
    		show,
    		showPlaceholder,
    		$inMeeting,
    		width,
    		height,
    		detachedWidth,
    		detachedHeight,
    		handleJoin,
    		onLeave,
    		$location,
    		jitsi_detached_binding
    	];
    }

    class JitsiController extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JitsiController",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /*!
     * wavesurfer.js 4.3.0 (2020-12-13)
     * https://wavesurfer-js.org
     * @license BSD-3-Clause
     */

    var wavesurfer = createCommonjsModule(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(commonjsGlobal, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = "./src/wavesurfer.js");
    /******/ })
    /************************************************************************/
    /******/ ({

    /***/ "./node_modules/debounce/index.js":
    /*!****************************************!*\
      !*** ./node_modules/debounce/index.js ***!
      \****************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    /**
     * Returns a function, that, as long as it continues to be invoked, will not
     * be triggered. The function will be called after it stops being called for
     * N milliseconds. If `immediate` is passed, trigger the function on the
     * leading edge, instead of the trailing. The function also has a property 'clear' 
     * that is a function which will clear the timer to prevent previously scheduled executions. 
     *
     * @source underscore.js
     * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
     * @param {Function} function to wrap
     * @param {Number} timeout in ms (`100`)
     * @param {Boolean} whether to execute at the beginning (`false`)
     * @api public
     */
    function debounce(func, wait, immediate){
      var timeout, args, context, timestamp, result;
      if (null == wait) wait = 100;

      function later() {
        var last = Date.now() - timestamp;

        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      var debounced = function(){
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };

      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          
          clearTimeout(timeout);
          timeout = null;
        }
      };

      return debounced;
    }
    // Adds compatibility for ES modules
    debounce.debounce = debounce;

    module.exports = debounce;


    /***/ }),

    /***/ "./src/drawer.canvasentry.js":
    /*!***********************************!*\
      !*** ./src/drawer.canvasentry.js ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _style = _interopRequireDefault(__webpack_require__(/*! ./util/style */ "./src/util/style.js"));

    var _getId = _interopRequireDefault(__webpack_require__(/*! ./util/get-id */ "./src/util/get-id.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    /**
     * The `CanvasEntry` class represents an element consisting of a wave `canvas`
     * and an (optional) progress wave `canvas`.
     *
     * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to
     * render a waveform, depending on the zoom level.
     */
    var CanvasEntry = /*#__PURE__*/function () {
      function CanvasEntry() {
        _classCallCheck(this, CanvasEntry);

        /**
         * The wave node
         *
         * @type {HTMLCanvasElement}
         */
        this.wave = null;
        /**
         * The wave canvas rendering context
         *
         * @type {CanvasRenderingContext2D}
         */

        this.waveCtx = null;
        /**
         * The (optional) progress wave node
         *
         * @type {HTMLCanvasElement}
         */

        this.progress = null;
        /**
         * The (optional) progress wave canvas rendering context
         *
         * @type {CanvasRenderingContext2D}
         */

        this.progressCtx = null;
        /**
         * Start of the area the canvas should render, between 0 and 1
         *
         * @type {number}
         */

        this.start = 0;
        /**
         * End of the area the canvas should render, between 0 and 1
         *
         * @type {number}
         */

        this.end = 1;
        /**
         * Unique identifier for this entry
         *
         * @type {string}
         */

        this.id = (0, _getId.default)(typeof this.constructor.name !== 'undefined' ? this.constructor.name.toLowerCase() + '_' : 'canvasentry_');
        /**
         * Canvas 2d context attributes
         *
         * @type {object}
         */

        this.canvasContextAttributes = {};
      }
      /**
       * Store the wave canvas element and create the 2D rendering context
       *
       * @param {HTMLCanvasElement} element The wave `canvas` element.
       */


      _createClass(CanvasEntry, [{
        key: "initWave",
        value: function initWave(element) {
          this.wave = element;
          this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);
        }
        /**
         * Store the progress wave canvas element and create the 2D rendering
         * context
         *
         * @param {HTMLCanvasElement} element The progress wave `canvas` element.
         */

      }, {
        key: "initProgress",
        value: function initProgress(element) {
          this.progress = element;
          this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);
        }
        /**
         * Update the dimensions
         *
         * @param {number} elementWidth Width of the entry
         * @param {number} totalWidth Total width of the multi canvas renderer
         * @param {number} width The new width of the element
         * @param {number} height The new height of the element
         */

      }, {
        key: "updateDimensions",
        value: function updateDimensions(elementWidth, totalWidth, width, height) {
          // where the canvas starts and ends in the waveform, represented as a
          // decimal between 0 and 1
          this.start = this.wave.offsetLeft / totalWidth || 0;
          this.end = this.start + elementWidth / totalWidth; // set wave canvas dimensions

          this.wave.width = width;
          this.wave.height = height;
          var elementSize = {
            width: elementWidth + 'px'
          };
          (0, _style.default)(this.wave, elementSize);

          if (this.hasProgressCanvas) {
            // set progress canvas dimensions
            this.progress.width = width;
            this.progress.height = height;
            (0, _style.default)(this.progress, elementSize);
          }
        }
        /**
         * Clear the wave and progress rendering contexts
         */

      }, {
        key: "clearWave",
        value: function clearWave() {
          // wave
          this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height); // progress

          if (this.hasProgressCanvas) {
            this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);
          }
        }
        /**
         * Set the fill styles for wave and progress
         *
         * @param {string} waveColor Fill color for the wave canvas
         * @param {?string} progressColor Fill color for the progress canvas
         */

      }, {
        key: "setFillStyles",
        value: function setFillStyles(waveColor, progressColor) {
          this.waveCtx.fillStyle = waveColor;

          if (this.hasProgressCanvas) {
            this.progressCtx.fillStyle = progressColor;
          }
        }
        /**
         * Draw a rectangle for wave and progress
         *
         * @param {number} x X start position
         * @param {number} y Y start position
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         */

      }, {
        key: "fillRects",
        value: function fillRects(x, y, width, height, radius) {
          this.fillRectToContext(this.waveCtx, x, y, width, height, radius);

          if (this.hasProgressCanvas) {
            this.fillRectToContext(this.progressCtx, x, y, width, height, radius);
          }
        }
        /**
         * Draw the actual rectangle on a `canvas` element
         *
         * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
         * @param {number} x X start position
         * @param {number} y Y start position
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         */

      }, {
        key: "fillRectToContext",
        value: function fillRectToContext(ctx, x, y, width, height, radius) {
          if (!ctx) {
            return;
          }

          if (radius) {
            this.drawRoundedRect(ctx, x, y, width, height, radius);
          } else {
            ctx.fillRect(x, y, width, height);
          }
        }
        /**
         * Draw a rounded rectangle on Canvas
         *
         * @param {CanvasRenderingContext2D} ctx Canvas context
         * @param {number} x X-position of the rectangle
         * @param {number} y Y-position of the rectangle
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         *
         * @return {void}
         * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)
         */

      }, {
        key: "drawRoundedRect",
        value: function drawRoundedRect(ctx, x, y, width, height, radius) {
          if (height === 0) {
            return;
          } // peaks are float values from -1 to 1. Use absolute height values in
          // order to correctly calculate rounded rectangle coordinates


          if (height < 0) {
            height *= -1;
            y -= height;
          }

          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();
        }
        /**
         * Render the actual wave and progress lines
         *
         * @param {number[]} peaks Array with peaks data
         * @param {number} absmax Maximum peak value (absolute)
         * @param {number} halfH Half the height of the waveform
         * @param {number} offsetY Offset to the top
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that
         * should be rendered
         */

      }, {
        key: "drawLines",
        value: function drawLines(peaks, absmax, halfH, offsetY, start, end) {
          this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY, start, end);

          if (this.hasProgressCanvas) {
            this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY, start, end);
          }
        }
        /**
         * Render the actual waveform line on a `canvas` element
         *
         * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
         * @param {number[]} peaks Array with peaks data
         * @param {number} absmax Maximum peak value (absolute)
         * @param {number} halfH Half the height of the waveform
         * @param {number} offsetY Offset to the top
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that
         * should be rendered
         */

      }, {
        key: "drawLineToContext",
        value: function drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {
          if (!ctx) {
            return;
          }

          var length = peaks.length / 2;
          var first = Math.round(length * this.start); // use one more peak value to make sure we join peaks at ends -- unless,
          // of course, this is the last canvas

          var last = Math.round(length * this.end) + 1;
          var canvasStart = first;
          var canvasEnd = last;
          var scale = this.wave.width / (canvasEnd - canvasStart - 1); // optimization

          var halfOffset = halfH + offsetY;
          var absmaxHalf = absmax / halfH;
          ctx.beginPath();
          ctx.moveTo((canvasStart - first) * scale, halfOffset);
          ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));
          var i, peak, h;

          for (i = canvasStart; i < canvasEnd; i++) {
            peak = peaks[2 * i] || 0;
            h = Math.round(peak / absmaxHalf);
            ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);
          } // draw the bottom edge going backwards, to make a single
          // closed hull to fill


          var j = canvasEnd - 1;

          for (j; j >= canvasStart; j--) {
            peak = peaks[2 * j + 1] || 0;
            h = Math.round(peak / absmaxHalf);
            ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);
          }

          ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));
          ctx.closePath();
          ctx.fill();
        }
        /**
         * Destroys this entry
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.waveCtx = null;
          this.wave = null;
          this.progressCtx = null;
          this.progress = null;
        }
        /**
         * Return image data of the wave `canvas` element
         *
         * When using a `type` of `'blob'`, this will return a `Promise` that
         * resolves with a `Blob` instance.
         *
         * @param {string} format='image/png' An optional value of a format type.
         * @param {number} quality=0.92 An optional value between 0 and 1.
         * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
         * @return {string|Promise} When using the default `'dataURL'` `type` this
         * returns a data URL. When using the `'blob'` `type` this returns a
         * `Promise` that resolves with a `Blob` instance.
         */

      }, {
        key: "getImage",
        value: function getImage(format, quality, type) {
          var _this = this;

          if (type === 'blob') {
            return new Promise(function (resolve) {
              _this.wave.toBlob(resolve, format, quality);
            });
          } else if (type === 'dataURL') {
            return this.wave.toDataURL(format, quality);
          }
        }
      }]);

      return CanvasEntry;
    }();

    exports.default = CanvasEntry;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/drawer.js":
    /*!***********************!*\
      !*** ./src/drawer.js ***!
      \***********************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * Parent class for renderers
     *
     * @extends {Observer}
     */
    var Drawer = /*#__PURE__*/function (_util$Observer) {
      _inherits(Drawer, _util$Observer);

      var _super = _createSuper(Drawer);

      /**
       * @param {HTMLElement} container The container node of the wavesurfer instance
       * @param {WavesurferParams} params The wavesurfer initialisation options
       */
      function Drawer(container, params) {
        var _this;

        _classCallCheck(this, Drawer);

        _this = _super.call(this);
        _this.container = container;
        /**
         * @type {WavesurferParams}
         */

        _this.params = params;
        /**
         * The width of the renderer
         * @type {number}
         */

        _this.width = 0;
        /**
         * The height of the renderer
         * @type {number}
         */

        _this.height = params.height * _this.params.pixelRatio;
        _this.lastPos = 0;
        /**
         * The `<wave>` element which is added to the container
         * @type {HTMLElement}
         */

        _this.wrapper = null;
        return _this;
      }
      /**
       * Alias of `util.style`
       *
       * @param {HTMLElement} el The element that the styles will be applied to
       * @param {Object} styles The map of propName: attribute, both are used as-is
       * @return {HTMLElement} el
       */


      _createClass(Drawer, [{
        key: "style",
        value: function style(el, styles) {
          return util.style(el, styles);
        }
        /**
         * Create the wrapper `<wave>` element, style it and set up the events for
         * interaction
         */

      }, {
        key: "createWrapper",
        value: function createWrapper() {
          this.wrapper = this.container.appendChild(document.createElement('wave'));
          this.style(this.wrapper, {
            display: 'block',
            position: 'relative',
            userSelect: 'none',
            webkitUserSelect: 'none',
            height: this.params.height + 'px'
          });

          if (this.params.fillParent || this.params.scrollParent) {
            this.style(this.wrapper, {
              width: '100%',
              overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
              overflowY: 'hidden'
            });
          }

          this.setupWrapperEvents();
        }
        /**
         * Handle click event
         *
         * @param {Event} e Click event
         * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`
         * @return {number} Playback position from 0 to 1
         */

      }, {
        key: "handleEvent",
        value: function handleEvent(e, noPrevent) {
          !noPrevent && e.preventDefault();
          var clientX = e.targetTouches ? e.targetTouches[0].clientX : e.clientX;
          var bbox = this.wrapper.getBoundingClientRect();
          var nominalWidth = this.width;
          var parentWidth = this.getWidth();
          var progress;

          if (!this.params.fillParent && nominalWidth < parentWidth) {
            progress = (this.params.rtl ? bbox.right - clientX : clientX - bbox.left) * (this.params.pixelRatio / nominalWidth) || 0;
          } else {
            progress = ((this.params.rtl ? bbox.right - clientX : clientX - bbox.left) + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0;
          }

          return util.clamp(progress, 0, 1);
        }
      }, {
        key: "setupWrapperEvents",
        value: function setupWrapperEvents() {
          var _this2 = this;

          this.wrapper.addEventListener('click', function (e) {
            var scrollbarHeight = _this2.wrapper.offsetHeight - _this2.wrapper.clientHeight;

            if (scrollbarHeight !== 0) {
              // scrollbar is visible.  Check if click was on it
              var bbox = _this2.wrapper.getBoundingClientRect();

              if (e.clientY >= bbox.bottom - scrollbarHeight) {
                // ignore mousedown as it was on the scrollbar
                return;
              }
            }

            if (_this2.params.interact) {
              _this2.fireEvent('click', e, _this2.handleEvent(e));
            }
          });
          this.wrapper.addEventListener('dblclick', function (e) {
            if (_this2.params.interact) {
              _this2.fireEvent('dblclick', e, _this2.handleEvent(e));
            }
          });
          this.wrapper.addEventListener('scroll', function (e) {
            return _this2.fireEvent('scroll', e);
          });
        }
        /**
         * Draw peaks on the canvas
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
         * for split channel rendering
         * @param {number} length The width of the area that should be drawn
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         */

      }, {
        key: "drawPeaks",
        value: function drawPeaks(peaks, length, start, end) {
          if (!this.setWidth(length)) {
            this.clearWave();
          }

          this.params.barWidth ? this.drawBars(peaks, 0, start, end) : this.drawWave(peaks, 0, start, end);
        }
        /**
         * Scroll to the beginning
         */

      }, {
        key: "resetScroll",
        value: function resetScroll() {
          if (this.wrapper !== null) {
            this.wrapper.scrollLeft = 0;
          }
        }
        /**
         * Recenter the view-port at a certain percent of the waveform
         *
         * @param {number} percent Value from 0 to 1 on the waveform
         */

      }, {
        key: "recenter",
        value: function recenter(percent) {
          var position = this.wrapper.scrollWidth * percent;
          this.recenterOnPosition(position, true);
        }
        /**
         * Recenter the view-port on a position, either scroll there immediately or
         * in steps of 5 pixels
         *
         * @param {number} position X-offset in pixels
         * @param {boolean} immediate Set to true to immediately scroll somewhere
         */

      }, {
        key: "recenterOnPosition",
        value: function recenterOnPosition(position, immediate) {
          var scrollLeft = this.wrapper.scrollLeft;
          var half = ~~(this.wrapper.clientWidth / 2);
          var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
          var target = position - half;
          var offset = target - scrollLeft;

          if (maxScroll == 0) {
            // no need to continue if scrollbar is not there
            return;
          } // if the cursor is currently visible...


          if (!immediate && -half <= offset && offset < half) {
            // set rate at which waveform is centered
            var rate = this.params.autoCenterRate; // make rate depend on width of view and length of waveform

            rate /= half;
            rate *= maxScroll;
            offset = Math.max(-rate, Math.min(rate, offset));
            target = scrollLeft + offset;
          } // limit target to valid range (0 to maxScroll)


          target = Math.max(0, Math.min(maxScroll, target)); // no use attempting to scroll if we're not moving

          if (target != scrollLeft) {
            this.wrapper.scrollLeft = target;
          }
        }
        /**
         * Get the current scroll position in pixels
         *
         * @return {number} Horizontal scroll position in pixels
         */

      }, {
        key: "getScrollX",
        value: function getScrollX() {
          var x = 0;

          if (this.wrapper) {
            var pixelRatio = this.params.pixelRatio;
            x = Math.round(this.wrapper.scrollLeft * pixelRatio); // In cases of elastic scroll (safari with mouse wheel) you can
            // scroll beyond the limits of the container
            // Calculate and floor the scrollable extent to make sure an out
            // of bounds value is not returned
            // Ticket #1312

            if (this.params.scrollParent) {
              var maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio - this.getWidth());
              x = Math.min(maxScroll, Math.max(0, x));
            }
          }

          return x;
        }
        /**
         * Get the width of the container
         *
         * @return {number} The width of the container
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return Math.round(this.container.clientWidth * this.params.pixelRatio);
        }
        /**
         * Set the width of the container
         *
         * @param {number} width The new width of the container
         * @return {boolean} Whether the width of the container was updated or not
         */

      }, {
        key: "setWidth",
        value: function setWidth(width) {
          if (this.width == width) {
            return false;
          }

          this.width = width;

          if (this.params.fillParent || this.params.scrollParent) {
            this.style(this.wrapper, {
              width: ''
            });
          } else {
            this.style(this.wrapper, {
              width: ~~(this.width / this.params.pixelRatio) + 'px'
            });
          }

          this.updateSize();
          return true;
        }
        /**
         * Set the height of the container
         *
         * @param {number} height The new height of the container.
         * @return {boolean} Whether the height of the container was updated or not
         */

      }, {
        key: "setHeight",
        value: function setHeight(height) {
          if (height == this.height) {
            return false;
          }

          this.height = height;
          this.style(this.wrapper, {
            height: ~~(this.height / this.params.pixelRatio) + 'px'
          });
          this.updateSize();
          return true;
        }
        /**
         * Called by wavesurfer when progress should be rendered
         *
         * @param {number} progress From 0 to 1
         */

      }, {
        key: "progress",
        value: function progress(_progress) {
          var minPxDelta = 1 / this.params.pixelRatio;
          var pos = Math.round(_progress * this.width) * minPxDelta;

          if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
            this.lastPos = pos;

            if (this.params.scrollParent && this.params.autoCenter) {
              var newPos = ~~(this.wrapper.scrollWidth * _progress);
              this.recenterOnPosition(newPos, this.params.autoCenterImmediately);
            }

            this.updateProgress(pos);
          }
        }
        /**
         * This is called when wavesurfer is destroyed
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.unAll();

          if (this.wrapper) {
            if (this.wrapper.parentNode == this.container) {
              this.container.removeChild(this.wrapper);
            }

            this.wrapper = null;
          }
        }
        /* Renderer-specific methods */

        /**
         * Called after cursor related params have changed.
         *
         * @abstract
         */

      }, {
        key: "updateCursor",
        value: function updateCursor() {}
        /**
         * Called when the size of the container changes so the renderer can adjust
         *
         * @abstract
         */

      }, {
        key: "updateSize",
        value: function updateSize() {}
        /**
         * Draw a waveform with bars
         *
         * @abstract
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
         * rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         */

      }, {
        key: "drawBars",
        value: function drawBars(peaks, channelIndex, start, end) {}
        /**
         * Draw a waveform
         *
         * @abstract
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
         * rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         */

      }, {
        key: "drawWave",
        value: function drawWave(peaks, channelIndex, start, end) {}
        /**
         * Clear the waveform
         *
         * @abstract
         */

      }, {
        key: "clearWave",
        value: function clearWave() {}
        /**
         * Render the new progress
         *
         * @abstract
         * @param {number} position X-Offset of progress position in pixels
         */

      }, {
        key: "updateProgress",
        value: function updateProgress(position) {}
      }]);

      return Drawer;
    }(util.Observer);

    exports.default = Drawer;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/drawer.multicanvas.js":
    /*!***********************************!*\
      !*** ./src/drawer.multicanvas.js ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _drawer = _interopRequireDefault(__webpack_require__(/*! ./drawer */ "./src/drawer.js"));

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    var _drawer2 = _interopRequireDefault(__webpack_require__(/*! ./drawer.canvasentry */ "./src/drawer.canvasentry.js"));

    function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * MultiCanvas renderer for wavesurfer. Is currently the default and sole
     * builtin renderer.
     *
     * A `MultiCanvas` consists of one or more `CanvasEntry` instances, depending
     * on the zoom level.
     */
    var MultiCanvas = /*#__PURE__*/function (_Drawer) {
      _inherits(MultiCanvas, _Drawer);

      var _super = _createSuper(MultiCanvas);

      /**
       * @param {HTMLElement} container The container node of the wavesurfer instance
       * @param {WavesurferParams} params The wavesurfer initialisation options
       */
      function MultiCanvas(container, params) {
        var _this;

        _classCallCheck(this, MultiCanvas);

        _this = _super.call(this, container, params);
        /**
         * @type {number}
         */

        _this.maxCanvasWidth = params.maxCanvasWidth;
        /**
         * @type {number}
         */

        _this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);
        /**
         * Whether or not the progress wave is rendered. If the `waveColor`
         * and `progressColor` are the same color it is not.
         *
         * @type {boolean}
         */

        _this.hasProgressCanvas = params.waveColor != params.progressColor;
        /**
         * @type {number}
         */

        _this.halfPixel = 0.5 / params.pixelRatio;
        /**
         * List of `CanvasEntry` instances.
         *
         * @type {Array}
         */

        _this.canvases = [];
        /**
         * @type {HTMLElement}
         */

        _this.progressWave = null;
        /**
         * Class used to generate entries.
         *
         * @type {function}
         */

        _this.EntryClass = _drawer2.default;
        /**
         * Canvas 2d context attributes.
         *
         * @type {object}
         */

        _this.canvasContextAttributes = params.drawingContextAttributes;
        /**
         * Overlap added between entries to prevent vertical white stripes
         * between `canvas` elements.
         *
         * @type {number}
         */

        _this.overlap = 2 * Math.ceil(params.pixelRatio / 2);
        /**
         * The radius of the wave bars. Makes bars rounded
         *
         * @type {number}
         */

        _this.barRadius = params.barRadius || 0;
        return _this;
      }
      /**
       * Initialize the drawer
       */


      _createClass(MultiCanvas, [{
        key: "init",
        value: function init() {
          this.createWrapper();
          this.createElements();
        }
        /**
         * Create the canvas elements and style them
         *
         */

      }, {
        key: "createElements",
        value: function createElements() {
          this.progressWave = this.wrapper.appendChild(this.style(document.createElement('wave'), {
            position: 'absolute',
            zIndex: 3,
            left: 0,
            top: 0,
            bottom: 0,
            overflow: 'hidden',
            width: '0',
            display: 'none',
            boxSizing: 'border-box',
            borderRightStyle: 'solid',
            pointerEvents: 'none'
          }));
          this.addCanvas();
          this.updateCursor();
        }
        /**
         * Update cursor style
         */

      }, {
        key: "updateCursor",
        value: function updateCursor() {
          this.style(this.progressWave, {
            borderRightWidth: this.params.cursorWidth + 'px',
            borderRightColor: this.params.cursorColor
          });
        }
        /**
         * Adjust to the updated size by adding or removing canvases
         */

      }, {
        key: "updateSize",
        value: function updateSize() {
          var _this2 = this;

          var totalWidth = Math.round(this.width / this.params.pixelRatio);
          var requiredCanvases = Math.ceil(totalWidth / (this.maxCanvasElementWidth + this.overlap)); // add required canvases

          while (this.canvases.length < requiredCanvases) {
            this.addCanvas();
          } // remove older existing canvases, if any


          while (this.canvases.length > requiredCanvases) {
            this.removeCanvas();
          }

          var canvasWidth = this.maxCanvasWidth + this.overlap;
          var lastCanvas = this.canvases.length - 1;
          this.canvases.forEach(function (entry, i) {
            if (i == lastCanvas) {
              canvasWidth = _this2.width - _this2.maxCanvasWidth * lastCanvas;
            }

            _this2.updateDimensions(entry, canvasWidth, _this2.height);

            entry.clearWave();
          });
        }
        /**
         * Add a canvas to the canvas list
         *
         */

      }, {
        key: "addCanvas",
        value: function addCanvas() {
          var entry = new this.EntryClass();
          entry.canvasContextAttributes = this.canvasContextAttributes;
          entry.hasProgressCanvas = this.hasProgressCanvas;
          entry.halfPixel = this.halfPixel;
          var leftOffset = this.maxCanvasElementWidth * this.canvases.length; // wave

          entry.initWave(this.wrapper.appendChild(this.style(document.createElement('canvas'), {
            position: 'absolute',
            zIndex: 2,
            left: leftOffset + 'px',
            top: 0,
            bottom: 0,
            height: '100%',
            pointerEvents: 'none'
          }))); // progress

          if (this.hasProgressCanvas) {
            entry.initProgress(this.progressWave.appendChild(this.style(document.createElement('canvas'), {
              position: 'absolute',
              left: leftOffset + 'px',
              top: 0,
              bottom: 0,
              height: '100%'
            })));
          }

          this.canvases.push(entry);
        }
        /**
         * Pop single canvas from the list
         *
         */

      }, {
        key: "removeCanvas",
        value: function removeCanvas() {
          var lastEntry = this.canvases[this.canvases.length - 1]; // wave

          lastEntry.wave.parentElement.removeChild(lastEntry.wave); // progress

          if (this.hasProgressCanvas) {
            lastEntry.progress.parentElement.removeChild(lastEntry.progress);
          } // cleanup


          if (lastEntry) {
            lastEntry.destroy();
            lastEntry = null;
          }

          this.canvases.pop();
        }
        /**
         * Update the dimensions of a canvas element
         *
         * @param {CanvasEntry} entry Target entry
         * @param {number} width The new width of the element
         * @param {number} height The new height of the element
         */

      }, {
        key: "updateDimensions",
        value: function updateDimensions(entry, width, height) {
          var elementWidth = Math.round(width / this.params.pixelRatio);
          var totalWidth = Math.round(this.width / this.params.pixelRatio); // update canvas dimensions

          entry.updateDimensions(elementWidth, totalWidth, width, height); // style element

          this.style(this.progressWave, {
            display: 'block'
          });
        }
        /**
         * Clear the whole multi-canvas
         */

      }, {
        key: "clearWave",
        value: function clearWave() {
          var _this3 = this;

          util.frame(function () {
            _this3.canvases.forEach(function (entry) {
              return entry.clearWave();
            });
          })();
        }
        /**
         * Draw a waveform with bars
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
         * for split channel rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0. Must be an integer.
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that should be
         * rendered
         * @returns {void}
         */

      }, {
        key: "drawBars",
        value: function drawBars(peaks, channelIndex, start, end) {
          var _this4 = this;

          return this.prepareDraw(peaks, channelIndex, start, end, function (_ref) {
            var absmax = _ref.absmax,
                hasMinVals = _ref.hasMinVals,
                height = _ref.height,
                offsetY = _ref.offsetY,
                halfH = _ref.halfH,
                peaks = _ref.peaks;

            // if drawBars was called within ws.empty we don't pass a start and
            // don't want anything to happen
            if (start === undefined) {
              return;
            } // Skip every other value if there are negatives.


            var peakIndexScale = hasMinVals ? 2 : 1;
            var length = peaks.length / peakIndexScale;
            var bar = _this4.params.barWidth * _this4.params.pixelRatio;
            var gap = _this4.params.barGap === null ? Math.max(_this4.params.pixelRatio, ~~(bar / 2)) : Math.max(_this4.params.pixelRatio, _this4.params.barGap * _this4.params.pixelRatio);
            var step = bar + gap;
            var scale = length / _this4.width;
            var first = start;
            var last = end;
            var i = first;

            for (i; i < last; i += step) {
              var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
              var h = Math.round(peak / absmax * halfH);
              /* in case of silences, allow the user to specify that we
               * always draw *something* (normally a 1px high bar) */

              if (h == 0 && _this4.params.barMinHeight) h = _this4.params.barMinHeight;

              _this4.fillRect(i + _this4.halfPixel, halfH - h + offsetY, bar + _this4.halfPixel, h * 2, _this4.barRadius);
            }
          });
        }
        /**
         * Draw a waveform
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
         * for split channel rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number?} start The x-offset of the beginning of the area that
         * should be rendered (If this isn't set only a flat line is rendered)
         * @param {number?} end The x-offset of the end of the area that should be
         * rendered
         * @returns {void}
         */

      }, {
        key: "drawWave",
        value: function drawWave(peaks, channelIndex, start, end) {
          var _this5 = this;

          return this.prepareDraw(peaks, channelIndex, start, end, function (_ref2) {
            var absmax = _ref2.absmax,
                hasMinVals = _ref2.hasMinVals,
                height = _ref2.height,
                offsetY = _ref2.offsetY,
                halfH = _ref2.halfH,
                peaks = _ref2.peaks,
                channelIndex = _ref2.channelIndex;

            if (!hasMinVals) {
              var reflectedPeaks = [];
              var len = peaks.length;
              var i = 0;

              for (i; i < len; i++) {
                reflectedPeaks[2 * i] = peaks[i];
                reflectedPeaks[2 * i + 1] = -peaks[i];
              }

              peaks = reflectedPeaks;
            } // if drawWave was called within ws.empty we don't pass a start and
            // end and simply want a flat line


            if (start !== undefined) {
              _this5.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);
            } // always draw a median line


            _this5.fillRect(0, halfH + offsetY - _this5.halfPixel, _this5.width, _this5.halfPixel, _this5.barRadius);
          });
        }
        /**
         * Tell the canvas entries to render their portion of the waveform
         *
         * @param {number[]} peaks Peaks data
         * @param {number} absmax Maximum peak value (absolute)
         * @param {number} halfH Half the height of the waveform
         * @param {number} offsetY Offset to the top
         * @param {number} start The x-offset of the beginning of the area that
         * should be rendered
         * @param {number} end The x-offset of the end of the area that
         * should be rendered
         * @param {channelIndex} channelIndex The channel index of the line drawn
         */

      }, {
        key: "drawLine",
        value: function drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {
          var _this6 = this;

          var _ref3 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
              waveColor = _ref3.waveColor,
              progressColor = _ref3.progressColor;

          this.canvases.forEach(function (entry, i) {
            _this6.setFillStyles(entry, waveColor, progressColor);

            entry.drawLines(peaks, absmax, halfH, offsetY, start, end);
          });
        }
        /**
         * Draw a rectangle on the multi-canvas
         *
         * @param {number} x X-position of the rectangle
         * @param {number} y Y-position of the rectangle
         * @param {number} width Width of the rectangle
         * @param {number} height Height of the rectangle
         * @param {number} radius Radius of the rectangle
         */

      }, {
        key: "fillRect",
        value: function fillRect(x, y, width, height, radius) {
          var startCanvas = Math.floor(x / this.maxCanvasWidth);
          var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
          var i = startCanvas;

          for (i; i < endCanvas; i++) {
            var entry = this.canvases[i];
            var leftOffset = i * this.maxCanvasWidth;
            var intersection = {
              x1: Math.max(x, i * this.maxCanvasWidth),
              y1: y,
              x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
              y2: y + height
            };

            if (intersection.x1 < intersection.x2) {
              this.setFillStyles(entry);
              entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
            }
          }
        }
        /**
         * Returns whether to hide the channel from being drawn based on params.
         *
         * @param {number} channelIndex The index of the current channel.
         * @returns {bool} True to hide the channel, false to draw.
         */

      }, {
        key: "hideChannel",
        value: function hideChannel(channelIndex) {
          return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);
        }
        /**
         * Performs preparation tasks and calculations which are shared by `drawBars`
         * and `drawWave`
         *
         * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for
         * split channel rendering
         * @param {number} channelIndex The index of the current channel. Normally
         * should be 0
         * @param {number?} start The x-offset of the beginning of the area that
         * should be rendered. If this isn't set only a flat line is rendered
         * @param {number?} end The x-offset of the end of the area that should be
         * rendered
         * @param {function} fn The render function to call, e.g. `drawWave`
         * @param {number} drawIndex The index of the current channel after filtering.
         * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined
         * @returns {void}
         */

      }, {
        key: "prepareDraw",
        value: function prepareDraw(peaks, channelIndex, start, end, fn, drawIndex, normalizedMax) {
          var _this7 = this;

          return util.frame(function () {
            // Split channels and call this function with the channelIndex set
            if (peaks[0] instanceof Array) {
              var channels = peaks;

              if (_this7.params.splitChannels) {
                var filteredChannels = channels.filter(function (c, i) {
                  return !_this7.hideChannel(i);
                });

                if (!_this7.params.splitChannelsOptions.overlay) {
                  _this7.setHeight(Math.max(filteredChannels.length, 1) * _this7.params.height * _this7.params.pixelRatio);
                }

                var overallAbsMax;

                if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.relativeNormalization) {
                  // calculate maximum peak across channels to use for normalization
                  overallAbsMax = util.max(channels.map(function (channelPeaks) {
                    return util.absMax(channelPeaks);
                  }));
                }

                return channels.forEach(function (channelPeaks, i) {
                  return _this7.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks), overallAbsMax);
                });
              }

              peaks = channels[0];
            } // Return and do not draw channel peaks if hidden.


            if (_this7.hideChannel(channelIndex)) {
              return;
            } // calculate maximum modulation value, either from the barHeight
            // parameter or if normalize=true from the largest value in the peak
            // set


            var absmax = 1 / _this7.params.barHeight;

            if (_this7.params.normalize) {
              absmax = normalizedMax === undefined ? util.absMax(peaks) : normalizedMax;
            } // Bar wave draws the bottom only as a reflection of the top,
            // so we don't need negative values


            var hasMinVals = [].some.call(peaks, function (val) {
              return val < 0;
            });
            var height = _this7.params.height * _this7.params.pixelRatio;
            var offsetY = height * drawIndex || 0;
            var halfH = height / 2;
            return fn({
              absmax: absmax,
              hasMinVals: hasMinVals,
              height: height,
              offsetY: offsetY,
              halfH: halfH,
              peaks: peaks,
              channelIndex: channelIndex
            });
          })();
        }
        /**
         * Set the fill styles for a certain entry (wave and progress)
         *
         * @param {CanvasEntry} entry Target entry
         * @param {string} waveColor Wave color to draw this entry
         * @param {string} progressColor Progress color to draw this entry
         */

      }, {
        key: "setFillStyles",
        value: function setFillStyles(entry) {
          var waveColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.waveColor;
          var progressColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.params.progressColor;
          entry.setFillStyles(waveColor, progressColor);
        }
        /**
         * Return image data of the multi-canvas
         *
         * When using a `type` of `'blob'`, this will return a `Promise`.
         *
         * @param {string} format='image/png' An optional value of a format type.
         * @param {number} quality=0.92 An optional value between 0 and 1.
         * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
         * @return {string|string[]|Promise} When using the default `'dataURL'`
         * `type` this returns a single data URL or an array of data URLs,
         * one for each canvas. When using the `'blob'` `type` this returns a
         * `Promise` that resolves with an array of `Blob` instances, one for each
         * canvas.
         */

      }, {
        key: "getImage",
        value: function getImage(format, quality, type) {
          if (type === 'blob') {
            return Promise.all(this.canvases.map(function (entry) {
              return entry.getImage(format, quality, type);
            }));
          } else if (type === 'dataURL') {
            var images = this.canvases.map(function (entry) {
              return entry.getImage(format, quality, type);
            });
            return images.length > 1 ? images : images[0];
          }
        }
        /**
         * Render the new progress
         *
         * @param {number} position X-offset of progress position in pixels
         */

      }, {
        key: "updateProgress",
        value: function updateProgress(position) {
          this.style(this.progressWave, {
            width: position + 'px'
          });
        }
      }]);

      return MultiCanvas;
    }(_drawer.default);

    exports.default = MultiCanvas;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/mediaelement-webaudio.js":
    /*!**************************************!*\
      !*** ./src/mediaelement-webaudio.js ***!
      \**************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _mediaelement = _interopRequireDefault(__webpack_require__(/*! ./mediaelement */ "./src/mediaelement.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

    function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * MediaElementWebAudio backend: load audio via an HTML5 audio tag, but playback with the WebAudio API.
     * The advantage here is that the html5 <audio> tag can perform range requests on the server and not
     * buffer the entire file in one request, and you still get the filtering and scripting functionality
     * of the webaudio API.
     * Note that in order to use range requests and prevent buffering, you must provide peak data.
     *
     * @since 3.2.0
     */
    var MediaElementWebAudio = /*#__PURE__*/function (_MediaElement) {
      _inherits(MediaElementWebAudio, _MediaElement);

      var _super = _createSuper(MediaElementWebAudio);

      /**
       * Construct the backend
       *
       * @param {WavesurferParams} params Wavesurfer parameters
       */
      function MediaElementWebAudio(params) {
        var _this;

        _classCallCheck(this, MediaElementWebAudio);

        _this = _super.call(this, params);
        /** @private */

        _this.params = params;
        /** @private */

        _this.sourceMediaElement = null;
        return _this;
      }
      /**
       * Initialise the backend, called in `wavesurfer.createBackend()`
       */


      _createClass(MediaElementWebAudio, [{
        key: "init",
        value: function init() {
          this.setPlaybackRate(this.params.audioRate);
          this.createTimer();
          this.createVolumeNode();
          this.createScriptNode();
          this.createAnalyserNode();
        }
        /**
         * Private method called by both `load` (from url)
         * and `loadElt` (existing media element) methods.
         *
         * @param {HTMLMediaElement} media HTML5 Audio or Video element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         * @param {string} preload HTML 5 preload attribute value
         * @private
         */

      }, {
        key: "_load",
        value: function _load(media, peaks, preload) {
          _get(_getPrototypeOf(MediaElementWebAudio.prototype), "_load", this).call(this, media, peaks, preload);

          this.createMediaElementSource(media);
        }
        /**
         * Create MediaElementSource node
         *
         * @since 3.2.0
         * @param {HTMLMediaElement} mediaElement HTML5 Audio to load
         */

      }, {
        key: "createMediaElementSource",
        value: function createMediaElementSource(mediaElement) {
          this.sourceMediaElement = this.ac.createMediaElementSource(mediaElement);
          this.sourceMediaElement.connect(this.analyser);
        }
      }, {
        key: "play",
        value: function play(start, end) {
          this.resumeAudioContext();
          return _get(_getPrototypeOf(MediaElementWebAudio.prototype), "play", this).call(this, start, end);
        }
        /**
         * This is called when wavesurfer is destroyed
         *
         */

      }, {
        key: "destroy",
        value: function destroy() {
          _get(_getPrototypeOf(MediaElementWebAudio.prototype), "destroy", this).call(this);

          this.destroyWebAudio();
        }
      }]);

      return MediaElementWebAudio;
    }(_mediaelement.default);

    exports.default = MediaElementWebAudio;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/mediaelement.js":
    /*!*****************************!*\
      !*** ./src/mediaelement.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _webaudio = _interopRequireDefault(__webpack_require__(/*! ./webaudio */ "./src/webaudio.js"));

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

    function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    /**
     * MediaElement backend
     */
    var MediaElement = /*#__PURE__*/function (_WebAudio) {
      _inherits(MediaElement, _WebAudio);

      var _super = _createSuper(MediaElement);

      /**
       * Construct the backend
       *
       * @param {WavesurferParams} params Wavesurfer parameters
       */
      function MediaElement(params) {
        var _this;

        _classCallCheck(this, MediaElement);

        _this = _super.call(this, params);
        /** @private */

        _this.params = params;
        /**
         * Initially a dummy media element to catch errors. Once `_load` is
         * called, this will contain the actual `HTMLMediaElement`.
         * @private
         */

        _this.media = {
          currentTime: 0,
          duration: 0,
          paused: true,
          playbackRate: 1,
          play: function play() {},
          pause: function pause() {},
          volume: 0
        };
        /** @private */

        _this.mediaType = params.mediaType.toLowerCase();
        /** @private */

        _this.elementPosition = params.elementPosition;
        /** @private */

        _this.peaks = null;
        /** @private */

        _this.playbackRate = 1;
        /** @private */

        _this.volume = 1;
        /** @private */

        _this.isMuted = false;
        /** @private */

        _this.buffer = null;
        /** @private */

        _this.onPlayEnd = null;
        /** @private */

        _this.mediaListeners = {};
        return _this;
      }
      /**
       * Initialise the backend, called in `wavesurfer.createBackend()`
       */


      _createClass(MediaElement, [{
        key: "init",
        value: function init() {
          this.setPlaybackRate(this.params.audioRate);
          this.createTimer();
        }
        /**
         * Attach event listeners to media element.
         */

      }, {
        key: "_setupMediaListeners",
        value: function _setupMediaListeners() {
          var _this2 = this;

          this.mediaListeners.error = function () {
            _this2.fireEvent('error', 'Error loading media element');
          };

          this.mediaListeners.canplay = function () {
            _this2.fireEvent('canplay');
          };

          this.mediaListeners.ended = function () {
            _this2.fireEvent('finish');
          }; // listen to and relay play, pause and seeked events to enable
          // playback control from the external media element


          this.mediaListeners.play = function () {
            _this2.fireEvent('play');
          };

          this.mediaListeners.pause = function () {
            _this2.fireEvent('pause');
          };

          this.mediaListeners.seeked = function (event) {
            _this2.fireEvent('seek');
          };

          this.mediaListeners.volumechange = function (event) {
            _this2.isMuted = _this2.media.muted;

            if (_this2.isMuted) {
              _this2.volume = 0;
            } else {
              _this2.volume = _this2.media.volume;
            }

            _this2.fireEvent('volume');
          }; // reset event listeners


          Object.keys(this.mediaListeners).forEach(function (id) {
            _this2.media.removeEventListener(id, _this2.mediaListeners[id]);

            _this2.media.addEventListener(id, _this2.mediaListeners[id]);
          });
        }
        /**
         * Create a timer to provide a more precise `audioprocess` event.
         */

      }, {
        key: "createTimer",
        value: function createTimer() {
          var _this3 = this;

          var onAudioProcess = function onAudioProcess() {
            if (_this3.isPaused()) {
              return;
            }

            _this3.fireEvent('audioprocess', _this3.getCurrentTime()); // Call again in the next frame


            util.frame(onAudioProcess)();
          };

          this.on('play', onAudioProcess); // Update the progress one more time to prevent it from being stuck in
          // case of lower framerates

          this.on('pause', function () {
            _this3.fireEvent('audioprocess', _this3.getCurrentTime());
          });
        }
        /**
         * Create media element with url as its source,
         * and append to container element.
         *
         * @param {string} url Path to media file
         * @param {HTMLElement} container HTML element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         * @param {string} preload HTML 5 preload attribute value
         * @throws Will throw an error if the `url` argument is not a valid media
         * element.
         */

      }, {
        key: "load",
        value: function load(url, container, peaks, preload) {
          var media = document.createElement(this.mediaType);
          media.controls = this.params.mediaControls;
          media.autoplay = this.params.autoplay || false;
          media.preload = preload == null ? 'auto' : preload;
          media.src = url;
          media.style.width = '100%';
          var prevMedia = container.querySelector(this.mediaType);

          if (prevMedia) {
            container.removeChild(prevMedia);
          }

          container.appendChild(media);

          this._load(media, peaks, preload);
        }
        /**
         * Load existing media element.
         *
         * @param {HTMLMediaElement} elt HTML5 Audio or Video element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         */

      }, {
        key: "loadElt",
        value: function loadElt(elt, peaks) {
          elt.controls = this.params.mediaControls;
          elt.autoplay = this.params.autoplay || false;

          this._load(elt, peaks, elt.preload);
        }
        /**
         * Method called by both `load` (from url)
         * and `loadElt` (existing media element) methods.
         *
         * @param {HTMLMediaElement} media HTML5 Audio or Video element
         * @param {number[]|Number.<Array[]>} peaks Array of peak data
         * @param {string} preload HTML 5 preload attribute value
         * @throws Will throw an error if the `media` argument is not a valid media
         * element.
         * @private
         */

      }, {
        key: "_load",
        value: function _load(media, peaks, preload) {
          // verify media element is valid
          if (!(media instanceof HTMLMediaElement) || typeof media.addEventListener === 'undefined') {
            throw new Error('media parameter is not a valid media element');
          } // load must be called manually on iOS, otherwise peaks won't draw
          // until a user interaction triggers load --> 'ready' event
          //
          // note that we avoid calling media.load here when given peaks and preload == 'none'
          // as this almost always triggers some browser fetch of the media.


          if (typeof media.load == 'function' && !(peaks && preload == 'none')) {
            // Resets the media element and restarts the media resource. Any
            // pending events are discarded. How much media data is fetched is
            // still affected by the preload attribute.
            media.load();
          }

          this.media = media;

          this._setupMediaListeners();

          this.peaks = peaks;
          this.onPlayEnd = null;
          this.buffer = null;
          this.isMuted = media.muted;
          this.setPlaybackRate(this.playbackRate);
          this.setVolume(this.volume);
        }
        /**
         * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
         *
         * @return {boolean} Media paused or not
         */

      }, {
        key: "isPaused",
        value: function isPaused() {
          return !this.media || this.media.paused;
        }
        /**
         * Used by `wavesurfer.getDuration()`
         *
         * @return {number} Duration
         */

      }, {
        key: "getDuration",
        value: function getDuration() {
          if (this.explicitDuration) {
            return this.explicitDuration;
          }

          var duration = (this.buffer || this.media).duration;

          if (duration >= Infinity) {
            // streaming audio
            duration = this.media.seekable.end(0);
          }

          return duration;
        }
        /**
         * Returns the current time in seconds relative to the audio-clip's
         * duration.
         *
         * @return {number} Current time
         */

      }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
          return this.media && this.media.currentTime;
        }
        /**
         * Get the position from 0 to 1
         *
         * @return {number} Current position
         */

      }, {
        key: "getPlayedPercents",
        value: function getPlayedPercents() {
          return this.getCurrentTime() / this.getDuration() || 0;
        }
        /**
         * Get the audio source playback rate.
         *
         * @return {number} Playback rate
         */

      }, {
        key: "getPlaybackRate",
        value: function getPlaybackRate() {
          return this.playbackRate || this.media.playbackRate;
        }
        /**
         * Set the audio source playback rate.
         *
         * @param {number} value Playback rate
         */

      }, {
        key: "setPlaybackRate",
        value: function setPlaybackRate(value) {
          this.playbackRate = value || 1;
          this.media.playbackRate = this.playbackRate;
        }
        /**
         * Used by `wavesurfer.seekTo()`
         *
         * @param {number} start Position to start at in seconds
         */

      }, {
        key: "seekTo",
        value: function seekTo(start) {
          if (start != null) {
            this.media.currentTime = start;
          }

          this.clearPlayEnd();
        }
        /**
         * Plays the loaded audio region.
         *
         * @param {number} start Start offset in seconds, relative to the beginning
         * of a clip.
         * @param {number} end When to stop, relative to the beginning of a clip.
         * @emits MediaElement#play
         * @return {Promise} Result
         */

      }, {
        key: "play",
        value: function play(start, end) {
          this.seekTo(start);
          var promise = this.media.play();
          end && this.setPlayEnd(end);
          return promise;
        }
        /**
         * Pauses the loaded audio.
         *
         * @emits MediaElement#pause
         * @return {Promise} Result
         */

      }, {
        key: "pause",
        value: function pause() {
          var promise;

          if (this.media) {
            promise = this.media.pause();
          }

          this.clearPlayEnd();
          return promise;
        }
        /**
         * Set the play end
         *
         * @param {number} end Where to end
         */

      }, {
        key: "setPlayEnd",
        value: function setPlayEnd(end) {
          var _this4 = this;

          this.clearPlayEnd();

          this._onPlayEnd = function (time) {
            if (time >= end) {
              _this4.pause();

              _this4.seekTo(end);
            }
          };

          this.on('audioprocess', this._onPlayEnd);
        }
        /** @private */

      }, {
        key: "clearPlayEnd",
        value: function clearPlayEnd() {
          if (this._onPlayEnd) {
            this.un('audioprocess', this._onPlayEnd);
            this._onPlayEnd = null;
          }
        }
        /**
         * Compute the max and min value of the waveform when broken into
         * <length> subranges.
         *
         * @param {number} length How many subranges to break the waveform into.
         * @param {number} first First sample in the required range.
         * @param {number} last Last sample in the required range.
         * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of
         * arrays of peaks consisting of (max, min) values for each subrange.
         */

      }, {
        key: "getPeaks",
        value: function getPeaks(length, first, last) {
          if (this.buffer) {
            return _get(_getPrototypeOf(MediaElement.prototype), "getPeaks", this).call(this, length, first, last);
          }

          return this.peaks || [];
        }
        /**
         * Set the sink id for the media player
         *
         * @param {string} deviceId String value representing audio device id.
         * @returns {Promise} A Promise that resolves to `undefined` when there
         * are no errors.
         */

      }, {
        key: "setSinkId",
        value: function setSinkId(deviceId) {
          if (deviceId) {
            if (!this.media.setSinkId) {
              return Promise.reject(new Error('setSinkId is not supported in your browser'));
            }

            return this.media.setSinkId(deviceId);
          }

          return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
        }
        /**
         * Get the current volume
         *
         * @return {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "getVolume",
        value: function getVolume() {
          return this.volume;
        }
        /**
         * Set the audio volume
         *
         * @param {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "setVolume",
        value: function setVolume(value) {
          this.volume = value; // no need to change when it's already at that volume

          if (this.media.volume !== this.volume) {
            this.media.volume = this.volume;
          }
        }
        /**
         * Enable or disable muted audio
         *
         * @since 4.0.0
         * @param {boolean} muted Specify `true` to mute audio.
         */

      }, {
        key: "setMute",
        value: function setMute(muted) {
          // This causes a volume change to be emitted too through the
          // volumechange event listener.
          this.isMuted = this.media.muted = muted;
        }
        /**
         * This is called when wavesurfer is destroyed
         *
         */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this5 = this;

          this.pause();
          this.unAll();
          this.destroyed = true; // cleanup media event listeners

          Object.keys(this.mediaListeners).forEach(function (id) {
            if (_this5.media) {
              _this5.media.removeEventListener(id, _this5.mediaListeners[id]);
            }
          });

          if (this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode) {
            this.media.parentNode.removeChild(this.media);
          }

          this.media = null;
        }
      }]);

      return MediaElement;
    }(_webaudio.default);

    exports.default = MediaElement;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/peakcache.js":
    /*!**************************!*\
      !*** ./src/peakcache.js ***!
      \**************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    /**
     * Caches the decoded peaks data to improve rendering speed for large audio
     *
     * Is used if the option parameter `partialRender` is set to `true`
     */
    var PeakCache = /*#__PURE__*/function () {
      /**
       * Instantiate cache
       */
      function PeakCache() {
        _classCallCheck(this, PeakCache);

        this.clearPeakCache();
      }
      /**
       * Empty the cache
       */


      _createClass(PeakCache, [{
        key: "clearPeakCache",
        value: function clearPeakCache() {
          /**
           * Flat array with entries that are always in pairs to mark the
           * beginning and end of each subrange.  This is a convenience so we can
           * iterate over the pairs for easy set difference operations.
           * @private
           */
          this.peakCacheRanges = [];
          /**
           * Length of the entire cachable region, used for resetting the cache
           * when this changes (zoom events, for instance).
           * @private
           */

          this.peakCacheLength = -1;
        }
        /**
         * Add a range of peaks to the cache
         *
         * @param {number} length The length of the range
         * @param {number} start The x offset of the start of the range
         * @param {number} end The x offset of the end of the range
         * @return {Number.<Array[]>} Array with arrays of numbers
         */

      }, {
        key: "addRangeToPeakCache",
        value: function addRangeToPeakCache(length, start, end) {
          if (length != this.peakCacheLength) {
            this.clearPeakCache();
            this.peakCacheLength = length;
          } // Return ranges that weren't in the cache before the call.


          var uncachedRanges = [];
          var i = 0; // Skip ranges before the current start.

          while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
            i++;
          } // If |i| is even, |start| falls after an existing range.  Otherwise,
          // |start| falls between an existing range, and the uncached region
          // starts when we encounter the next node in |peakCacheRanges| or
          // |end|, whichever comes first.


          if (i % 2 == 0) {
            uncachedRanges.push(start);
          }

          while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
            uncachedRanges.push(this.peakCacheRanges[i]);
            i++;
          } // If |i| is even, |end| is after all existing ranges.


          if (i % 2 == 0) {
            uncachedRanges.push(end);
          } // Filter out the 0-length ranges.


          uncachedRanges = uncachedRanges.filter(function (item, pos, arr) {
            if (pos == 0) {
              return item != arr[pos + 1];
            } else if (pos == arr.length - 1) {
              return item != arr[pos - 1];
            }

            return item != arr[pos - 1] && item != arr[pos + 1];
          }); // Merge the two ranges together, uncachedRanges will either contain
          // wholly new points, or duplicates of points in peakCacheRanges.  If
          // duplicates are detected, remove both and extend the range.

          this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
          this.peakCacheRanges = this.peakCacheRanges.sort(function (a, b) {
            return a - b;
          }).filter(function (item, pos, arr) {
            if (pos == 0) {
              return item != arr[pos + 1];
            } else if (pos == arr.length - 1) {
              return item != arr[pos - 1];
            }

            return item != arr[pos - 1] && item != arr[pos + 1];
          }); // Push the uncached ranges into an array of arrays for ease of
          // iteration in the functions that call this.

          var uncachedRangePairs = [];

          for (i = 0; i < uncachedRanges.length; i += 2) {
            uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i + 1]]);
          }

          return uncachedRangePairs;
        }
        /**
         * For testing
         *
         * @return {Number.<Array[]>} Array with arrays of numbers
         */

      }, {
        key: "getCacheRanges",
        value: function getCacheRanges() {
          var peakCacheRangePairs = [];
          var i;

          for (i = 0; i < this.peakCacheRanges.length; i += 2) {
            peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i + 1]]);
          }

          return peakCacheRangePairs;
        }
      }]);

      return PeakCache;
    }();

    exports.default = PeakCache;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/absMax.js":
    /*!****************************!*\
      !*** ./src/util/absMax.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = absMax;

    var _max = _interopRequireDefault(__webpack_require__(/*! ./max */ "./src/util/max.js"));

    var _min = _interopRequireDefault(__webpack_require__(/*! ./min */ "./src/util/min.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * Get the largest absolute value in an array
     *
     * @param   {Array} values Array of numbers
     * @returns {Number} Largest number found
     * @example console.log(max([-3, 2, 1]), max([-3, 2, 4])); // logs 3 4
     * @since 4.3.0
     */
    function absMax(values) {
      var max = (0, _max.default)(values);
      var min = (0, _min.default)(values);
      return -min > max ? -min : max;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/clamp.js":
    /*!***************************!*\
      !*** ./src/util/clamp.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = clamp;

    /**
     * Returns a number limited to the given range.
     *
     * @param {number} val The number to be limited to a range
     * @param {number} min The lower boundary of the limit range
     * @param {number} max The upper boundary of the limit range
     * @returns {number} A number in the range [min, max]
     */
    function clamp(val, min, max) {
      return Math.min(Math.max(min, val), max);
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/fetch.js":
    /*!***************************!*\
      !*** ./src/util/fetch.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = fetchFile;

    var _observer = _interopRequireDefault(__webpack_require__(/*! ./observer */ "./src/util/observer.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var ProgressHandler = /*#__PURE__*/function () {
      /**
       * Instantiate ProgressHandler
       *
       * @param {Observer} instance The `fetchFile` observer instance.
       * @param {Number} contentLength Content length.
       * @param {Response} response Response object.
       */
      function ProgressHandler(instance, contentLength, response) {
        _classCallCheck(this, ProgressHandler);

        this.instance = instance;
        this.instance._reader = response.body.getReader();
        this.total = parseInt(contentLength, 10);
        this.loaded = 0;
      }
      /**
       * A method that is called once, immediately after the `ReadableStream``
       * is constructed.
       *
       * @param {ReadableStreamDefaultController} controller Controller instance
       *     used to control the stream.
       */


      _createClass(ProgressHandler, [{
        key: "start",
        value: function start(controller) {
          var _this = this;

          var read = function read() {
            // instance._reader.read() returns a promise that resolves
            // when a value has been received
            _this.instance._reader.read().then(function (_ref) {
              var done = _ref.done,
                  value = _ref.value;

              // result objects contain two properties:
              // done  - true if the stream has already given you all its data.
              // value - some data. Always undefined when done is true.
              if (done) {
                // ensure onProgress called when content-length=0
                if (_this.total === 0) {
                  _this.instance.onProgress.call(_this.instance, {
                    loaded: _this.loaded,
                    total: _this.total,
                    lengthComputable: false
                  });
                } // no more data needs to be consumed, close the stream


                controller.close();
                return;
              }

              _this.loaded += value.byteLength;

              _this.instance.onProgress.call(_this.instance, {
                loaded: _this.loaded,
                total: _this.total,
                lengthComputable: !(_this.total === 0)
              }); // enqueue the next data chunk into our target stream


              controller.enqueue(value);
              read();
            }).catch(function (error) {
              controller.error(error);
            });
          };

          read();
        }
      }]);

      return ProgressHandler;
    }();
    /**
     * Load a file using `fetch`.
     *
     * @param {object} options Request options to use. See example below.
     * @returns {Observer} Observer instance
     * @example
     * // default options
     * let options = {
     *     url: undefined,
     *     method: 'GET',
     *     mode: 'cors',
     *     credentials: 'same-origin',
     *     cache: 'default',
     *     responseType: 'json',
     *     requestHeaders: [],
     *     redirect: 'follow',
     *     referrer: 'client'
     * };
     *
     * // override some options
     * options.url = '../media/demo.wav';

     * // available types: 'arraybuffer', 'blob', 'json' or 'text'
     * options.responseType = 'arraybuffer';
     *
     * // make fetch call
     * let request = util.fetchFile(options);
     *
     * // listen for events
     * request.on('progress', e => {
     *     console.log('progress', e);
     * });
     *
     * request.on('success', data => {
     *     console.log('success!', data);
     * });
     *
     * request.on('error', e => {
     *     console.warn('fetchFile error: ', e);
     * });
     */


    function fetchFile(options) {
      if (!options) {
        throw new Error('fetch options missing');
      } else if (!options.url) {
        throw new Error('fetch url missing');
      }

      var instance = new _observer.default();
      var fetchHeaders = new Headers();
      var fetchRequest = new Request(options.url); // add ability to abort

      instance.controller = new AbortController(); // check if headers have to be added

      if (options && options.requestHeaders) {
        // add custom request headers
        options.requestHeaders.forEach(function (header) {
          fetchHeaders.append(header.key, header.value);
        });
      } // parse fetch options


      var responseType = options.responseType || 'json';
      var fetchOptions = {
        method: options.method || 'GET',
        headers: fetchHeaders,
        mode: options.mode || 'cors',
        credentials: options.credentials || 'same-origin',
        cache: options.cache || 'default',
        redirect: options.redirect || 'follow',
        referrer: options.referrer || 'client',
        signal: instance.controller.signal
      };
      fetch(fetchRequest, fetchOptions).then(function (response) {
        // store response reference
        instance.response = response;
        var progressAvailable = true;

        if (!response.body) {
          // ReadableStream is not yet supported in this browser
          // see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
          progressAvailable = false;
        } // Server must send CORS header "Access-Control-Expose-Headers: content-length"


        var contentLength = response.headers.get('content-length');

        if (contentLength === null) {
          // Content-Length server response header missing.
          // Don't evaluate download progress if we can't compare against a total size
          // see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Access-Control-Expose-Headers
          progressAvailable = false;
        }

        if (!progressAvailable) {
          // not able to check download progress so skip it
          return response;
        } // fire progress event when during load


        instance.onProgress = function (e) {
          instance.fireEvent('progress', e);
        };

        return new Response(new ReadableStream(new ProgressHandler(instance, contentLength, response)), fetchOptions);
      }).then(function (response) {
        var errMsg;

        if (response.ok) {
          switch (responseType) {
            case 'arraybuffer':
              return response.arrayBuffer();

            case 'json':
              return response.json();

            case 'blob':
              return response.blob();

            case 'text':
              return response.text();

            default:
              errMsg = 'Unknown responseType: ' + responseType;
              break;
          }
        }

        if (!errMsg) {
          errMsg = 'HTTP error status: ' + response.status;
        }

        throw new Error(errMsg);
      }).then(function (response) {
        instance.fireEvent('success', response);
      }).catch(function (error) {
        instance.fireEvent('error', error);
      }); // return the fetch request

      instance.fetchRequest = fetchRequest;
      return instance;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/frame.js":
    /*!***************************!*\
      !*** ./src/util/frame.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = frame;

    var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(/*! ./request-animation-frame */ "./src/util/request-animation-frame.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * Create a function which will be called at the next requestAnimationFrame
     * cycle
     *
     * @param {function} func The function to call
     *
     * @return {func} The function wrapped within a requestAnimationFrame
     */
    function frame(func) {
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (0, _requestAnimationFrame.default)(function () {
          return func.apply(void 0, args);
        });
      };
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/get-id.js":
    /*!****************************!*\
      !*** ./src/util/get-id.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getId;

    /**
     * Get a random prefixed ID
     *
     * @param {String} prefix Prefix to use. Default is `'wavesurfer_'`.
     * @returns {String} Random prefixed ID
     * @example
     * console.log(getId()); // logs 'wavesurfer_b5pors4ru6g'
     *
     * let prefix = 'foo-';
     * console.log(getId(prefix)); // logs 'foo-b5pors4ru6g'
     */
    function getId(prefix) {
      if (prefix === undefined) {
        prefix = 'wavesurfer_';
      }

      return prefix + Math.random().toString(32).substring(2);
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/index.js":
    /*!***************************!*\
      !*** ./src/util/index.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getId", {
      enumerable: true,
      get: function get() {
        return _getId.default;
      }
    });
    Object.defineProperty(exports, "max", {
      enumerable: true,
      get: function get() {
        return _max.default;
      }
    });
    Object.defineProperty(exports, "min", {
      enumerable: true,
      get: function get() {
        return _min.default;
      }
    });
    Object.defineProperty(exports, "absMax", {
      enumerable: true,
      get: function get() {
        return _absMax.default;
      }
    });
    Object.defineProperty(exports, "Observer", {
      enumerable: true,
      get: function get() {
        return _observer.default;
      }
    });
    Object.defineProperty(exports, "style", {
      enumerable: true,
      get: function get() {
        return _style.default;
      }
    });
    Object.defineProperty(exports, "requestAnimationFrame", {
      enumerable: true,
      get: function get() {
        return _requestAnimationFrame.default;
      }
    });
    Object.defineProperty(exports, "frame", {
      enumerable: true,
      get: function get() {
        return _frame.default;
      }
    });
    Object.defineProperty(exports, "debounce", {
      enumerable: true,
      get: function get() {
        return _debounce.default;
      }
    });
    Object.defineProperty(exports, "preventClick", {
      enumerable: true,
      get: function get() {
        return _preventClick.default;
      }
    });
    Object.defineProperty(exports, "fetchFile", {
      enumerable: true,
      get: function get() {
        return _fetch.default;
      }
    });
    Object.defineProperty(exports, "clamp", {
      enumerable: true,
      get: function get() {
        return _clamp.default;
      }
    });

    var _getId = _interopRequireDefault(__webpack_require__(/*! ./get-id */ "./src/util/get-id.js"));

    var _max = _interopRequireDefault(__webpack_require__(/*! ./max */ "./src/util/max.js"));

    var _min = _interopRequireDefault(__webpack_require__(/*! ./min */ "./src/util/min.js"));

    var _absMax = _interopRequireDefault(__webpack_require__(/*! ./absMax */ "./src/util/absMax.js"));

    var _observer = _interopRequireDefault(__webpack_require__(/*! ./observer */ "./src/util/observer.js"));

    var _style = _interopRequireDefault(__webpack_require__(/*! ./style */ "./src/util/style.js"));

    var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(/*! ./request-animation-frame */ "./src/util/request-animation-frame.js"));

    var _frame = _interopRequireDefault(__webpack_require__(/*! ./frame */ "./src/util/frame.js"));

    var _debounce = _interopRequireDefault(__webpack_require__(/*! debounce */ "./node_modules/debounce/index.js"));

    var _preventClick = _interopRequireDefault(__webpack_require__(/*! ./prevent-click */ "./src/util/prevent-click.js"));

    var _fetch = _interopRequireDefault(__webpack_require__(/*! ./fetch */ "./src/util/fetch.js"));

    var _clamp = _interopRequireDefault(__webpack_require__(/*! ./clamp */ "./src/util/clamp.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /***/ }),

    /***/ "./src/util/max.js":
    /*!*************************!*\
      !*** ./src/util/max.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = max;

    /**
     * Get the largest value
     *
     * @param   {Array} values Array of numbers
     * @returns {Number} Largest number found
     * @example console.log(max([1, 2, 3])); // logs 3
     */
    function max(values) {
      var largest = -Infinity;
      Object.keys(values).forEach(function (i) {
        if (values[i] > largest) {
          largest = values[i];
        }
      });
      return largest;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/min.js":
    /*!*************************!*\
      !*** ./src/util/min.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = min;

    /**
     * Get the smallest value
     *
     * @param   {Array} values Array of numbers
     * @returns {Number} Smallest number found
     * @example console.log(min([1, 2, 3])); // logs 1
     */
    function min(values) {
      var smallest = Number(Infinity);
      Object.keys(values).forEach(function (i) {
        if (values[i] < smallest) {
          smallest = values[i];
        }
      });
      return smallest;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/observer.js":
    /*!******************************!*\
      !*** ./src/util/observer.js ***!
      \******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    /**
     * @typedef {Object} ListenerDescriptor
     * @property {string} name The name of the event
     * @property {function} callback The callback
     * @property {function} un The function to call to remove the listener
     */

    /**
     * Observer class
     */
    var Observer = /*#__PURE__*/function () {
      /**
       * Instantiate Observer
       */
      function Observer() {
        _classCallCheck(this, Observer);

        /**
         * @private
         * @todo Initialise the handlers here already and remove the conditional
         * assignment in `on()`
         */
        this._disabledEventEmissions = [];
        this.handlers = null;
      }
      /**
       * Attach a handler function for an event.
       *
       * @param {string} event Name of the event to listen to
       * @param {function} fn The callback to trigger when the event is fired
       * @return {ListenerDescriptor} The event descriptor
       */


      _createClass(Observer, [{
        key: "on",
        value: function on(event, fn) {
          var _this = this;

          if (!this.handlers) {
            this.handlers = {};
          }

          var handlers = this.handlers[event];

          if (!handlers) {
            handlers = this.handlers[event] = [];
          }

          handlers.push(fn); // Return an event descriptor

          return {
            name: event,
            callback: fn,
            un: function un(e, fn) {
              return _this.un(e, fn);
            }
          };
        }
        /**
         * Remove an event handler.
         *
         * @param {string} event Name of the event the listener that should be
         * removed listens to
         * @param {function} fn The callback that should be removed
         */

      }, {
        key: "un",
        value: function un(event, fn) {
          if (!this.handlers) {
            return;
          }

          var handlers = this.handlers[event];
          var i;

          if (handlers) {
            if (fn) {
              for (i = handlers.length - 1; i >= 0; i--) {
                if (handlers[i] == fn) {
                  handlers.splice(i, 1);
                }
              }
            } else {
              handlers.length = 0;
            }
          }
        }
        /**
         * Remove all event handlers.
         */

      }, {
        key: "unAll",
        value: function unAll() {
          this.handlers = null;
        }
        /**
         * Attach a handler to an event. The handler is executed at most once per
         * event type.
         *
         * @param {string} event The event to listen to
         * @param {function} handler The callback that is only to be called once
         * @return {ListenerDescriptor} The event descriptor
         */

      }, {
        key: "once",
        value: function once(event, handler) {
          var _this2 = this;

          var fn = function fn() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            /*  eslint-disable no-invalid-this */
            handler.apply(_this2, args);
            /*  eslint-enable no-invalid-this */

            setTimeout(function () {
              _this2.un(event, fn);
            }, 0);
          };

          return this.on(event, fn);
        }
        /**
         * Disable firing a list of events by name. When specified, event handlers for any event type
         * passed in here will not be called.
         *
         * @since 4.0.0
         * @param {string[]} eventNames an array of event names to disable emissions for
         * @example
         * // disable seek and interaction events
         * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);
         */

      }, {
        key: "setDisabledEventEmissions",
        value: function setDisabledEventEmissions(eventNames) {
          this._disabledEventEmissions = eventNames;
        }
        /**
         * plugins borrow part of this class without calling the constructor,
         * so we have to be careful about _disabledEventEmissions
         */

      }, {
        key: "_isDisabledEventEmission",
        value: function _isDisabledEventEmission(event) {
          return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);
        }
        /**
         * Manually fire an event
         *
         * @param {string} event The event to fire manually
         * @param {...any} args The arguments with which to call the listeners
         */

      }, {
        key: "fireEvent",
        value: function fireEvent(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          if (!this.handlers || this._isDisabledEventEmission(event)) {
            return;
          }

          var handlers = this.handlers[event];
          handlers && handlers.forEach(function (fn) {
            fn.apply(void 0, args);
          });
        }
      }]);

      return Observer;
    }();

    exports.default = Observer;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/prevent-click.js":
    /*!***********************************!*\
      !*** ./src/util/prevent-click.js ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = preventClick;

    /**
     * Stops propagation of click event and removes event listener
     *
     * @private
     * @param {object} event The click event
     */
    function preventClickHandler(event) {
      event.stopPropagation();
      document.body.removeEventListener('click', preventClickHandler, true);
    }
    /**
     * Starts listening for click event and prevent propagation
     *
     * @param {object} values Values
     */


    function preventClick(values) {
      document.body.addEventListener('click', preventClickHandler, true);
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/request-animation-frame.js":
    /*!*********************************************!*\
      !*** ./src/util/request-animation-frame.js ***!
      \*********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    /* eslint-disable valid-jsdoc */

    /**
     * Returns the `requestAnimationFrame` function for the browser, or a shim with
     * `setTimeout` if the function is not found
     *
     * @return {function} Available `requestAnimationFrame` function for the browser
     */
    var _default = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
      return setTimeout(callback, 1000 / 60);
    }).bind(window);

    exports.default = _default;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/util/style.js":
    /*!***************************!*\
      !*** ./src/util/style.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = style;

    /**
     * Apply a map of styles to an element
     *
     * @param {HTMLElement} el The element that the styles will be applied to
     * @param {Object} styles The map of propName: attribute, both are used as-is
     *
     * @return {HTMLElement} el
     */
    function style(el, styles) {
      Object.keys(styles).forEach(function (prop) {
        if (el.style[prop] !== styles[prop]) {
          el.style[prop] = styles[prop];
        }
      });
      return el;
    }

    module.exports = exports.default;

    /***/ }),

    /***/ "./src/wavesurfer.js":
    /*!***************************!*\
      !*** ./src/wavesurfer.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    var _drawer = _interopRequireDefault(__webpack_require__(/*! ./drawer.multicanvas */ "./src/drawer.multicanvas.js"));

    var _webaudio = _interopRequireDefault(__webpack_require__(/*! ./webaudio */ "./src/webaudio.js"));

    var _mediaelement = _interopRequireDefault(__webpack_require__(/*! ./mediaelement */ "./src/mediaelement.js"));

    var _peakcache = _interopRequireDefault(__webpack_require__(/*! ./peakcache */ "./src/peakcache.js"));

    var _mediaelementWebaudio = _interopRequireDefault(__webpack_require__(/*! ./mediaelement-webaudio */ "./src/mediaelement-webaudio.js"));

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
    /**
     * WaveSurfer core library class
     *
     * @extends {Observer}
     * @example
     * const params = {
     *   container: '#waveform',
     *   waveColor: 'violet',
     *   progressColor: 'purple'
     * };
     *
     * // initialise like this
     * const wavesurfer = WaveSurfer.create(params);
     *
     * // or like this ...
     * const wavesurfer = new WaveSurfer(params);
     * wavesurfer.init();
     *
     * // load audio file
     * wavesurfer.load('example/media/demo.wav');
     */


    var WaveSurfer = /*#__PURE__*/function (_util$Observer) {
      _inherits(WaveSurfer, _util$Observer);

      var _super = _createSuper(WaveSurfer);

      _createClass(WaveSurfer, null, [{
        key: "create",

        /** @private */

        /** @private */

        /**
         * Instantiate this class, call its `init` function and returns it
         *
         * @param {WavesurferParams} params The wavesurfer parameters
         * @return {Object} WaveSurfer instance
         * @example const wavesurfer = WaveSurfer.create(params);
         */
        value: function create(params) {
          var wavesurfer = new WaveSurfer(params);
          return wavesurfer.init();
        }
        /**
         * The library version number is available as a static property of the
         * WaveSurfer class
         *
         * @type {String}
         * @example
         * console.log('Using wavesurfer.js ' + WaveSurfer.VERSION);
         */

      }]);

      /**
       * Initialise wavesurfer instance
       *
       * @param {WavesurferParams} params Instantiation options for wavesurfer
       * @example
       * const wavesurfer = new WaveSurfer(params);
       * @returns {this} Wavesurfer instance
       */
      function WaveSurfer(params) {
        var _this;

        _classCallCheck(this, WaveSurfer);

        _this = _super.call(this);
        /**
         * Extract relevant parameters (or defaults)
         * @private
         */

        _this.defaultParams = {
          audioContext: null,
          audioScriptProcessor: null,
          audioRate: 1,
          autoCenter: true,
          autoCenterRate: 5,
          autoCenterImmediately: false,
          backend: 'WebAudio',
          backgroundColor: null,
          barHeight: 1,
          barRadius: 0,
          barGap: null,
          barMinHeight: null,
          container: null,
          cursorColor: '#333',
          cursorWidth: 1,
          dragSelection: true,
          drawingContextAttributes: {
            // Boolean that hints the user agent to reduce the latency
            // by desynchronizing the canvas paint cycle from the event
            // loop
            desynchronized: false
          },
          duration: null,
          fillParent: true,
          forceDecode: false,
          height: 128,
          hideScrollbar: false,
          interact: true,
          loopSelection: true,
          maxCanvasWidth: 4000,
          mediaContainer: null,
          mediaControls: false,
          mediaType: 'audio',
          minPxPerSec: 20,
          normalize: false,
          partialRender: false,
          pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
          plugins: [],
          progressColor: '#555',
          removeMediaElementOnDestroy: true,
          renderer: _drawer.default,
          responsive: false,
          rtl: false,
          scrollParent: false,
          skipLength: 2,
          splitChannels: false,
          splitChannelsOptions: {
            overlay: false,
            channelColors: {},
            filterChannels: [],
            relativeNormalization: false
          },
          waveColor: '#999',
          xhr: {}
        };
        _this.backends = {
          MediaElement: _mediaelement.default,
          WebAudio: _webaudio.default,
          MediaElementWebAudio: _mediaelementWebaudio.default
        };
        _this.util = util;
        _this.params = Object.assign({}, _this.defaultParams, params);
        _this.params.splitChannelsOptions = Object.assign({}, _this.defaultParams.splitChannelsOptions, params.splitChannelsOptions);
        /** @private */

        _this.container = 'string' == typeof params.container ? document.querySelector(_this.params.container) : _this.params.container;

        if (!_this.container) {
          throw new Error('Container element not found');
        }

        if (_this.params.mediaContainer == null) {
          /** @private */
          _this.mediaContainer = _this.container;
        } else if (typeof _this.params.mediaContainer == 'string') {
          /** @private */
          _this.mediaContainer = document.querySelector(_this.params.mediaContainer);
        } else {
          /** @private */
          _this.mediaContainer = _this.params.mediaContainer;
        }

        if (!_this.mediaContainer) {
          throw new Error('Media Container element not found');
        }

        if (_this.params.maxCanvasWidth <= 1) {
          throw new Error('maxCanvasWidth must be greater than 1');
        } else if (_this.params.maxCanvasWidth % 2 == 1) {
          throw new Error('maxCanvasWidth must be an even number');
        }

        if (_this.params.rtl === true) {
          util.style(_this.container, {
            transform: 'rotateY(180deg)'
          });
        }

        if (_this.params.backgroundColor) {
          _this.setBackgroundColor(_this.params.backgroundColor);
        }
        /**
         * @private Used to save the current volume when muting so we can
         * restore once unmuted
         * @type {number}
         */


        _this.savedVolume = 0;
        /**
         * @private The current muted state
         * @type {boolean}
         */

        _this.isMuted = false;
        /**
         * @private Will hold a list of event descriptors that need to be
         * canceled on subsequent loads of audio
         * @type {Object[]}
         */

        _this.tmpEvents = [];
        /**
         * @private Holds any running audio downloads
         * @type {Observer}
         */

        _this.currentRequest = null;
        /** @private */

        _this.arraybuffer = null;
        /** @private */

        _this.drawer = null;
        /** @private */

        _this.backend = null;
        /** @private */

        _this.peakCache = null; // cache constructor objects

        if (typeof _this.params.renderer !== 'function') {
          throw new Error('Renderer parameter is invalid');
        }
        /**
         * @private The uninitialised Drawer class
         */


        _this.Drawer = _this.params.renderer;
        /**
         * @private The uninitialised Backend class
         */
        // Back compat

        if (_this.params.backend == 'AudioElement') {
          _this.params.backend = 'MediaElement';
        }

        if ((_this.params.backend == 'WebAudio' || _this.params.backend === 'MediaElementWebAudio') && !_webaudio.default.prototype.supportsWebAudio.call(null)) {
          _this.params.backend = 'MediaElement';
        }

        _this.Backend = _this.backends[_this.params.backend];
        /**
         * @private map of plugin names that are currently initialised
         */

        _this.initialisedPluginList = {};
        /** @private */

        _this.isDestroyed = false;
        /**
         * Get the current ready status.
         *
         * @example const isReady = wavesurfer.isReady;
         * @return {boolean}
         */

        _this.isReady = false; // responsive debounced event listener. If this.params.responsive is not
        // set, this is never called. Use 100ms or this.params.responsive as
        // timeout for the debounce function.

        var prevWidth = 0;
        _this._onResize = util.debounce(function () {
          if (prevWidth != _this.drawer.wrapper.clientWidth && !_this.params.scrollParent) {
            prevWidth = _this.drawer.wrapper.clientWidth;

            _this.drawer.fireEvent('redraw');
          }
        }, typeof _this.params.responsive === 'number' ? _this.params.responsive : 100);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      /**
       * Initialise the wave
       *
       * @example
       * var wavesurfer = new WaveSurfer(params);
       * wavesurfer.init();
       * @return {this} The wavesurfer instance
       */


      _createClass(WaveSurfer, [{
        key: "init",
        value: function init() {
          this.registerPlugins(this.params.plugins);
          this.createDrawer();
          this.createBackend();
          this.createPeakCache();
          return this;
        }
        /**
         * Add and initialise array of plugins (if `plugin.deferInit` is falsey),
         * this function is called in the init function of wavesurfer
         *
         * @param {PluginDefinition[]} plugins An array of plugin definitions
         * @emits {WaveSurfer#plugins-registered} Called with the array of plugin definitions
         * @return {this} The wavesurfer instance
         */

      }, {
        key: "registerPlugins",
        value: function registerPlugins(plugins) {
          var _this2 = this;

          // first instantiate all the plugins
          plugins.forEach(function (plugin) {
            return _this2.addPlugin(plugin);
          }); // now run the init functions

          plugins.forEach(function (plugin) {
            // call init function of the plugin if deferInit is falsey
            // in that case you would manually use initPlugins()
            if (!plugin.deferInit) {
              _this2.initPlugin(plugin.name);
            }
          });
          this.fireEvent('plugins-registered', plugins);
          return this;
        }
        /**
         * Get a map of plugin names that are currently initialised
         *
         * @example wavesurfer.getPlugins();
         * @return {Object} Object with plugin names
         */

      }, {
        key: "getActivePlugins",
        value: function getActivePlugins() {
          return this.initialisedPluginList;
        }
        /**
         * Add a plugin object to wavesurfer
         *
         * @param {PluginDefinition} plugin A plugin definition
         * @emits {WaveSurfer#plugin-added} Called with the name of the plugin that was added
         * @example wavesurfer.addPlugin(WaveSurfer.minimap());
         * @return {this} The wavesurfer instance
         */

      }, {
        key: "addPlugin",
        value: function addPlugin(plugin) {
          var _this3 = this;

          if (!plugin.name) {
            throw new Error('Plugin does not have a name!');
          }

          if (!plugin.instance) {
            throw new Error("Plugin ".concat(plugin.name, " does not have an instance property!"));
          } // staticProps properties are applied to wavesurfer instance


          if (plugin.staticProps) {
            Object.keys(plugin.staticProps).forEach(function (pluginStaticProp) {
              /**
               * Properties defined in a plugin definition's `staticProps` property are added as
               * staticProps properties of the WaveSurfer instance
               */
              _this3[pluginStaticProp] = plugin.staticProps[pluginStaticProp];
            });
          }

          var Instance = plugin.instance; // turn the plugin instance into an observer

          var observerPrototypeKeys = Object.getOwnPropertyNames(util.Observer.prototype);
          observerPrototypeKeys.forEach(function (key) {
            Instance.prototype[key] = util.Observer.prototype[key];
          });
          /**
           * Instantiated plugin classes are added as a property of the wavesurfer
           * instance
           * @type {Object}
           */

          this[plugin.name] = new Instance(plugin.params || {}, this);
          this.fireEvent('plugin-added', plugin.name);
          return this;
        }
        /**
         * Initialise a plugin
         *
         * @param {string} name A plugin name
         * @emits WaveSurfer#plugin-initialised
         * @example wavesurfer.initPlugin('minimap');
         * @return {this} The wavesurfer instance
         */

      }, {
        key: "initPlugin",
        value: function initPlugin(name) {
          if (!this[name]) {
            throw new Error("Plugin ".concat(name, " has not been added yet!"));
          }

          if (this.initialisedPluginList[name]) {
            // destroy any already initialised plugins
            this.destroyPlugin(name);
          }

          this[name].init();
          this.initialisedPluginList[name] = true;
          this.fireEvent('plugin-initialised', name);
          return this;
        }
        /**
         * Destroy a plugin
         *
         * @param {string} name A plugin name
         * @emits WaveSurfer#plugin-destroyed
         * @example wavesurfer.destroyPlugin('minimap');
         * @returns {this} The wavesurfer instance
         */

      }, {
        key: "destroyPlugin",
        value: function destroyPlugin(name) {
          if (!this[name]) {
            throw new Error("Plugin ".concat(name, " has not been added yet and cannot be destroyed!"));
          }

          if (!this.initialisedPluginList[name]) {
            throw new Error("Plugin ".concat(name, " is not active and cannot be destroyed!"));
          }

          if (typeof this[name].destroy !== 'function') {
            throw new Error("Plugin ".concat(name, " does not have a destroy function!"));
          }

          this[name].destroy();
          delete this.initialisedPluginList[name];
          this.fireEvent('plugin-destroyed', name);
          return this;
        }
        /**
         * Destroy all initialised plugins. Convenience function to use when
         * wavesurfer is removed
         *
         * @private
         */

      }, {
        key: "destroyAllPlugins",
        value: function destroyAllPlugins() {
          var _this4 = this;

          Object.keys(this.initialisedPluginList).forEach(function (name) {
            return _this4.destroyPlugin(name);
          });
        }
        /**
         * Create the drawer and draw the waveform
         *
         * @private
         * @emits WaveSurfer#drawer-created
         */

      }, {
        key: "createDrawer",
        value: function createDrawer() {
          var _this5 = this;

          this.drawer = new this.Drawer(this.container, this.params);
          this.drawer.init();
          this.fireEvent('drawer-created', this.drawer);

          if (this.params.responsive !== false) {
            window.addEventListener('resize', this._onResize, true);
            window.addEventListener('orientationchange', this._onResize, true);
          }

          this.drawer.on('redraw', function () {
            _this5.drawBuffer();

            _this5.drawer.progress(_this5.backend.getPlayedPercents());
          }); // Click-to-seek

          this.drawer.on('click', function (e, progress) {
            setTimeout(function () {
              return _this5.seekTo(progress);
            }, 0);
          }); // Relay the scroll event from the drawer

          this.drawer.on('scroll', function (e) {
            if (_this5.params.partialRender) {
              _this5.drawBuffer();
            }

            _this5.fireEvent('scroll', e);
          });
        }
        /**
         * Create the backend
         *
         * @private
         * @emits WaveSurfer#backend-created
         */

      }, {
        key: "createBackend",
        value: function createBackend() {
          var _this6 = this;

          if (this.backend) {
            this.backend.destroy();
          }

          this.backend = new this.Backend(this.params);
          this.backend.init();
          this.fireEvent('backend-created', this.backend);
          this.backend.on('finish', function () {
            _this6.drawer.progress(_this6.backend.getPlayedPercents());

            _this6.fireEvent('finish');
          });
          this.backend.on('play', function () {
            return _this6.fireEvent('play');
          });
          this.backend.on('pause', function () {
            return _this6.fireEvent('pause');
          });
          this.backend.on('audioprocess', function (time) {
            _this6.drawer.progress(_this6.backend.getPlayedPercents());

            _this6.fireEvent('audioprocess', time);
          }); // only needed for MediaElement and MediaElementWebAudio backend

          if (this.params.backend === 'MediaElement' || this.params.backend === 'MediaElementWebAudio') {
            this.backend.on('seek', function () {
              _this6.drawer.progress(_this6.backend.getPlayedPercents());
            });
            this.backend.on('volume', function () {
              var newVolume = _this6.getVolume();

              _this6.fireEvent('volume', newVolume);

              if (_this6.backend.isMuted !== _this6.isMuted) {
                _this6.isMuted = _this6.backend.isMuted;

                _this6.fireEvent('mute', _this6.isMuted);
              }
            });
          }
        }
        /**
         * Create the peak cache
         *
         * @private
         */

      }, {
        key: "createPeakCache",
        value: function createPeakCache() {
          if (this.params.partialRender) {
            this.peakCache = new _peakcache.default();
          }
        }
        /**
         * Get the duration of the audio clip
         *
         * @example const duration = wavesurfer.getDuration();
         * @return {number} Duration in seconds
         */

      }, {
        key: "getDuration",
        value: function getDuration() {
          return this.backend.getDuration();
        }
        /**
         * Get the current playback position
         *
         * @example const currentTime = wavesurfer.getCurrentTime();
         * @return {number} Playback position in seconds
         */

      }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
          return this.backend.getCurrentTime();
        }
        /**
         * Set the current play time in seconds.
         *
         * @param {number} seconds A positive number in seconds. E.g. 10 means 10
         * seconds, 60 means 1 minute
         */

      }, {
        key: "setCurrentTime",
        value: function setCurrentTime(seconds) {
          if (seconds >= this.getDuration()) {
            this.seekTo(1);
          } else {
            this.seekTo(seconds / this.getDuration());
          }
        }
        /**
         * Starts playback from the current position. Optional start and end
         * measured in seconds can be used to set the range of audio to play.
         *
         * @param {?number} start Position to start at
         * @param {?number} end Position to end at
         * @emits WaveSurfer#interaction
         * @return {Promise} Result of the backend play method
         * @example
         * // play from second 1 to 5
         * wavesurfer.play(1, 5);
         */

      }, {
        key: "play",
        value: function play(start, end) {
          var _this7 = this;

          this.fireEvent('interaction', function () {
            return _this7.play(start, end);
          });
          return this.backend.play(start, end);
        }
        /**
         * Set a point in seconds for playback to stop at.
         *
         * @param {number} position Position (in seconds) to stop at
         * @version 3.3.0
         */

      }, {
        key: "setPlayEnd",
        value: function setPlayEnd(position) {
          this.backend.setPlayEnd(position);
        }
        /**
         * Stops and pauses playback
         *
         * @example wavesurfer.pause();
         * @return {Promise} Result of the backend pause method
         */

      }, {
        key: "pause",
        value: function pause() {
          if (!this.backend.isPaused()) {
            return this.backend.pause();
          }
        }
        /**
         * Toggle playback
         *
         * @example wavesurfer.playPause();
         * @return {Promise} Result of the backend play or pause method
         */

      }, {
        key: "playPause",
        value: function playPause() {
          return this.backend.isPaused() ? this.play() : this.pause();
        }
        /**
         * Get the current playback state
         *
         * @example const isPlaying = wavesurfer.isPlaying();
         * @return {boolean} False if paused, true if playing
         */

      }, {
        key: "isPlaying",
        value: function isPlaying() {
          return !this.backend.isPaused();
        }
        /**
         * Skip backward
         *
         * @param {?number} seconds Amount to skip back, if not specified `skipLength`
         * is used
         * @example wavesurfer.skipBackward();
         */

      }, {
        key: "skipBackward",
        value: function skipBackward(seconds) {
          this.skip(-seconds || -this.params.skipLength);
        }
        /**
         * Skip forward
         *
         * @param {?number} seconds Amount to skip back, if not specified `skipLength`
         * is used
         * @example wavesurfer.skipForward();
         */

      }, {
        key: "skipForward",
        value: function skipForward(seconds) {
          this.skip(seconds || this.params.skipLength);
        }
        /**
         * Skip a number of seconds from the current position (use a negative value
         * to go backwards).
         *
         * @param {number} offset Amount to skip back or forwards
         * @example
         * // go back 2 seconds
         * wavesurfer.skip(-2);
         */

      }, {
        key: "skip",
        value: function skip(offset) {
          var duration = this.getDuration() || 1;
          var position = this.getCurrentTime() || 0;
          position = Math.max(0, Math.min(duration, position + (offset || 0)));
          this.seekAndCenter(position / duration);
        }
        /**
         * Seeks to a position and centers the view
         *
         * @param {number} progress Between 0 (=beginning) and 1 (=end)
         * @example
         * // seek and go to the middle of the audio
         * wavesurfer.seekTo(0.5);
         */

      }, {
        key: "seekAndCenter",
        value: function seekAndCenter(progress) {
          this.seekTo(progress);
          this.drawer.recenter(progress);
        }
        /**
         * Seeks to a position
         *
         * @param {number} progress Between 0 (=beginning) and 1 (=end)
         * @emits WaveSurfer#interaction
         * @emits WaveSurfer#seek
         * @example
         * // seek to the middle of the audio
         * wavesurfer.seekTo(0.5);
         */

      }, {
        key: "seekTo",
        value: function seekTo(progress) {
          var _this8 = this;

          // return an error if progress is not a number between 0 and 1
          if (typeof progress !== 'number' || !isFinite(progress) || progress < 0 || progress > 1) {
            throw new Error('Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!');
          }

          this.fireEvent('interaction', function () {
            return _this8.seekTo(progress);
          }); // avoid small scrolls while paused seeking

          var oldScrollParent = this.params.scrollParent;
          this.params.scrollParent = false;
          this.backend.seekTo(progress * this.getDuration());
          this.drawer.progress(progress);
          this.params.scrollParent = oldScrollParent;
          this.fireEvent('seek', progress);
        }
        /**
         * Stops and goes to the beginning.
         *
         * @example wavesurfer.stop();
         */

      }, {
        key: "stop",
        value: function stop() {
          this.pause();
          this.seekTo(0);
          this.drawer.progress(0);
        }
        /**
         * Sets the ID of the audio device to use for output and returns a Promise.
         *
         * @param {string} deviceId String value representing underlying output
         * device
         * @returns {Promise} `Promise` that resolves to `undefined` when there are
         * no errors detected.
         */

      }, {
        key: "setSinkId",
        value: function setSinkId(deviceId) {
          return this.backend.setSinkId(deviceId);
        }
        /**
         * Set the playback volume.
         *
         * @param {number} newVolume A value between 0 and 1, 0 being no
         * volume and 1 being full volume.
         * @emits WaveSurfer#volume
         */

      }, {
        key: "setVolume",
        value: function setVolume(newVolume) {
          this.backend.setVolume(newVolume);
          this.fireEvent('volume', newVolume);
        }
        /**
         * Get the playback volume.
         *
         * @return {number} A value between 0 and 1, 0 being no
         * volume and 1 being full volume.
         */

      }, {
        key: "getVolume",
        value: function getVolume() {
          return this.backend.getVolume();
        }
        /**
         * Set the playback rate.
         *
         * @param {number} rate A positive number. E.g. 0.5 means half the normal
         * speed, 2 means double speed and so on.
         * @example wavesurfer.setPlaybackRate(2);
         */

      }, {
        key: "setPlaybackRate",
        value: function setPlaybackRate(rate) {
          this.backend.setPlaybackRate(rate);
        }
        /**
         * Get the playback rate.
         *
         * @return {number} The current playback rate.
         */

      }, {
        key: "getPlaybackRate",
        value: function getPlaybackRate() {
          return this.backend.getPlaybackRate();
        }
        /**
         * Toggle the volume on and off. If not currently muted it will save the
         * current volume value and turn the volume off. If currently muted then it
         * will restore the volume to the saved value, and then rest the saved
         * value.
         *
         * @example wavesurfer.toggleMute();
         */

      }, {
        key: "toggleMute",
        value: function toggleMute() {
          this.setMute(!this.isMuted);
        }
        /**
         * Enable or disable muted audio
         *
         * @param {boolean} mute Specify `true` to mute audio.
         * @emits WaveSurfer#volume
         * @emits WaveSurfer#mute
         * @example
         * // unmute
         * wavesurfer.setMute(false);
         * console.log(wavesurfer.getMute()) // logs false
         */

      }, {
        key: "setMute",
        value: function setMute(mute) {
          // ignore all muting requests if the audio is already in that state
          if (mute === this.isMuted) {
            this.fireEvent('mute', this.isMuted);
            return;
          }

          if (this.backend.setMute) {
            // Backends such as the MediaElement backend have their own handling
            // of mute, let them handle it.
            this.backend.setMute(mute);
            this.isMuted = mute;
          } else {
            if (mute) {
              // If currently not muted then save current volume,
              // turn off the volume and update the mute properties
              this.savedVolume = this.backend.getVolume();
              this.backend.setVolume(0);
              this.isMuted = true;
              this.fireEvent('volume', 0);
            } else {
              // If currently muted then restore to the saved volume
              // and update the mute properties
              this.backend.setVolume(this.savedVolume);
              this.isMuted = false;
              this.fireEvent('volume', this.savedVolume);
            }
          }

          this.fireEvent('mute', this.isMuted);
        }
        /**
         * Get the current mute status.
         *
         * @example const isMuted = wavesurfer.getMute();
         * @return {boolean} Current mute status
         */

      }, {
        key: "getMute",
        value: function getMute() {
          return this.isMuted;
        }
        /**
         * Get the list of current set filters as an array.
         *
         * Filters must be set with setFilters method first
         *
         * @return {array} List of enabled filters
         */

      }, {
        key: "getFilters",
        value: function getFilters() {
          return this.backend.filters || [];
        }
        /**
         * Toggles `scrollParent` and redraws
         *
         * @example wavesurfer.toggleScroll();
         */

      }, {
        key: "toggleScroll",
        value: function toggleScroll() {
          this.params.scrollParent = !this.params.scrollParent;
          this.drawBuffer();
        }
        /**
         * Toggle mouse interaction
         *
         * @example wavesurfer.toggleInteraction();
         */

      }, {
        key: "toggleInteraction",
        value: function toggleInteraction() {
          this.params.interact = !this.params.interact;
        }
        /**
         * Get the fill color of the waveform after the cursor.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getWaveColor",
        value: function getWaveColor() {
          return this.params.waveColor;
        }
        /**
         * Set the fill color of the waveform after the cursor.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setWaveColor('#ddd');
         */

      }, {
        key: "setWaveColor",
        value: function setWaveColor(color) {
          this.params.waveColor = color;
          this.drawBuffer();
        }
        /**
         * Get the fill color of the waveform behind the cursor.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getProgressColor",
        value: function getProgressColor() {
          return this.params.progressColor;
        }
        /**
         * Set the fill color of the waveform behind the cursor.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setProgressColor('#400');
         */

      }, {
        key: "setProgressColor",
        value: function setProgressColor(color) {
          this.params.progressColor = color;
          this.drawBuffer();
        }
        /**
         * Get the background color of the waveform container.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getBackgroundColor",
        value: function getBackgroundColor() {
          return this.params.backgroundColor;
        }
        /**
         * Set the background color of the waveform container.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setBackgroundColor('#FF00FF');
         */

      }, {
        key: "setBackgroundColor",
        value: function setBackgroundColor(color) {
          this.params.backgroundColor = color;
          util.style(this.container, {
            background: this.params.backgroundColor
          });
        }
        /**
         * Get the fill color of the cursor indicating the playhead
         * position.
         *
         * @return {string} A CSS color string.
         */

      }, {
        key: "getCursorColor",
        value: function getCursorColor() {
          return this.params.cursorColor;
        }
        /**
         * Set the fill color of the cursor indicating the playhead
         * position.
         *
         * @param {string} color A CSS color string.
         * @example wavesurfer.setCursorColor('#222');
         */

      }, {
        key: "setCursorColor",
        value: function setCursorColor(color) {
          this.params.cursorColor = color;
          this.drawer.updateCursor();
        }
        /**
         * Get the height of the waveform.
         *
         * @return {number} Height measured in pixels.
         */

      }, {
        key: "getHeight",
        value: function getHeight() {
          return this.params.height;
        }
        /**
         * Set the height of the waveform.
         *
         * @param {number} height Height measured in pixels.
         * @example wavesurfer.setHeight(200);
         */

      }, {
        key: "setHeight",
        value: function setHeight(height) {
          this.params.height = height;
          this.drawer.setHeight(height * this.params.pixelRatio);
          this.drawBuffer();
        }
        /**
         * Hide channels from being drawn on the waveform if splitting channels.
         *
         * For example, if we want to draw only the peaks for the right stereo channel:
         *
         * const wavesurfer = new WaveSurfer.create({...splitChannels: true});
         * wavesurfer.load('stereo_audio.mp3');
         *
         * wavesurfer.setFilteredChannel([0]); <-- hide left channel peaks.
         *
         * @param {array} channelIndices Channels to be filtered out from drawing.
         * @version 4.0.0
         */

      }, {
        key: "setFilteredChannels",
        value: function setFilteredChannels(channelIndices) {
          this.params.splitChannelsOptions.filterChannels = channelIndices;
          this.drawBuffer();
        }
        /**
         * Get the correct peaks for current wave view-port and render wave
         *
         * @private
         * @emits WaveSurfer#redraw
         */

      }, {
        key: "drawBuffer",
        value: function drawBuffer() {
          var nominalWidth = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio);
          var parentWidth = this.drawer.getWidth();
          var width = nominalWidth; // always start at 0 after zooming for scrolling : issue redraw left part

          var start = 0;
          var end = Math.max(start + parentWidth, width); // Fill container

          if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
            width = parentWidth;
            start = 0;
            end = width;
          }

          var peaks;

          if (this.params.partialRender) {
            var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
            var i;

            for (i = 0; i < newRanges.length; i++) {
              peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
              this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
            }
          } else {
            peaks = this.backend.getPeaks(width, start, end);
            this.drawer.drawPeaks(peaks, width, start, end);
          }

          this.fireEvent('redraw', peaks, width);
        }
        /**
         * Horizontally zooms the waveform in and out. It also changes the parameter
         * `minPxPerSec` and enables the `scrollParent` option. Calling the function
         * with a falsey parameter will reset the zoom state.
         *
         * @param {?number} pxPerSec Number of horizontal pixels per second of
         * audio, if none is set the waveform returns to unzoomed state
         * @emits WaveSurfer#zoom
         * @example wavesurfer.zoom(20);
         */

      }, {
        key: "zoom",
        value: function zoom(pxPerSec) {
          if (!pxPerSec) {
            this.params.minPxPerSec = this.defaultParams.minPxPerSec;
            this.params.scrollParent = false;
          } else {
            this.params.minPxPerSec = pxPerSec;
            this.params.scrollParent = true;
          }

          this.drawBuffer();
          this.drawer.progress(this.backend.getPlayedPercents());
          this.drawer.recenter(this.getCurrentTime() / this.getDuration());
          this.fireEvent('zoom', pxPerSec);
        }
        /**
         * Decode buffer and load
         *
         * @private
         * @param {ArrayBuffer} arraybuffer Buffer to process
         */

      }, {
        key: "loadArrayBuffer",
        value: function loadArrayBuffer(arraybuffer) {
          var _this9 = this;

          this.decodeArrayBuffer(arraybuffer, function (data) {
            if (!_this9.isDestroyed) {
              _this9.loadDecodedBuffer(data);
            }
          });
        }
        /**
         * Directly load an externally decoded AudioBuffer
         *
         * @private
         * @param {AudioBuffer} buffer Buffer to process
         * @emits WaveSurfer#ready
         */

      }, {
        key: "loadDecodedBuffer",
        value: function loadDecodedBuffer(buffer) {
          this.backend.load(buffer);
          this.drawBuffer();
          this.isReady = true;
          this.fireEvent('ready');
        }
        /**
         * Loads audio data from a Blob or File object
         *
         * @param {Blob|File} blob Audio data
         * @example
         */

      }, {
        key: "loadBlob",
        value: function loadBlob(blob) {
          var _this10 = this;

          // Create file reader
          var reader = new FileReader();
          reader.addEventListener('progress', function (e) {
            return _this10.onProgress(e);
          });
          reader.addEventListener('load', function (e) {
            return _this10.loadArrayBuffer(e.target.result);
          });
          reader.addEventListener('error', function () {
            return _this10.fireEvent('error', 'Error reading file');
          });
          reader.readAsArrayBuffer(blob);
          this.empty();
        }
        /**
         * Loads audio and re-renders the waveform.
         *
         * @param {string|HTMLMediaElement} url The url of the audio file or the
         * audio element with the audio
         * @param {number[]|Number.<Array[]>} peaks Wavesurfer does not have to decode
         * the audio to render the waveform if this is specified
         * @param {?string} preload (Use with backend `MediaElement` and `MediaElementWebAudio`)
         * `'none'|'metadata'|'auto'` Preload attribute for the media element
         * @param {?number} duration The duration of the audio. This is used to
         * render the peaks data in the correct size for the audio duration (as
         * befits the current `minPxPerSec` and zoom value) without having to decode
         * the audio.
         * @returns {void}
         * @throws Will throw an error if the `url` argument is empty.
         * @example
         * // uses fetch or media element to load file (depending on backend)
         * wavesurfer.load('http://example.com/demo.wav');
         *
         * // setting preload attribute with media element backend and supplying
         * // peaks
         * wavesurfer.load(
         *   'http://example.com/demo.wav',
         *   [0.0218, 0.0183, 0.0165, 0.0198, 0.2137, 0.2888],
         *   true
         * );
         */

      }, {
        key: "load",
        value: function load(url, peaks, preload, duration) {
          if (!url) {
            throw new Error('url parameter cannot be empty');
          }

          this.empty();

          if (preload) {
            // check whether the preload attribute will be usable and if not log
            // a warning listing the reasons why not and nullify the variable
            var preloadIgnoreReasons = {
              "Preload is not 'auto', 'none' or 'metadata'": ['auto', 'metadata', 'none'].indexOf(preload) === -1,
              'Peaks are not provided': !peaks,
              "Backend is not of type 'MediaElement' or 'MediaElementWebAudio'": ['MediaElement', 'MediaElementWebAudio'].indexOf(this.params.backend) === -1,
              'Url is not of type string': typeof url !== 'string'
            };
            var activeReasons = Object.keys(preloadIgnoreReasons).filter(function (reason) {
              return preloadIgnoreReasons[reason];
            });

            if (activeReasons.length) {
              // eslint-disable-next-line no-console
              console.warn('Preload parameter of wavesurfer.load will be ignored because:\n\t- ' + activeReasons.join('\n\t- ')); // stop invalid values from being used

              preload = null;
            }
          }

          switch (this.params.backend) {
            case 'WebAudio':
              return this.loadBuffer(url, peaks, duration);

            case 'MediaElement':
            case 'MediaElementWebAudio':
              return this.loadMediaElement(url, peaks, preload, duration);
          }
        }
        /**
         * Loads audio using Web Audio buffer backend.
         *
         * @private
         * @emits WaveSurfer#waveform-ready
         * @param {string} url URL of audio file
         * @param {number[]|Number.<Array[]>} peaks Peaks data
         * @param {?number} duration Optional duration of audio file
         * @returns {void}
         */

      }, {
        key: "loadBuffer",
        value: function loadBuffer(url, peaks, duration) {
          var _this11 = this;

          var load = function load(action) {
            if (action) {
              _this11.tmpEvents.push(_this11.once('ready', action));
            }

            return _this11.getArrayBuffer(url, function (data) {
              return _this11.loadArrayBuffer(data);
            });
          };

          if (peaks) {
            this.backend.setPeaks(peaks, duration);
            this.drawBuffer();
            this.fireEvent('waveform-ready');
            this.tmpEvents.push(this.once('interaction', load));
          } else {
            return load();
          }
        }
        /**
         * Either create a media element, or load an existing media element.
         *
         * @private
         * @emits WaveSurfer#waveform-ready
         * @param {string|HTMLMediaElement} urlOrElt Either a path to a media file, or an
         * existing HTML5 Audio/Video Element
         * @param {number[]|Number.<Array[]>} peaks Array of peaks. Required to bypass web audio
         * dependency
         * @param {?boolean} preload Set to true if the preload attribute of the
         * audio element should be enabled
         * @param {?number} duration Optional duration of audio file
         */

      }, {
        key: "loadMediaElement",
        value: function loadMediaElement(urlOrElt, peaks, preload, duration) {
          var _this12 = this;

          var url = urlOrElt;

          if (typeof urlOrElt === 'string') {
            this.backend.load(url, this.mediaContainer, peaks, preload);
          } else {
            var elt = urlOrElt;
            this.backend.loadElt(elt, peaks); // If peaks are not provided,
            // url = element.src so we can get peaks with web audio

            url = elt.src;
          }

          this.tmpEvents.push(this.backend.once('canplay', function () {
            // ignore when backend was already destroyed
            if (!_this12.backend.destroyed) {
              _this12.drawBuffer();

              _this12.isReady = true;

              _this12.fireEvent('ready');
            }
          }), this.backend.once('error', function (err) {
            return _this12.fireEvent('error', err);
          })); // If peaks are provided, render them and fire the `waveform-ready` event.

          if (peaks) {
            this.backend.setPeaks(peaks, duration);
            this.drawBuffer();
            this.fireEvent('waveform-ready');
          } // If no pre-decoded peaks are provided, or are provided with
          // forceDecode flag, attempt to download the audio file and decode it
          // with Web Audio.


          if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
            this.getArrayBuffer(url, function (arraybuffer) {
              _this12.decodeArrayBuffer(arraybuffer, function (buffer) {
                _this12.backend.buffer = buffer;

                _this12.backend.setPeaks(null);

                _this12.drawBuffer();

                _this12.fireEvent('waveform-ready');
              });
            });
          }
        }
        /**
         * Decode an array buffer and pass data to a callback
         *
         * @private
         * @param {Object} arraybuffer The array buffer to decode
         * @param {function} callback The function to call on complete
         */

      }, {
        key: "decodeArrayBuffer",
        value: function decodeArrayBuffer(arraybuffer, callback) {
          var _this13 = this;

          this.arraybuffer = arraybuffer;
          this.backend.decodeArrayBuffer(arraybuffer, function (data) {
            // Only use the decoded data if we haven't been destroyed or
            // another decode started in the meantime
            if (!_this13.isDestroyed && _this13.arraybuffer == arraybuffer) {
              callback(data);
              _this13.arraybuffer = null;
            }
          }, function () {
            return _this13.fireEvent('error', 'Error decoding audiobuffer');
          });
        }
        /**
         * Load an array buffer using fetch and pass the result to a callback
         *
         * @param {string} url The URL of the file object
         * @param {function} callback The function to call on complete
         * @returns {util.fetchFile} fetch call
         * @private
         */

      }, {
        key: "getArrayBuffer",
        value: function getArrayBuffer(url, callback) {
          var _this14 = this;

          var options = Object.assign({
            url: url,
            responseType: 'arraybuffer'
          }, this.params.xhr);
          var request = util.fetchFile(options);
          this.currentRequest = request;
          this.tmpEvents.push(request.on('progress', function (e) {
            _this14.onProgress(e);
          }), request.on('success', function (data) {
            callback(data);
            _this14.currentRequest = null;
          }), request.on('error', function (e) {
            _this14.fireEvent('error', e);

            _this14.currentRequest = null;
          }));
          return request;
        }
        /**
         * Called while the audio file is loading
         *
         * @private
         * @param {Event} e Progress event
         * @emits WaveSurfer#loading
         */

      }, {
        key: "onProgress",
        value: function onProgress(e) {
          var percentComplete;

          if (e.lengthComputable) {
            percentComplete = e.loaded / e.total;
          } else {
            // Approximate progress with an asymptotic
            // function, and assume downloads in the 1-3 MB range.
            percentComplete = e.loaded / (e.loaded + 1000000);
          }

          this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
        }
        /**
         * Exports PCM data into a JSON array and opens in a new window.
         *
         * @param {number} length=1024 The scale in which to export the peaks
         * @param {number} accuracy=10000
         * @param {?boolean} noWindow Set to true to disable opening a new
         * window with the JSON
         * @param {number} start Start index
         * @param {number} end End index
         * @return {Promise} Promise that resolves with array of peaks
         */

      }, {
        key: "exportPCM",
        value: function exportPCM(length, accuracy, noWindow, start, end) {
          length = length || 1024;
          start = start || 0;
          accuracy = accuracy || 10000;
          noWindow = noWindow || false;
          var peaks = this.backend.getPeaks(length, start, end);
          var arr = [].map.call(peaks, function (val) {
            return Math.round(val * accuracy) / accuracy;
          });
          return new Promise(function (resolve, reject) {
            var json = JSON.stringify(arr);

            if (!noWindow) {
              window.open('data:application/json;charset=utf-8,' + encodeURIComponent(json));
            }

            resolve(json);
          });
        }
        /**
         * Save waveform image as data URI.
         *
         * The default format is `'image/png'`. Other supported types are
         * `'image/jpeg'` and `'image/webp'`.
         *
         * @param {string} format='image/png' A string indicating the image format.
         * The default format type is `'image/png'`.
         * @param {number} quality=1 A number between 0 and 1 indicating the image
         * quality to use for image formats that use lossy compression such as
         * `'image/jpeg'`` and `'image/webp'`.
         * @param {string} type Image data type to return. Either 'dataURL' (default)
         * or 'blob'.
         * @return {string|string[]|Promise} When using `'dataURL'` type this returns
         * a single data URL or an array of data URLs, one for each canvas. When using
         * `'blob'` type this returns a `Promise` resolving with an array of `Blob`
         * instances, one for each canvas.
         */

      }, {
        key: "exportImage",
        value: function exportImage(format, quality, type) {
          if (!format) {
            format = 'image/png';
          }

          if (!quality) {
            quality = 1;
          }

          if (!type) {
            type = 'dataURL';
          }

          return this.drawer.getImage(format, quality, type);
        }
        /**
         * Cancel any fetch request currently in progress
         */

      }, {
        key: "cancelAjax",
        value: function cancelAjax() {
          if (this.currentRequest && this.currentRequest.controller) {
            // If the current request has a ProgressHandler, then its ReadableStream might need to be cancelled too
            // See: Wavesurfer issue #2042
            // See Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1583815
            if (this.currentRequest._reader) {
              // Ignoring exceptions thrown by call to cancel()
              this.currentRequest._reader.cancel().catch(function (err) {});
            }

            this.currentRequest.controller.abort();
            this.currentRequest = null;
          }
        }
        /**
         * @private
         */

      }, {
        key: "clearTmpEvents",
        value: function clearTmpEvents() {
          this.tmpEvents.forEach(function (e) {
            return e.un();
          });
        }
        /**
         * Display empty waveform.
         */

      }, {
        key: "empty",
        value: function empty() {
          if (!this.backend.isPaused()) {
            this.stop();
            this.backend.disconnectSource();
          }

          this.isReady = false;
          this.cancelAjax();
          this.clearTmpEvents(); // empty drawer

          this.drawer.progress(0);
          this.drawer.setWidth(0);
          this.drawer.drawPeaks({
            length: this.drawer.getWidth()
          }, 0);
        }
        /**
         * Remove events, elements and disconnect WebAudio nodes.
         *
         * @emits WaveSurfer#destroy
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.destroyAllPlugins();
          this.fireEvent('destroy');
          this.cancelAjax();
          this.clearTmpEvents();
          this.unAll();

          if (this.params.responsive !== false) {
            window.removeEventListener('resize', this._onResize, true);
            window.removeEventListener('orientationchange', this._onResize, true);
          }

          if (this.backend) {
            this.backend.destroy();
          }

          if (this.drawer) {
            this.drawer.destroy();
          }

          this.isDestroyed = true;
          this.isReady = false;
          this.arraybuffer = null;
        }
      }]);

      return WaveSurfer;
    }(util.Observer);

    exports.default = WaveSurfer;
    WaveSurfer.VERSION = "4.3.0";
    WaveSurfer.util = util;
    module.exports = exports.default;

    /***/ }),

    /***/ "./src/webaudio.js":
    /*!*************************!*\
      !*** ./src/webaudio.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));

    function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    // using constants to prevent someone writing the string wrong
    var PLAYING = 'playing';
    var PAUSED = 'paused';
    var FINISHED = 'finished';
    /**
     * WebAudio backend
     *
     * @extends {Observer}
     */

    var WebAudio = /*#__PURE__*/function (_util$Observer) {
      _inherits(WebAudio, _util$Observer);

      var _super = _createSuper(WebAudio);

      _createClass(WebAudio, [{
        key: "supportsWebAudio",

        /** scriptBufferSize: size of the processing buffer */

        /** audioContext: allows to process audio with WebAudio API */

        /** @private */

        /** @private */

        /**
         * Does the browser support this backend
         *
         * @return {boolean} Whether or not this browser supports this backend
         */
        value: function supportsWebAudio() {
          return !!(window.AudioContext || window.webkitAudioContext);
        }
        /**
         * Get the audio context used by this backend or create one
         *
         * @return {AudioContext} Existing audio context, or creates a new one
         */

      }, {
        key: "getAudioContext",
        value: function getAudioContext() {
          if (!window.WaveSurferAudioContext) {
            window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          return window.WaveSurferAudioContext;
        }
        /**
         * Get the offline audio context used by this backend or create one
         *
         * @param {number} sampleRate The sample rate to use
         * @return {OfflineAudioContext} Existing offline audio context, or creates
         * a new one
         */

      }, {
        key: "getOfflineAudioContext",
        value: function getOfflineAudioContext(sampleRate) {
          if (!window.WaveSurferOfflineAudioContext) {
            window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, sampleRate);
          }

          return window.WaveSurferOfflineAudioContext;
        }
        /**
         * Construct the backend
         *
         * @param {WavesurferParams} params Wavesurfer parameters
         */

      }]);

      function WebAudio(params) {
        var _this$stateBehaviors, _this$states;

        var _this;

        _classCallCheck(this, WebAudio);

        _this = _super.call(this);
        /** @private */

        _this.audioContext = null;
        _this.offlineAudioContext = null;
        _this.stateBehaviors = (_this$stateBehaviors = {}, _defineProperty(_this$stateBehaviors, PLAYING, {
          init: function init() {
            this.addOnAudioProcess();
          },
          getPlayedPercents: function getPlayedPercents() {
            var duration = this.getDuration();
            return this.getCurrentTime() / duration || 0;
          },
          getCurrentTime: function getCurrentTime() {
            return this.startPosition + this.getPlayedTime();
          }
        }), _defineProperty(_this$stateBehaviors, PAUSED, {
          init: function init() {
            this.removeOnAudioProcess();
          },
          getPlayedPercents: function getPlayedPercents() {
            var duration = this.getDuration();
            return this.getCurrentTime() / duration || 0;
          },
          getCurrentTime: function getCurrentTime() {
            return this.startPosition;
          }
        }), _defineProperty(_this$stateBehaviors, FINISHED, {
          init: function init() {
            this.removeOnAudioProcess();
            this.fireEvent('finish');
          },
          getPlayedPercents: function getPlayedPercents() {
            return 1;
          },
          getCurrentTime: function getCurrentTime() {
            return this.getDuration();
          }
        }), _this$stateBehaviors);
        _this.params = params;
        /** ac: Audio Context instance */

        _this.ac = params.audioContext || (_this.supportsWebAudio() ? _this.getAudioContext() : {});
        /**@private */

        _this.lastPlay = _this.ac.currentTime;
        /** @private */

        _this.startPosition = 0;
        /** @private */

        _this.scheduledPause = null;
        /** @private */

        _this.states = (_this$states = {}, _defineProperty(_this$states, PLAYING, Object.create(_this.stateBehaviors[PLAYING])), _defineProperty(_this$states, PAUSED, Object.create(_this.stateBehaviors[PAUSED])), _defineProperty(_this$states, FINISHED, Object.create(_this.stateBehaviors[FINISHED])), _this$states);
        /** @private */

        _this.buffer = null;
        /** @private */

        _this.filters = [];
        /** gainNode: allows to control audio volume */

        _this.gainNode = null;
        /** @private */

        _this.mergedPeaks = null;
        /** @private */

        _this.offlineAc = null;
        /** @private */

        _this.peaks = null;
        /** @private */

        _this.playbackRate = 1;
        /** analyser: provides audio analysis information */

        _this.analyser = null;
        /** scriptNode: allows processing audio */

        _this.scriptNode = null;
        /** @private */

        _this.source = null;
        /** @private */

        _this.splitPeaks = [];
        /** @private */

        _this.state = null;
        /** @private */

        _this.explicitDuration = params.duration;
        /**
         * Boolean indicating if the backend was destroyed.
         */

        _this.destroyed = false;
        return _this;
      }
      /**
       * Initialise the backend, called in `wavesurfer.createBackend()`
       */


      _createClass(WebAudio, [{
        key: "init",
        value: function init() {
          this.createVolumeNode();
          this.createScriptNode();
          this.createAnalyserNode();
          this.setState(PAUSED);
          this.setPlaybackRate(this.params.audioRate);
          this.setLength(0);
        }
        /** @private */

      }, {
        key: "disconnectFilters",
        value: function disconnectFilters() {
          if (this.filters) {
            this.filters.forEach(function (filter) {
              filter && filter.disconnect();
            });
            this.filters = null; // Reconnect direct path

            this.analyser.connect(this.gainNode);
          }
        }
        /**
         * @private
         *
         * @param {string} state The new state
         */

      }, {
        key: "setState",
        value: function setState(state) {
          if (this.state !== this.states[state]) {
            this.state = this.states[state];
            this.state.init.call(this);
          }
        }
        /**
         * Unpacked `setFilters()`
         *
         * @param {...AudioNode} filters One or more filters to set
         */

      }, {
        key: "setFilter",
        value: function setFilter() {
          for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
            filters[_key] = arguments[_key];
          }

          this.setFilters(filters);
        }
        /**
         * Insert custom Web Audio nodes into the graph
         *
         * @param {AudioNode[]} filters Packed filters array
         * @example
         * const lowpass = wavesurfer.backend.ac.createBiquadFilter();
         * wavesurfer.backend.setFilter(lowpass);
         */

      }, {
        key: "setFilters",
        value: function setFilters(filters) {
          // Remove existing filters
          this.disconnectFilters(); // Insert filters if filter array not empty

          if (filters && filters.length) {
            this.filters = filters; // Disconnect direct path before inserting filters

            this.analyser.disconnect(); // Connect each filter in turn

            filters.reduce(function (prev, curr) {
              prev.connect(curr);
              return curr;
            }, this.analyser).connect(this.gainNode);
          }
        }
        /** Create ScriptProcessorNode to process audio */

      }, {
        key: "createScriptNode",
        value: function createScriptNode() {
          if (this.params.audioScriptProcessor) {
            this.scriptNode = this.params.audioScriptProcessor;
          } else {
            if (this.ac.createScriptProcessor) {
              this.scriptNode = this.ac.createScriptProcessor(WebAudio.scriptBufferSize);
            } else {
              this.scriptNode = this.ac.createJavaScriptNode(WebAudio.scriptBufferSize);
            }
          }

          this.scriptNode.connect(this.ac.destination);
        }
        /** @private */

      }, {
        key: "addOnAudioProcess",
        value: function addOnAudioProcess() {
          var _this2 = this;

          this.scriptNode.onaudioprocess = function () {
            var time = _this2.getCurrentTime();

            if (time >= _this2.getDuration()) {
              _this2.setState(FINISHED);

              _this2.fireEvent('pause');
            } else if (time >= _this2.scheduledPause) {
              _this2.pause();
            } else if (_this2.state === _this2.states[PLAYING]) {
              _this2.fireEvent('audioprocess', time);
            }
          };
        }
        /** @private */

      }, {
        key: "removeOnAudioProcess",
        value: function removeOnAudioProcess() {
          this.scriptNode.onaudioprocess = function () {};
        }
        /** Create analyser node to perform audio analysis */

      }, {
        key: "createAnalyserNode",
        value: function createAnalyserNode() {
          this.analyser = this.ac.createAnalyser();
          this.analyser.connect(this.gainNode);
        }
        /**
         * Create the gain node needed to control the playback volume.
         *
         */

      }, {
        key: "createVolumeNode",
        value: function createVolumeNode() {
          // Create gain node using the AudioContext
          if (this.ac.createGain) {
            this.gainNode = this.ac.createGain();
          } else {
            this.gainNode = this.ac.createGainNode();
          } // Add the gain node to the graph


          this.gainNode.connect(this.ac.destination);
        }
        /**
         * Set the sink id for the media player
         *
         * @param {string} deviceId String value representing audio device id.
         * @returns {Promise} A Promise that resolves to `undefined` when there
         * are no errors.
         */

      }, {
        key: "setSinkId",
        value: function setSinkId(deviceId) {
          if (deviceId) {
            /**
             * The webaudio API doesn't currently support setting the device
             * output. Here we create an HTMLAudioElement, connect the
             * webaudio stream to that element and setSinkId there.
             */
            var audio = new window.Audio();

            if (!audio.setSinkId) {
              return Promise.reject(new Error('setSinkId is not supported in your browser'));
            }

            audio.autoplay = true;
            var dest = this.ac.createMediaStreamDestination();
            this.gainNode.disconnect();
            this.gainNode.connect(dest);
            audio.srcObject = dest.stream;
            return audio.setSinkId(deviceId);
          } else {
            return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
          }
        }
        /**
         * Set the audio volume
         *
         * @param {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "setVolume",
        value: function setVolume(value) {
          this.gainNode.gain.setValueAtTime(value, this.ac.currentTime);
        }
        /**
         * Get the current volume
         *
         * @return {number} value A floating point value between 0 and 1.
         */

      }, {
        key: "getVolume",
        value: function getVolume() {
          return this.gainNode.gain.value;
        }
        /**
         * Decode an array buffer and pass data to a callback
         *
         * @private
         * @param {ArrayBuffer} arraybuffer The array buffer to decode
         * @param {function} callback The function to call on complete.
         * @param {function} errback The function to call on error.
         */

      }, {
        key: "decodeArrayBuffer",
        value: function decodeArrayBuffer(arraybuffer, callback, errback) {
          if (!this.offlineAc) {
            this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100);
          }

          if ('AudioContext' in window) {
            this.offlineAc.decodeAudioData(arraybuffer).then(function (data) {
              return callback(data);
            }).catch(function (err) {
              return errback(err);
            });
          } else {
            // Safari: no support for Promise-based decodeAudioData yet
            this.offlineAc.decodeAudioData(arraybuffer, function (data) {
              return callback(data);
            }, errback);
          }
        }
        /**
         * Set pre-decoded peaks
         *
         * @param {number[]|Number.<Array[]>} peaks Peaks data
         * @param {?number} duration Explicit duration
         */

      }, {
        key: "setPeaks",
        value: function setPeaks(peaks, duration) {
          if (duration != null) {
            this.explicitDuration = duration;
          }

          this.peaks = peaks;
        }
        /**
         * Set the rendered length (different from the length of the audio)
         *
         * @param {number} length The rendered length
         */

      }, {
        key: "setLength",
        value: function setLength(length) {
          // No resize, we can preserve the cached peaks.
          if (this.mergedPeaks && length == 2 * this.mergedPeaks.length - 1 + 2) {
            return;
          }

          this.splitPeaks = [];
          this.mergedPeaks = []; // Set the last element of the sparse array so the peak arrays are
          // appropriately sized for other calculations.

          var channels = this.buffer ? this.buffer.numberOfChannels : 1;
          var c;

          for (c = 0; c < channels; c++) {
            this.splitPeaks[c] = [];
            this.splitPeaks[c][2 * (length - 1)] = 0;
            this.splitPeaks[c][2 * (length - 1) + 1] = 0;
          }

          this.mergedPeaks[2 * (length - 1)] = 0;
          this.mergedPeaks[2 * (length - 1) + 1] = 0;
        }
        /**
         * Compute the max and min value of the waveform when broken into <length> subranges.
         *
         * @param {number} length How many subranges to break the waveform into.
         * @param {number} first First sample in the required range.
         * @param {number} last Last sample in the required range.
         * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of arrays of
         * peaks consisting of (max, min) values for each subrange.
         */

      }, {
        key: "getPeaks",
        value: function getPeaks(length, first, last) {
          if (this.peaks) {
            return this.peaks;
          }

          if (!this.buffer) {
            return [];
          }

          first = first || 0;
          last = last || length - 1;
          this.setLength(length);

          if (!this.buffer) {
            return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
          }
          /**
           * The following snippet fixes a buffering data issue on the Safari
           * browser which returned undefined It creates the missing buffer based
           * on 1 channel, 4096 samples and the sampleRate from the current
           * webaudio context 4096 samples seemed to be the best fit for rendering
           * will review this code once a stable version of Safari TP is out
           */


          if (!this.buffer.length) {
            var newBuffer = this.createBuffer(1, 4096, this.sampleRate);
            this.buffer = newBuffer.buffer;
          }

          var sampleSize = this.buffer.length / length;
          var sampleStep = ~~(sampleSize / 10) || 1;
          var channels = this.buffer.numberOfChannels;
          var c;

          for (c = 0; c < channels; c++) {
            var peaks = this.splitPeaks[c];
            var chan = this.buffer.getChannelData(c);
            var i = void 0;

            for (i = first; i <= last; i++) {
              var start = ~~(i * sampleSize);
              var end = ~~(start + sampleSize);
              /**
               * Initialize the max and min to the first sample of this
               * subrange, so that even if the samples are entirely
               * on one side of zero, we still return the true max and
               * min values in the subrange.
               */

              var min = chan[start];
              var max = min;
              var j = void 0;

              for (j = start; j < end; j += sampleStep) {
                var value = chan[j];

                if (value > max) {
                  max = value;
                }

                if (value < min) {
                  min = value;
                }
              }

              peaks[2 * i] = max;
              peaks[2 * i + 1] = min;

              if (c == 0 || max > this.mergedPeaks[2 * i]) {
                this.mergedPeaks[2 * i] = max;
              }

              if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
                this.mergedPeaks[2 * i + 1] = min;
              }
            }
          }

          return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
        }
        /**
         * Get the position from 0 to 1
         *
         * @return {number} Position
         */

      }, {
        key: "getPlayedPercents",
        value: function getPlayedPercents() {
          return this.state.getPlayedPercents.call(this);
        }
        /** @private */

      }, {
        key: "disconnectSource",
        value: function disconnectSource() {
          if (this.source) {
            this.source.disconnect();
          }
        }
        /**
         * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context
         */

      }, {
        key: "destroyWebAudio",
        value: function destroyWebAudio() {
          this.disconnectFilters();
          this.disconnectSource();
          this.gainNode.disconnect();
          this.scriptNode.disconnect();
          this.analyser.disconnect(); // close the audioContext if closeAudioContext option is set to true

          if (this.params.closeAudioContext) {
            // check if browser supports AudioContext.close()
            if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
              this.ac.close();
            } // clear the reference to the audiocontext


            this.ac = null; // clear the actual audiocontext, either passed as param or the
            // global singleton

            if (!this.params.audioContext) {
              window.WaveSurferAudioContext = null;
            } else {
              this.params.audioContext = null;
            } // clear the offlineAudioContext


            window.WaveSurferOfflineAudioContext = null;
          }
        }
        /**
         * This is called when wavesurfer is destroyed
         */

      }, {
        key: "destroy",
        value: function destroy() {
          if (!this.isPaused()) {
            this.pause();
          }

          this.unAll();
          this.buffer = null;
          this.destroyed = true;
          this.destroyWebAudio();
        }
        /**
         * Loaded a decoded audio buffer
         *
         * @param {Object} buffer Decoded audio buffer to load
         */

      }, {
        key: "load",
        value: function load(buffer) {
          this.startPosition = 0;
          this.lastPlay = this.ac.currentTime;
          this.buffer = buffer;
          this.createSource();
        }
        /** @private */

      }, {
        key: "createSource",
        value: function createSource() {
          this.disconnectSource();
          this.source = this.ac.createBufferSource(); // adjust for old browsers

          this.source.start = this.source.start || this.source.noteGrainOn;
          this.source.stop = this.source.stop || this.source.noteOff;
          this.setPlaybackRate(this.playbackRate);
          this.source.buffer = this.buffer;
          this.source.connect(this.analyser);
        }
        /**
         * @private
         *
         * some browsers require an explicit call to #resume before they will play back audio
         */

      }, {
        key: "resumeAudioContext",
        value: function resumeAudioContext() {
          if (this.ac.state == 'suspended') {
            this.ac.resume && this.ac.resume();
          }
        }
        /**
         * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
         *
         * @return {boolean} Whether or not this backend is currently paused
         */

      }, {
        key: "isPaused",
        value: function isPaused() {
          return this.state !== this.states[PLAYING];
        }
        /**
         * Used by `wavesurfer.getDuration()`
         *
         * @return {number} Duration of loaded buffer
         */

      }, {
        key: "getDuration",
        value: function getDuration() {
          if (this.explicitDuration) {
            return this.explicitDuration;
          }

          if (!this.buffer) {
            return 0;
          }

          return this.buffer.duration;
        }
        /**
         * Used by `wavesurfer.seekTo()`
         *
         * @param {number} start Position to start at in seconds
         * @param {number} end Position to end at in seconds
         * @return {{start: number, end: number}} Object containing start and end
         * positions
         */

      }, {
        key: "seekTo",
        value: function seekTo(start, end) {
          if (!this.buffer) {
            return;
          }

          this.scheduledPause = null;

          if (start == null) {
            start = this.getCurrentTime();

            if (start >= this.getDuration()) {
              start = 0;
            }
          }

          if (end == null) {
            end = this.getDuration();
          }

          this.startPosition = start;
          this.lastPlay = this.ac.currentTime;

          if (this.state === this.states[FINISHED]) {
            this.setState(PAUSED);
          }

          return {
            start: start,
            end: end
          };
        }
        /**
         * Get the playback position in seconds
         *
         * @return {number} The playback position in seconds
         */

      }, {
        key: "getPlayedTime",
        value: function getPlayedTime() {
          return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
        }
        /**
         * Plays the loaded audio region.
         *
         * @param {number} start Start offset in seconds, relative to the beginning
         * of a clip.
         * @param {number} end When to stop relative to the beginning of a clip.
         */

      }, {
        key: "play",
        value: function play(start, end) {
          if (!this.buffer) {
            return;
          } // need to re-create source on each playback


          this.createSource();
          var adjustedTime = this.seekTo(start, end);
          start = adjustedTime.start;
          end = adjustedTime.end;
          this.scheduledPause = end;
          this.source.start(0, start);
          this.resumeAudioContext();
          this.setState(PLAYING);
          this.fireEvent('play');
        }
        /**
         * Pauses the loaded audio.
         */

      }, {
        key: "pause",
        value: function pause() {
          this.scheduledPause = null;
          this.startPosition += this.getPlayedTime();
          this.source && this.source.stop(0);
          this.setState(PAUSED);
          this.fireEvent('pause');
        }
        /**
         * Returns the current time in seconds relative to the audio-clip's
         * duration.
         *
         * @return {number} The current time in seconds
         */

      }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
          return this.state.getCurrentTime.call(this);
        }
        /**
         * Returns the current playback rate. (0=no playback, 1=normal playback)
         *
         * @return {number} The current playback rate
         */

      }, {
        key: "getPlaybackRate",
        value: function getPlaybackRate() {
          return this.playbackRate;
        }
        /**
         * Set the audio source playback rate.
         *
         * @param {number} value The playback rate to use
         */

      }, {
        key: "setPlaybackRate",
        value: function setPlaybackRate(value) {
          this.playbackRate = value || 1;
          this.source && this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime);
        }
        /**
         * Set a point in seconds for playback to stop at.
         *
         * @param {number} end Position to end at
         * @version 3.3.0
         */

      }, {
        key: "setPlayEnd",
        value: function setPlayEnd(end) {
          this.scheduledPause = end;
        }
      }]);

      return WebAudio;
    }(util.Observer);

    exports.default = WebAudio;
    WebAudio.scriptBufferSize = 256;
    module.exports = exports.default;

    /***/ })

    /******/ });
    });

    });

    var WaveSurfer = /*@__PURE__*/getDefaultExportFromCjs(wavesurfer);

    /* src/routes/home/Audio.svelte generated by Svelte v3.31.0 */
    const file$5 = "src/routes/home/Audio.svelte";

    function create_fragment$6(ctx) {
    	let div2;
    	let div0;
    	let button;
    	let button_disabled_value;
    	let t;
    	let div1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button = element("button");
    			t = space();
    			div1 = element("div");
    			button.disabled = button_disabled_value = !/*audioPlayer*/ ctx[1];
    			attr_dev(button, "class", "svelte-mgvljc");
    			toggle_class(button, "paused", /*showPause*/ ctx[2]);
    			add_location(button, file$5, 103, 4, 2291);
    			attr_dev(div0, "class", "controls svelte-mgvljc");
    			add_location(div0, file$5, 102, 2, 2264);
    			attr_dev(div1, "id", "waveform");
    			attr_dev(div1, "class", "waveform svelte-mgvljc");
    			add_location(div1, file$5, 108, 2, 2399);
    			attr_dev(div2, "class", "container svelte-mgvljc");
    			add_location(div2, file$5, 101, 0, 2238);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			/*div1_binding*/ ctx[4](div1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onClick*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*audioPlayer*/ 2 && button_disabled_value !== (button_disabled_value = !/*audioPlayer*/ ctx[1])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*showPause*/ 4) {
    				toggle_class(button, "paused", /*showPause*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			/*div1_binding*/ ctx[4](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Audio", slots, []);
    	let waveform;
    	let audioPlayer;
    	let showPause;

    	function onClick(e) {
    		audioPlayer.playPause();
    	}

    	function onAudioPlay(e) {
    		$$invalidate(2, showPause = audioPlayer.isPlaying());
    	}

    	function onAudioPause(e) {
    		$$invalidate(2, showPause = audioPlayer.isPlaying());
    	}

    	function onAudioSeek(e) {
    		if (audioPlayer.isPlaying()) {
    			audioPlayer.play();
    		}
    	}

    	onMount(() => {
    		function onAudioReady() {
    			$$invalidate(1, audioPlayer = wavesurfer);
    		}

    		let wavesurfer = WaveSurfer.create({
    			container: waveform,
    			barWidth: 2,
    			barHeight: 1,
    			barGap: null,
    			responsive: true,
    			hideScrollbar: true,
    			cursorWidth: 0,
    			waveColor: "#f96400",
    			progressColor: "#e1fe6e",
    			normalize: true,
    			height: 64
    		});

    		wavesurfer.load("./assets/audio/welcome.mp3");
    		wavesurfer.on("ready", onAudioReady);
    		wavesurfer.on("play", onAudioPlay);
    		wavesurfer.on("pause", onAudioPause);
    		wavesurfer.on("seek", onAudioSeek);

    		return () => {
    			wavesurfer.un("ready", onAudioReady);
    			wavesurfer.un("play", onAudioPlay);
    			wavesurfer.un("pause", onAudioPause);
    			wavesurfer.un("seek", onAudioSeek);
    		};
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Audio> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			waveform = $$value;
    			$$invalidate(0, waveform);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		WaveSurfer,
    		waveform,
    		audioPlayer,
    		showPause,
    		onClick,
    		onAudioPlay,
    		onAudioPause,
    		onAudioSeek
    	});

    	$$self.$inject_state = $$props => {
    		if ("waveform" in $$props) $$invalidate(0, waveform = $$props.waveform);
    		if ("audioPlayer" in $$props) $$invalidate(1, audioPlayer = $$props.audioPlayer);
    		if ("showPause" in $$props) $$invalidate(2, showPause = $$props.showPause);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [waveform, audioPlayer, showPause, onClick, div1_binding];
    }

    class Audio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Audio",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/routes/home/Welcome.svelte generated by Svelte v3.31.0 */
    const file$6 = "src/routes/home/Welcome.svelte";

    function create_fragment$7(ctx) {
    	let section0;
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let section1;
    	let audio;
    	let current;
    	audio = new Audio({ $$inline: true });

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			h1 = element("h1");
    			h1.textContent = "psst";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = ".--. --- ... - -.-. --- .-. --- -. .. .- .-.. .. ... --";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "is an open collective, study, solidarity and strategy group that commonly\n    works on for the urgent spread of interdisciplinary care, the\n    demilitarisation of the health education and labor sectors and the\n    ecological, systematic and agnotological comorbidity of Capital.";
    			t5 = space();
    			section1 = element("section");
    			create_component(audio.$$.fragment);
    			attr_dev(h1, "class", "logo svelte-l7883b");
    			add_location(h1, file$6, 29, 2, 390);
    			attr_dev(p0, "class", "divider svelte-l7883b");
    			add_location(p0, file$6, 31, 2, 420);
    			attr_dev(p1, "class", "svelte-l7883b");
    			add_location(p1, file$6, 33, 2, 502);
    			attr_dev(section0, "class", "banner svelte-l7883b");
    			add_location(section0, file$6, 28, 0, 363);
    			attr_dev(section1, "class", "audio");
    			add_location(section1, file$6, 41, 0, 809);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, h1);
    			append_dev(section0, t1);
    			append_dev(section0, p0);
    			append_dev(section0, t3);
    			append_dev(section0, p1);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, section1, anchor);
    			mount_component(audio, section1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(section1);
    			destroy_component(audio);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Welcome", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Welcome> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Audio });
    	return [];
    }

    class Welcome extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Welcome",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/components/Pad.svelte generated by Svelte v3.31.0 */

    function create_fragment$8(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Pad", slots, []);
    	let { key } = $$props;
    	let { name } = $$props;
    	const writable_props = ["key", "name"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pad> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("key" in $$props) $$invalidate(0, key = $$props.key);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    	};

    	$$self.$capture_state = () => ({ key, name });

    	$$self.$inject_state = $$props => {
    		if ("key" in $$props) $$invalidate(0, key = $$props.key);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [key, name];
    }

    class Pad extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { key: 0, name: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pad",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*key*/ ctx[0] === undefined && !("key" in props)) {
    			console.warn("<Pad> was created without expected prop 'key'");
    		}

    		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
    			console.warn("<Pad> was created without expected prop 'name'");
    		}
    	}

    	get key() {
    		throw new Error("<Pad>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Pad>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Pad>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Pad>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var moment = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
         module.exports = factory() ;
    }(commonjsGlobal, (function () {
        var hookCallback;

        function hooks() {
            return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
            hookCallback = callback;
        }

        function isArray(input) {
            return (
                input instanceof Array ||
                Object.prototype.toString.call(input) === '[object Array]'
            );
        }

        function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
                input != null &&
                Object.prototype.toString.call(input) === '[object Object]'
            );
        }

        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }

        function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
                return Object.getOwnPropertyNames(obj).length === 0;
            } else {
                var k;
                for (k in obj) {
                    if (hasOwnProp(obj, k)) {
                        return false;
                    }
                }
                return true;
            }
        }

        function isUndefined(input) {
            return input === void 0;
        }

        function isNumber(input) {
            return (
                typeof input === 'number' ||
                Object.prototype.toString.call(input) === '[object Number]'
            );
        }

        function isDate(input) {
            return (
                input instanceof Date ||
                Object.prototype.toString.call(input) === '[object Date]'
            );
        }

        function map(arr, fn) {
            var res = [],
                i;
            for (i = 0; i < arr.length; ++i) {
                res.push(fn(arr[i], i));
            }
            return res;
        }

        function extend(a, b) {
            for (var i in b) {
                if (hasOwnProp(b, i)) {
                    a[i] = b[i];
                }
            }

            if (hasOwnProp(b, 'toString')) {
                a.toString = b.toString;
            }

            if (hasOwnProp(b, 'valueOf')) {
                a.valueOf = b.valueOf;
            }

            return a;
        }

        function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
                empty: false,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: false,
                invalidEra: null,
                invalidMonth: null,
                invalidFormat: false,
                userInvalidated: false,
                iso: false,
                parsedDateParts: [],
                era: null,
                meridiem: null,
                rfc2822: false,
                weekdayMismatch: false,
            };
        }

        function getParsingFlags(m) {
            if (m._pf == null) {
                m._pf = defaultParsingFlags();
            }
            return m._pf;
        }

        var some;
        if (Array.prototype.some) {
            some = Array.prototype.some;
        } else {
            some = function (fun) {
                var t = Object(this),
                    len = t.length >>> 0,
                    i;

                for (i = 0; i < len; i++) {
                    if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                    }
                }

                return false;
            };
        }

        function isValid(m) {
            if (m._isValid == null) {
                var flags = getParsingFlags(m),
                    parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    }),
                    isNowValid =
                        !isNaN(m._d.getTime()) &&
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidEra &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));

                if (m._strict) {
                    isNowValid =
                        isNowValid &&
                        flags.charsLeftOver === 0 &&
                        flags.unusedTokens.length === 0 &&
                        flags.bigHour === undefined;
                }

                if (Object.isFrozen == null || !Object.isFrozen(m)) {
                    m._isValid = isNowValid;
                } else {
                    return isNowValid;
                }
            }
            return m._isValid;
        }

        function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
                extend(getParsingFlags(m), flags);
            } else {
                getParsingFlags(m).userInvalidated = true;
            }

            return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = (hooks.momentProperties = []),
            updateInProgress = false;

        function copyConfig(to, from) {
            var i, prop, val;

            if (!isUndefined(from._isAMomentObject)) {
                to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
                to._i = from._i;
            }
            if (!isUndefined(from._f)) {
                to._f = from._f;
            }
            if (!isUndefined(from._l)) {
                to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
                to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
                to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
                to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
                to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
                to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
                to._locale = from._locale;
            }

            if (momentProperties.length > 0) {
                for (i = 0; i < momentProperties.length; i++) {
                    prop = momentProperties[i];
                    val = from[prop];
                    if (!isUndefined(val)) {
                        to[prop] = val;
                    }
                }
            }

            return to;
        }

        // Moment prototype object
        function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
                this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
                updateInProgress = true;
                hooks.updateOffset(this);
                updateInProgress = false;
            }
        }

        function isMoment(obj) {
            return (
                obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
            );
        }

        function warn(msg) {
            if (
                hooks.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' &&
                console.warn
            ) {
                console.warn('Deprecation warning: ' + msg);
            }
        }

        function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(null, msg);
                }
                if (firstTime) {
                    var args = [],
                        arg,
                        i,
                        key;
                    for (i = 0; i < arguments.length; i++) {
                        arg = '';
                        if (typeof arguments[i] === 'object') {
                            arg += '\n[' + i + '] ';
                            for (key in arguments[0]) {
                                if (hasOwnProp(arguments[0], key)) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                            }
                            arg = arg.slice(0, -2); // Remove trailing comma and space
                        } else {
                            arg = arguments[i];
                        }
                        args.push(arg);
                    }
                    warn(
                        msg +
                            '\nArguments: ' +
                            Array.prototype.slice.call(args).join('') +
                            '\n' +
                            new Error().stack
                    );
                    firstTime = false;
                }
                return fn.apply(this, arguments);
            }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
                warn(msg);
                deprecations[name] = true;
            }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
            return (
                (typeof Function !== 'undefined' && input instanceof Function) ||
                Object.prototype.toString.call(input) === '[object Function]'
            );
        }

        function set(config) {
            var prop, i;
            for (i in config) {
                if (hasOwnProp(config, i)) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
                (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                    '|' +
                    /\d{1,2}/.source
            );
        }

        function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
                prop;
            for (prop in childConfig) {
                if (hasOwnProp(childConfig, prop)) {
                    if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                    } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                    } else {
                        delete res[prop];
                    }
                }
            }
            for (prop in parentConfig) {
                if (
                    hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])
                ) {
                    // make sure changes to properties don't modify parent config
                    res[prop] = extend({}, res[prop]);
                }
            }
            return res;
        }

        function Locale(config) {
            if (config != null) {
                this.set(config);
            }
        }

        var keys;

        if (Object.keys) {
            keys = Object.keys;
        } else {
            keys = function (obj) {
                var i,
                    res = [];
                for (i in obj) {
                    if (hasOwnProp(obj, i)) {
                        res.push(i);
                    }
                }
                return res;
            };
        }

        var defaultCalendar = {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        };

        function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar['sameElse'];
            return isFunction(output) ? output.call(mom, now) : output;
        }

        function zeroFill(number, targetLength, forceSign) {
            var absNumber = '' + Math.abs(number),
                zerosToFill = targetLength - absNumber.length,
                sign = number >= 0;
            return (
                (sign ? (forceSign ? '+' : '') : '-') +
                Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
                absNumber
            );
        }

        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === 'string') {
                func = function () {
                    return this[callback]();
                };
            }
            if (token) {
                formatTokenFunctions[token] = func;
            }
            if (padded) {
                formatTokenFunctions[padded[0]] = function () {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                };
            }
            if (ordinal) {
                formatTokenFunctions[ordinal] = function () {
                    return this.localeData().ordinal(
                        func.apply(this, arguments),
                        token
                    );
                };
            }
        }

        function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
                return input.replace(/^\[|\]$/g, '');
            }
            return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
                i,
                length;

            for (i = 0, length = array.length; i < length; i++) {
                if (formatTokenFunctions[array[i]]) {
                    array[i] = formatTokenFunctions[array[i]];
                } else {
                    array[i] = removeFormattingTokens(array[i]);
                }
            }

            return function (mom) {
                var output = '',
                    i;
                for (i = 0; i < length; i++) {
                    output += isFunction(array[i])
                        ? array[i].call(mom, format)
                        : array[i];
                }
                return output;
            };
        }

        // format date using native date object
        function formatMoment(m, format) {
            if (!m.isValid()) {
                return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
                formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
                format = format.replace(
                    localFormattingTokens,
                    replaceLongDateFormatTokens
                );
                localFormattingTokens.lastIndex = 0;
                i -= 1;
            }

            return format;
        }

        var defaultLongDateFormat = {
            LTS: 'h:mm:ss A',
            LT: 'h:mm A',
            L: 'MM/DD/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        };

        function longDateFormat(key) {
            var format = this._longDateFormat[key],
                formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
                return format;
            }

            this._longDateFormat[key] = formatUpper
                .match(formattingTokens)
                .map(function (tok) {
                    if (
                        tok === 'MMMM' ||
                        tok === 'MM' ||
                        tok === 'DD' ||
                        tok === 'dddd'
                    ) {
                        return tok.slice(1);
                    }
                    return tok;
                })
                .join('');

            return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
            return this._invalidDate;
        }

        var defaultOrdinal = '%d',
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
            return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            w: 'a week',
            ww: '%d weeks',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
                ? output(number, withoutSuffix, string, isFuture)
                : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
            return typeof units === 'string'
                ? aliases[units] || aliases[units.toLowerCase()]
                : undefined;
        }

        function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
                normalizedProp,
                prop;

            for (prop in inputObject) {
                if (hasOwnProp(inputObject, prop)) {
                    normalizedProp = normalizeUnits(prop);
                    if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                    }
                }
            }

            return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
            var units = [],
                u;
            for (u in unitsObj) {
                if (hasOwnProp(unitsObj, u)) {
                    units.push({ unit: u, priority: priorities[u] });
                }
            }
            units.sort(function (a, b) {
                return a.priority - b.priority;
            });
            return units;
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }

        function absFloor(number) {
            if (number < 0) {
                // -0 -> 0
                return Math.ceil(number) || 0;
            } else {
                return Math.floor(number);
            }
        }

        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                value = absFloor(coercedNumber);
            }

            return value;
        }

        function makeGetSet(unit, keepTime) {
            return function (value) {
                if (value != null) {
                    set$1(this, unit, value);
                    hooks.updateOffset(this, keepTime);
                    return this;
                } else {
                    return get(this, unit);
                }
            };
        }

        function get(mom, unit) {
            return mom.isValid()
                ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
                : NaN;
        }

        function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
                if (
                    unit === 'FullYear' &&
                    isLeapYear(mom.year()) &&
                    mom.month() === 1 &&
                    mom.date() === 29
                ) {
                    value = toInt(value);
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                        value,
                        mom.month(),
                        daysInMonth(value, mom.month())
                    );
                } else {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }
        }

        // MOMENTS

        function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units]();
            }
            return this;
        }

        function stringSet(units, value) {
            if (typeof units === 'object') {
                units = normalizeObjectUnits(units);
                var prioritized = getPrioritizedUnits(units),
                    i;
                for (i = 0; i < prioritized.length; i++) {
                    this[prioritized[i].unit](units[prioritized[i].unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units](value);
                }
            }
            return this;
        }

        var match1 = /\d/, //       0 - 9
            match2 = /\d\d/, //      00 - 99
            match3 = /\d{3}/, //     000 - 999
            match4 = /\d{4}/, //    0000 - 9999
            match6 = /[+-]?\d{6}/, // -999999 - 999999
            match1to2 = /\d\d?/, //       0 - 99
            match3to4 = /\d\d\d\d?/, //     999 - 9999
            match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
            match1to3 = /\d{1,3}/, //       0 - 999
            match1to4 = /\d{1,4}/, //       0 - 9999
            match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
            matchUnsigned = /\d+/, //       0 - inf
            matchSigned = /[+-]?\d+/, //    -inf - inf
            matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;

        regexes = {};

        function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
                ? regex
                : function (isStrict, localeData) {
                      return isStrict && strictRegex ? strictRegex : regex;
                  };
        }

        function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
                return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
            return regexEscape(
                s
                    .replace('\\', '')
                    .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                        matched,
                        p1,
                        p2,
                        p3,
                        p4
                    ) {
                        return p1 || p2 || p3 || p4;
                    })
            );
        }

        function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
            var i,
                func = callback;
            if (typeof token === 'string') {
                token = [token];
            }
            if (isNumber(callback)) {
                func = function (input, array) {
                    array[callback] = toInt(input);
                };
            }
            for (i = 0; i < token.length; i++) {
                tokens[token[i]] = func;
            }
        }

        function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
                config._w = config._w || {};
                callback(input, config._w, config, token);
            });
        }

        function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
                tokens[token](input, config._a, config, token);
            }
        }

        var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

        function mod(n, x) {
            return ((n % x) + x) % x;
        }

        var indexOf;

        if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
        } else {
            indexOf = function (o) {
                // I know
                var i;
                for (i = 0; i < this.length; ++i) {
                    if (this[i] === o) {
                        return i;
                    }
                }
                return -1;
            };
        }

        function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
                return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
                ? isLeapYear(year)
                    ? 29
                    : 28
                : 31 - ((modMonth % 7) % 2);
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
            return this.month() + 1;
        });

        addFormatToken('MMM', 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
        });

        addFormatToken('MMMM', 0, 0, function (format) {
            return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
        });

        addParseToken(['M', 'MM'], function (input, array) {
            array[MONTH] = toInt(input) - 1;
        });

        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
                array[MONTH] = month;
            } else {
                getParsingFlags(config).invalidMonth = input;
            }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
                '_'
            ),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

        function localeMonths(m, format) {
            if (!m) {
                return isArray(this._months)
                    ? this._months
                    : this._months['standalone'];
            }
            return isArray(this._months)
                ? this._months[m.month()]
                : this._months[
                      (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                          ? 'format'
                          : 'standalone'
                  ][m.month()];
        }

        function localeMonthsShort(m, format) {
            if (!m) {
                return isArray(this._monthsShort)
                    ? this._monthsShort
                    : this._monthsShort['standalone'];
            }
            return isArray(this._monthsShort)
                ? this._monthsShort[m.month()]
                : this._monthsShort[
                      MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                  ][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
            var i,
                ii,
                mom,
                llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
                // this is not used
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
                for (i = 0; i < 12; ++i) {
                    mom = createUTC([2000, i]);
                    this._shortMonthsParse[i] = this.monthsShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
                return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp(
                        '^' + this.months(mom, '').replace('.', '') + '$',
                        'i'
                    );
                    this._shortMonthsParse[i] = new RegExp(
                        '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                        'i'
                    );
                }
                if (!strict && !this._monthsParse[i]) {
                    regex =
                        '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'MMMM' &&
                    this._longMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'MMM' &&
                    this._shortMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
                // No op
                return mom;
            }

            if (typeof value === 'string') {
                if (/^\d+$/.test(value)) {
                    value = toInt(value);
                } else {
                    value = mom.localeData().monthsParse(value);
                    // TODO: Another silent failure?
                    if (!isNumber(value)) {
                        return mom;
                    }
                }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
            return mom;
        }

        function getSetMonth(value) {
            if (value != null) {
                setMonth(this, value);
                hooks.updateOffset(this, true);
                return this;
            } else {
                return get(this, 'Month');
            }
        }

        function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
        }

        function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsShortStrictRegex;
                } else {
                    return this._monthsShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsShortRegex')) {
                    this._monthsShortRegex = defaultMonthsShortRegex;
                }
                return this._monthsShortStrictRegex && isStrict
                    ? this._monthsShortStrictRegex
                    : this._monthsShortRegex;
            }
        }

        function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsStrictRegex;
                } else {
                    return this._monthsRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    this._monthsRegex = defaultMonthsRegex;
                }
                return this._monthsStrictRegex && isStrict
                    ? this._monthsStrictRegex
                    : this._monthsRegex;
            }
        }

        function computeMonthsParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom;
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                shortPieces.push(this.monthsShort(mom, ''));
                longPieces.push(this.months(mom, ''));
                mixedPieces.push(this.months(mom, ''));
                mixedPieces.push(this.monthsShort(mom, ''));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
                shortPieces[i] = regexEscape(shortPieces[i]);
                longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
                mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._monthsShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });

        addFormatToken(0, ['YY', 2], 0, function () {
            return this.year() % 100;
        });

        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);

        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
            array[YEAR] =
                input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
            array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
            return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                date = new Date(y + 400, m, d, h, M, s, ms);
                if (isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
            } else {
                date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
        }

        function createUTCDate(y) {
            var date, args;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                args = Array.prototype.slice.call(arguments);
                // preserve leap years using a full 400 year cycle, then reset
                args[0] = y + 400;
                date = new Date(Date.UTC.apply(null, args));
                if (isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
            } else {
                date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,
                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
                weekOffset = firstWeekOffset(year, dow, doy),
                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                resYear,
                resDayOfYear;

            if (dayOfYear <= 0) {
                resYear = year - 1;
                resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
                resYear = year + 1;
                resDayOfYear = dayOfYear - daysInYear(year);
            } else {
                resYear = year;
                resDayOfYear = dayOfYear;
            }

            return {
                year: resYear,
                dayOfYear: resDayOfYear,
            };
        }

        function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                resWeek,
                resYear;

            if (week < 1) {
                resYear = mom.year() - 1;
                resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
                resWeek = week - weeksInYear(mom.year(), dow, doy);
                resYear = mom.year() + 1;
            } else {
                resYear = mom.year();
                resWeek = week;
            }

            return {
                week: resWeek,
                year: resYear,
            };
        }

        function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);

        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
            return this._week.dow;
        }

        function localeFirstDayOfYear() {
            return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');

        addFormatToken('dd', 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
        });

        addFormatToken('ddd', 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
        });

        addFormatToken('dddd', 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
        });

        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
        });

        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
            var weekday = config._locale.weekdaysParse(input, token, config._strict);
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
                week.d = weekday;
            } else {
                getParsingFlags(config).invalidWeekday = input;
            }
        });

        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
            week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
            if (typeof input !== 'string') {
                return input;
            }

            if (!isNaN(input)) {
                return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === 'number') {
                return input;
            }

            return null;
        }

        function parseIsoWeekday(input, locale) {
            if (typeof input === 'string') {
                return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
        }

        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

        function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
                ? this._weekdays
                : this._weekdays[
                      m && m !== true && this._weekdays.isFormat.test(format)
                          ? 'format'
                          : 'standalone'
                  ];
            return m === true
                ? shiftWeekdays(weekdays, this._week.dow)
                : m
                ? weekdays[m.day()]
                : weekdays;
        }

        function localeWeekdaysShort(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                : m
                ? this._weekdaysShort[m.day()]
                : this._weekdaysShort;
        }

        function localeWeekdaysMin(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                : m
                ? this._weekdaysMin[m.day()]
                : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
            var i,
                ii,
                mom,
                llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._minWeekdaysParse = [];

                for (i = 0; i < 7; ++i) {
                    mom = createUTC([2000, 1]).day(i);
                    this._minWeekdaysParse[i] = this.weekdaysMin(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._shortWeekdaysParse[i] = this.weekdaysShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
                return handleStrictParse$1.call(this, weekdayName, format, strict);
            }

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._minWeekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already

                mom = createUTC([2000, 1]).day(i);
                if (strict && !this._fullWeekdaysParse[i]) {
                    this._fullWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._shortWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._minWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                }
                if (!this._weekdaysParse[i]) {
                    regex =
                        '^' +
                        this.weekdays(mom, '') +
                        '|^' +
                        this.weekdaysShort(mom, '') +
                        '|^' +
                        this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'dddd' &&
                    this._fullWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'ddd' &&
                    this._shortWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'dd' &&
                    this._minWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        }

        function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
                var weekday = parseIsoWeekday(input, this.localeData());
                return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
                return this.day() || 7;
            }
        }

        function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysStrictRegex;
                } else {
                    return this._weekdaysRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    this._weekdaysRegex = defaultWeekdaysRegex;
                }
                return this._weekdaysStrictRegex && isStrict
                    ? this._weekdaysStrictRegex
                    : this._weekdaysRegex;
            }
        }

        function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysShortStrictRegex;
                } else {
                    return this._weekdaysShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                    this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                }
                return this._weekdaysShortStrictRegex && isStrict
                    ? this._weekdaysShortStrictRegex
                    : this._weekdaysShortRegex;
            }
        }

        function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysMinStrictRegex;
                } else {
                    return this._weekdaysMinRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                    this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                }
                return this._weekdaysMinStrictRegex && isStrict
                    ? this._weekdaysMinStrictRegex
                    : this._weekdaysMinRegex;
            }
        }

        function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var minPieces = [],
                shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom,
                minp,
                shortp,
                longp;
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, 1]).day(i);
                minp = regexEscape(this.weekdaysMin(mom, ''));
                shortp = regexEscape(this.weekdaysShort(mom, ''));
                longp = regexEscape(this.weekdays(mom, ''));
                minPieces.push(minp);
                shortPieces.push(shortp);
                longPieces.push(longp);
                mixedPieces.push(minp);
                mixedPieces.push(shortp);
                mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);

            this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._weekdaysShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
            this._weekdaysMinStrictRegex = new RegExp(
                '^(' + minPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        function hFormat() {
            return this.hours() % 12 || 12;
        }

        function kFormat() {
            return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);

        addFormatToken('hmm', 0, 0, function () {
            return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });

        addFormatToken('hmmss', 0, 0, function () {
            return (
                '' +
                hFormat.apply(this) +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        addFormatToken('Hmm', 0, 0, function () {
            return '' + this.hours() + zeroFill(this.minutes(), 2);
        });

        addFormatToken('Hmmss', 0, 0, function () {
            return (
                '' +
                this.hours() +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
                return this.localeData().meridiem(
                    this.hours(),
                    this.minutes(),
                    lowercase
                );
            });
        }

        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);

        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);

        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            getSetHour = makeGetSet('Hours', true);

        function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        }

        var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
        };

        // internal storage for locale config files
        var locales = {},
            localeFamilies = {},
            globalLocale;

        function commonPrefix(arr1, arr2) {
            var i,
                minl = Math.min(arr1.length, arr2.length);
            for (i = 0; i < minl; i += 1) {
                if (arr1[i] !== arr2[i]) {
                    return i;
                }
            }
            return minl;
        }

        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
            var i = 0,
                j,
                next,
                locale,
                split;

            while (i < names.length) {
                split = normalizeLocale(names[i]).split('-');
                j = split.length;
                next = normalizeLocale(names[i + 1]);
                next = next ? next.split('-') : null;
                while (j > 0) {
                    locale = loadLocale(split.slice(0, j).join('-'));
                    if (locale) {
                        return locale;
                    }
                    if (
                        next &&
                        next.length >= j &&
                        commonPrefix(split, next) >= j - 1
                    ) {
                        //the next array item is better than a shallower substring of this one
                        break;
                    }
                    j--;
                }
                i++;
            }
            return globalLocale;
        }

        function loadLocale(name) {
            var oldLocale = null,
                aliasedRequire;
            // TODO: Find a better way to register and load all the locales in Node
            if (
                locales[name] === undefined &&
                'object' !== 'undefined' &&
                module &&
                module.exports
            ) {
                try {
                    oldLocale = globalLocale._abbr;
                    aliasedRequire = commonjsRequire;
                    aliasedRequire('./locale/' + name);
                    getSetGlobalLocale(oldLocale);
                } catch (e) {
                    // mark as not found to avoid repeating expensive file require call causing high CPU
                    // when trying to find en-US, en_US, en-us for every format call
                    locales[name] = null; // null means not found
                }
            }
            return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
                if (isUndefined(values)) {
                    data = getLocale(key);
                } else {
                    data = defineLocale(key, values);
                }

                if (data) {
                    // moment.duration._locale = moment._locale = data;
                    globalLocale = data;
                } else {
                    if (typeof console !== 'undefined' && console.warn) {
                        //warn user if arguments are passed but the locale could not be set
                        console.warn(
                            'Locale ' + key + ' not found. Did you forget to load it?'
                        );
                    }
                }
            }

            return globalLocale._abbr;
        }

        function defineLocale(name, config) {
            if (config !== null) {
                var locale,
                    parentConfig = baseConfig;
                config.abbr = name;
                if (locales[name] != null) {
                    deprecateSimple(
                        'defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                            'an existing locale. moment.defineLocale(localeName, ' +
                            'config) should only be used for creating a new locale ' +
                            'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                    );
                    parentConfig = locales[name]._config;
                } else if (config.parentLocale != null) {
                    if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                    } else {
                        locale = loadLocale(config.parentLocale);
                        if (locale != null) {
                            parentConfig = locale._config;
                        } else {
                            if (!localeFamilies[config.parentLocale]) {
                                localeFamilies[config.parentLocale] = [];
                            }
                            localeFamilies[config.parentLocale].push({
                                name: name,
                                config: config,
                            });
                            return null;
                        }
                    }
                }
                locales[name] = new Locale(mergeConfigs(parentConfig, config));

                if (localeFamilies[name]) {
                    localeFamilies[name].forEach(function (x) {
                        defineLocale(x.name, x.config);
                    });
                }

                // backwards compat for now: also set the locale
                // make sure we set the locale AFTER all child locales have been
                // created, so we won't end up with the child locale set.
                getSetGlobalLocale(name);

                return locales[name];
            } else {
                // useful for testing
                delete locales[name];
                return null;
            }
        }

        function updateLocale(name, config) {
            if (config != null) {
                var locale,
                    tmpLocale,
                    parentConfig = baseConfig;

                if (locales[name] != null && locales[name].parentLocale != null) {
                    // Update existing child locale in-place to avoid memory-leaks
                    locales[name].set(mergeConfigs(locales[name]._config, config));
                } else {
                    // MERGE
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                        parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    if (tmpLocale == null) {
                        // updateLocale is called for creating a new locale
                        // Set abbr so it will have a name (getters return
                        // undefined otherwise).
                        config.abbr = name;
                    }
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;
                }

                // backwards compat for now: also set the locale
                getSetGlobalLocale(name);
            } else {
                // pass null for config to unupdate, useful for tests
                if (locales[name] != null) {
                    if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                        if (name === getSetGlobalLocale()) {
                            getSetGlobalLocale(name);
                        }
                    } else if (locales[name] != null) {
                        delete locales[name];
                    }
                }
            }
            return locales[name];
        }

        // returns locale data
        function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
                key = key._locale._abbr;
            }

            if (!key) {
                return globalLocale;
            }

            if (!isArray(key)) {
                //short-circuit everything else
                locale = loadLocale(key);
                if (locale) {
                    return locale;
                }
                key = [key];
            }

            return chooseLocale(key);
        }

        function listLocales() {
            return keys(locales);
        }

        function checkOverflow(m) {
            var overflow,
                a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
                overflow =
                    a[MONTH] < 0 || a[MONTH] > 11
                        ? MONTH
                        : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                        ? DATE
                        : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                        ? MINUTE
                        : a[SECOND] < 0 || a[SECOND] > 59
                        ? SECOND
                        : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                        ? MILLISECOND
                        : -1;

                if (
                    getParsingFlags(m)._overflowDayOfYear &&
                    (overflow < YEAR || overflow > DATE)
                ) {
                    overflow = DATE;
                }
                if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                    overflow = WEEK;
                }
                if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                    overflow = WEEKDAY;
                }

                getParsingFlags(m).overflow = overflow;
            }

            return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
                ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                ['YYYY-DDD', /\d{4}-\d{3}/],
                ['YYYY-MM', /\d{4}-\d\d/, false],
                ['YYYYYYMMDD', /[+-]\d{10}/],
                ['YYYYMMDD', /\d{8}/],
                ['GGGG[W]WWE', /\d{4}W\d{3}/],
                ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                ['YYYYDDD', /\d{7}/],
                ['YYYYMM', /\d{6}/, false],
                ['YYYY', /\d{4}/, false],
            ],
            // iso time formats and regexes
            isoTimes = [
                ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                ['HH:mm', /\d\d:\d\d/],
                ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                ['HHmmss', /\d\d\d\d\d\d/],
                ['HHmm', /\d\d\d\d/],
                ['HH', /\d\d/],
            ],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -4 * 60,
                EST: -5 * 60,
                CDT: -5 * 60,
                CST: -6 * 60,
                MDT: -6 * 60,
                MST: -7 * 60,
                PDT: -7 * 60,
                PST: -8 * 60,
            };

        // date from iso format
        function configFromISO(config) {
            var i,
                l,
                string = config._i,
                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                allowTime,
                dateFormat,
                timeFormat,
                tzFormat;

            if (match) {
                getParsingFlags(config).iso = true;

                for (i = 0, l = isoDates.length; i < l; i++) {
                    if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                    }
                }
                if (dateFormat == null) {
                    config._isValid = false;
                    return;
                }
                if (match[3]) {
                    for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                            // match[2] should be 'T' or space
                            timeFormat = (match[2] || ' ') + isoTimes[i][0];
                            break;
                        }
                    }
                    if (timeFormat == null) {
                        config._isValid = false;
                        return;
                    }
                }
                if (!allowTime && timeFormat != null) {
                    config._isValid = false;
                    return;
                }
                if (match[4]) {
                    if (tzRegex.exec(match[4])) {
                        tzFormat = 'Z';
                    } else {
                        config._isValid = false;
                        return;
                    }
                }
                config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                configFromStringAndFormat(config);
            } else {
                config._isValid = false;
            }
        }

        function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
        ) {
            var result = [
                untruncateYear(yearStr),
                defaultLocaleMonthsShort.indexOf(monthStr),
                parseInt(dayStr, 10),
                parseInt(hourStr, 10),
                parseInt(minuteStr, 10),
            ];

            if (secondStr) {
                result.push(parseInt(secondStr, 10));
            }

            return result;
        }

        function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
                return 2000 + year;
            } else if (year <= 999) {
                return 1900 + year;
            }
            return year;
        }

        function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
                .replace(/\([^)]*\)|[\n\t]/g, ' ')
                .replace(/(\s\s+)/g, ' ')
                .replace(/^\s\s*/, '')
                .replace(/\s\s*$/, '');
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
                // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                    weekdayActual = new Date(
                        parsedInput[0],
                        parsedInput[1],
                        parsedInput[2]
                    ).getDay();
                if (weekdayProvided !== weekdayActual) {
                    getParsingFlags(config).weekdayMismatch = true;
                    config._isValid = false;
                    return false;
                }
            }
            return true;
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
                return obsOffsets[obsOffset];
            } else if (militaryOffset) {
                // the only allowed military tz is Z
                return 0;
            } else {
                var hm = parseInt(numOffset, 10),
                    m = hm % 100,
                    h = (hm - m) / 100;
                return h * 60 + m;
            }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i)),
                parsedArray;
            if (match) {
                parsedArray = extractFromRFC2822Strings(
                    match[4],
                    match[3],
                    match[2],
                    match[5],
                    match[6],
                    match[7]
                );
                if (!checkWeekday(match[1], parsedArray, config)) {
                    return;
                }

                config._a = parsedArray;
                config._tzm = calculateOffset(match[8], match[9], match[10]);

                config._d = createUTCDate.apply(null, config._a);
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                getParsingFlags(config).rfc2822 = true;
            } else {
                config._isValid = false;
            }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            if (matched !== null) {
                config._d = new Date(+matched[1]);
                return;
            }

            configFromISO(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            if (config._strict) {
                config._isValid = false;
            } else {
                // Final attempt, use Input Fallback
                hooks.createFromInputFallback(config);
            }
        }

        hooks.createFromInputFallback = deprecate(
            'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
                'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
                'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
            function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            }
        );

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
            if (a != null) {
                return a;
            }
            if (b != null) {
                return b;
            }
            return c;
        }

        function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
                return [
                    nowValue.getUTCFullYear(),
                    nowValue.getUTCMonth(),
                    nowValue.getUTCDate(),
                ];
            }
            return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
            var i,
                date,
                input = [],
                currentDate,
                expectedWeekday,
                yearToUse;

            if (config._d) {
                return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                if (
                    config._dayOfYear > daysInYear(yearToUse) ||
                    config._dayOfYear === 0
                ) {
                    getParsingFlags(config)._overflowDayOfYear = true;
                }

                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                config._a[MONTH] = date.getUTCMonth();
                config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
                config._a[i] = input[i] =
                    config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
                config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0
            ) {
                config._nextDay = true;
                config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
                null,
                input
            );
            expectedWeekday = config._useUTC
                ? config._d.getUTCDay()
                : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
                config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
                config._w &&
                typeof config._w.d !== 'undefined' &&
                config._w.d !== expectedWeekday
            ) {
                getParsingFlags(config).weekdayMismatch = true;
            }
        }

        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                dow = 1;
                doy = 4;

                // TODO: We need to take the current isoWeekYear, but that depends on
                // how we interpret now (local, utc, fixed offset). So create
                // a now version of current config (take local/utc/offset flags, and
                // create now).
                weekYear = defaults(
                    w.GG,
                    config._a[YEAR],
                    weekOfYear(createLocal(), 1, 4).year
                );
                week = defaults(w.W, 1);
                weekday = defaults(w.E, 1);
                if (weekday < 1 || weekday > 7) {
                    weekdayOverflow = true;
                }
            } else {
                dow = config._locale._week.dow;
                doy = config._locale._week.doy;

                curWeek = weekOfYear(createLocal(), dow, doy);

                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                // Default to current week.
                week = defaults(w.w, curWeek.week);

                if (w.d != null) {
                    // weekday -- low day numbers are considered next week
                    weekday = w.d;
                    if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                    }
                } else if (w.e != null) {
                    // local weekday -- counting starts from beginning of week
                    weekday = w.e + dow;
                    if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                    }
                } else {
                    // default to beginning of week
                    weekday = dow;
                }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
                getParsingFlags(config)._overflowWeekday = true;
            } else {
                temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                config._a[YEAR] = temp.year;
                config._dayOfYear = temp.dayOfYear;
            }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
                configFromISO(config);
                return;
            }
            if (config._f === hooks.RFC_2822) {
                configFromRFC2822(config);
                return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = '' + config._i,
                i,
                parsedInput,
                tokens,
                token,
                skipped,
                stringLength = string.length,
                totalParsedInputLength = 0,
                era;

            tokens =
                expandFormat(config._f, config._locale).match(formattingTokens) || [];

            for (i = 0; i < tokens.length; i++) {
                token = tokens[i];
                parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                    [])[0];
                if (parsedInput) {
                    skipped = string.substr(0, string.indexOf(parsedInput));
                    if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                    }
                    string = string.slice(
                        string.indexOf(parsedInput) + parsedInput.length
                    );
                    totalParsedInputLength += parsedInput.length;
                }
                // don't parse if it's not a known token
                if (formatTokenFunctions[token]) {
                    if (parsedInput) {
                        getParsingFlags(config).empty = false;
                    } else {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                    addTimeToArrayFromToken(token, parsedInput, config);
                } else if (config._strict && !parsedInput) {
                    getParsingFlags(config).unusedTokens.push(token);
                }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
                stringLength - totalParsedInputLength;
            if (string.length > 0) {
                getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
                config._a[HOUR] <= 12 &&
                getParsingFlags(config).bigHour === true &&
                config._a[HOUR] > 0
            ) {
                getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
                config._locale,
                config._a[HOUR],
                config._meridiem
            );

            // handle era
            era = getParsingFlags(config).era;
            if (era !== null) {
                config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
            }

            configFromArray(config);
            checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
                // nothing to do
                return hour;
            }
            if (locale.meridiemHour != null) {
                return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
                // Fallback
                isPm = locale.isPM(meridiem);
                if (isPm && hour < 12) {
                    hour += 12;
                }
                if (!isPm && hour === 12) {
                    hour = 0;
                }
                return hour;
            } else {
                // this is not supposed to happen
                return hour;
            }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
            var tempConfig,
                bestMoment,
                scoreToBeat,
                i,
                currentScore,
                validFormatFound,
                bestFormatIsValid = false;

            if (config._f.length === 0) {
                getParsingFlags(config).invalidFormat = true;
                config._d = new Date(NaN);
                return;
            }

            for (i = 0; i < config._f.length; i++) {
                currentScore = 0;
                validFormatFound = false;
                tempConfig = copyConfig({}, config);
                if (config._useUTC != null) {
                    tempConfig._useUTC = config._useUTC;
                }
                tempConfig._f = config._f[i];
                configFromStringAndFormat(tempConfig);

                if (isValid(tempConfig)) {
                    validFormatFound = true;
                }

                // if there is any input that was not parsed add a penalty for that format
                currentScore += getParsingFlags(tempConfig).charsLeftOver;

                //or tokens
                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                getParsingFlags(tempConfig).score = currentScore;

                if (!bestFormatIsValid) {
                    if (
                        scoreToBeat == null ||
                        currentScore < scoreToBeat ||
                        validFormatFound
                    ) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                        if (validFormatFound) {
                            bestFormatIsValid = true;
                        }
                    }
                } else {
                    if (currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }
            }

            extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
            if (config._d) {
                return;
            }

            var i = normalizeObjectUnits(config._i),
                dayOrDate = i.day === undefined ? i.date : i.day;
            config._a = map(
                [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
                function (obj) {
                    return obj && parseInt(obj, 10);
                }
            );

            configFromArray(config);
        }

        function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
                // Adding is smart enough around DST
                res.add(1, 'd');
                res._nextDay = undefined;
            }

            return res;
        }

        function prepareConfig(config) {
            var input = config._i,
                format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === '')) {
                return createInvalid({ nullInput: true });
            }

            if (typeof input === 'string') {
                config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
                return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
                config._d = input;
            } else if (isArray(format)) {
                configFromStringAndArray(config);
            } else if (format) {
                configFromStringAndFormat(config);
            } else {
                configFromInput(config);
            }

            if (!isValid(config)) {
                config._d = null;
            }

            return config;
        }

        function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
                config._d = new Date(hooks.now());
            } else if (isDate(input)) {
                config._d = new Date(input.valueOf());
            } else if (typeof input === 'string') {
                configFromString(config);
            } else if (isArray(input)) {
                config._a = map(input.slice(0), function (obj) {
                    return parseInt(obj, 10);
                });
                configFromArray(config);
            } else if (isObject(input)) {
                configFromObject(config);
            } else if (isNumber(input)) {
                // from milliseconds
                config._d = new Date(input);
            } else {
                hooks.createFromInputFallback(config);
            }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (format === true || format === false) {
                strict = format;
                format = undefined;
            }

            if (locale === true || locale === false) {
                strict = locale;
                locale = undefined;
            }

            if (
                (isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)
            ) {
                input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate(
                'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other < this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            ),
            prototypeMax = deprecate(
                'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other > this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
                moments = moments[0];
            }
            if (!moments.length) {
                return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
                if (!moments[i].isValid() || moments[i][fn](res)) {
                    res = moments[i];
                }
            }
            return res;
        }

        // TODO: Use [].sort instead?
        function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isBefore', args);
        }

        function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isAfter', args);
        }

        var now = function () {
            return Date.now ? Date.now() : +new Date();
        };

        var ordering = [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
        ];

        function isDurationValid(m) {
            var key,
                unitHasDecimal = false,
                i;
            for (key in m) {
                if (
                    hasOwnProp(m, key) &&
                    !(
                        indexOf.call(ordering, key) !== -1 &&
                        (m[key] == null || !isNaN(m[key]))
                    )
                ) {
                    return false;
                }
            }

            for (i = 0; i < ordering.length; ++i) {
                if (m[ordering[i]]) {
                    if (unitHasDecimal) {
                        return false; // only allow non-integers for smallest unit
                    }
                    if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                    }
                }
            }

            return true;
        }

        function isValid$1() {
            return this._isValid;
        }

        function createInvalid$1() {
            return createDuration(NaN);
        }

        function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
                +milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
        }

        function isDuration(obj) {
            return obj instanceof Duration;
        }

        function absRound(number) {
            if (number < 0) {
                return Math.round(-1 * number) * -1;
            } else {
                return Math.round(number);
            }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
            for (i = 0; i < len; i++) {
                if (
                    (dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
                ) {
                    diffs++;
                }
            }
            return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
                var offset = this.utcOffset(),
                    sign = '+';
                if (offset < 0) {
                    offset = -offset;
                    sign = '-';
                }
                return (
                    sign +
                    zeroFill(~~(offset / 60), 2) +
                    separator +
                    zeroFill(~~offset % 60, 2)
                );
            });
        }

        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
            var matches = (string || '').match(matcher),
                chunk,
                parts,
                minutes;

            if (matches === null) {
                return null;
            }

            chunk = matches[matches.length - 1] || [];
            parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
            minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
                res = model.clone();
                diff =
                    (isMoment(input) || isDate(input)
                        ? input.valueOf()
                        : createLocal(input).valueOf()) - res.valueOf();
                // Use low-level api, because this fn is low-level api.
                res._d.setTime(res._d.valueOf() + diff);
                hooks.updateOffset(res, false);
                return res;
            } else {
                return createLocal(input).local();
            }
        }

        function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
                localAdjust;
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            if (input != null) {
                if (typeof input === 'string') {
                    input = offsetFromString(matchShortOffset, input);
                    if (input === null) {
                        return this;
                    }
                } else if (Math.abs(input) < 16 && !keepMinutes) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = getDateOffset(this);
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(
                            this,
                            createDuration(input - offset, 'm'),
                            1,
                            false
                        );
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : getDateOffset(this);
            }
        }

        function getSetZone(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== 'string') {
                    input = -input;
                }

                this.utcOffset(input, keepLocalTime);

                return this;
            } else {
                return -this.utcOffset();
            }
        }

        function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(getDateOffset(this), 'm');
                }
            }
            return this;
        }

        function setOffsetToParsedOffset() {
            if (this._tzm != null) {
                this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === 'string') {
                var tZone = offsetFromString(matchOffset, this._i);
                if (tZone != null) {
                    this.utcOffset(tZone);
                } else {
                    this.utcOffset(0, true);
                }
            }
            return this;
        }

        function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
                return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
            return (
                this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset()
            );
        }

        function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
                return this._isDSTShifted;
            }

            var c = {},
                other;

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
                other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                this._isDSTShifted =
                    this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
                this._isDSTShifted = false;
            }

            return this._isDSTShifted;
        }

        function isLocal() {
            return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
            var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                diffRes;

            if (isDuration(input)) {
                duration = {
                    ms: input._milliseconds,
                    d: input._days,
                    M: input._months,
                };
            } else if (isNumber(input) || !isNaN(+input)) {
                duration = {};
                if (key) {
                    duration[key] = +input;
                } else {
                    duration.milliseconds = +input;
                }
            } else if ((match = aspNetRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: 0,
                    d: toInt(match[DATE]) * sign,
                    h: toInt(match[HOUR]) * sign,
                    m: toInt(match[MINUTE]) * sign,
                    s: toInt(match[SECOND]) * sign,
                    ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
                };
            } else if ((match = isoRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: parseIso(match[2], sign),
                    M: parseIso(match[3], sign),
                    w: parseIso(match[4], sign),
                    d: parseIso(match[5], sign),
                    h: parseIso(match[6], sign),
                    m: parseIso(match[7], sign),
                    s: parseIso(match[8], sign),
                };
            } else if (duration == null) {
                // checks for null or undefined
                duration = {};
            } else if (
                typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)
            ) {
                diffRes = momentsDifference(
                    createLocal(duration.from),
                    createLocal(duration.to)
                );

                duration = {};
                duration.ms = diffRes.milliseconds;
                duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, '_locale')) {
                ret._locale = input._locale;
            }

            if (isDuration(input) && hasOwnProp(input, '_isValid')) {
                ret._isValid = input._isValid;
            }

            return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(',', '.'));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
                other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, 'M').isAfter(other)) {
                --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, 'M');

            return res;
        }

        function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
                return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
                res = positiveMomentsDifference(base, other);
            } else {
                res = positiveMomentsDifference(other, base);
                res.milliseconds = -res.milliseconds;
                res.months = -res.months;
            }

            return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
            return function (val, period) {
                var dur, tmp;
                //invert the arguments, but complain about it
                if (period !== null && !isNaN(+period)) {
                    deprecateSimple(
                        name,
                        'moment().' +
                            name +
                            '(period, number) is deprecated. Please use moment().' +
                            name +
                            '(number, period). ' +
                            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                    );
                    tmp = val;
                    val = period;
                    period = tmp;
                }

                dur = createDuration(val, period);
                addSubtract(this, dur, direction);
                return this;
            };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = absRound(duration._days),
                months = absRound(duration._months);

            if (!mom.isValid()) {
                // No op
                return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
                setMonth(mom, get(mom, 'Month') + months * isAdding);
            }
            if (days) {
                set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
            }
            if (milliseconds) {
                mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
                hooks.updateOffset(mom, days || months);
            }
        }

        var add = createAdder(1, 'add'),
            subtract = createAdder(-1, 'subtract');

        function isString(input) {
            return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
            return (
                isMoment(input) ||
                isDate(input) ||
                isString(input) ||
                isNumber(input) ||
                isNumberOrStringArray(input) ||
                isMomentInputObject(input) ||
                input === null ||
                input === undefined
            );
        }

        function isMomentInputObject(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'years',
                    'year',
                    'y',
                    'months',
                    'month',
                    'M',
                    'days',
                    'day',
                    'd',
                    'dates',
                    'date',
                    'D',
                    'hours',
                    'hour',
                    'h',
                    'minutes',
                    'minute',
                    'm',
                    'seconds',
                    'second',
                    's',
                    'milliseconds',
                    'millisecond',
                    'ms',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function isNumberOrStringArray(input) {
            var arrayTest = isArray(input),
                dataTypeTest = false;
            if (arrayTest) {
                dataTypeTest =
                    input.filter(function (item) {
                        return !isNumber(item) && isString(input);
                    }).length === 0;
            }
            return arrayTest && dataTypeTest;
        }

        function isCalendarSpec(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'sameDay',
                    'nextDay',
                    'lastDay',
                    'nextWeek',
                    'lastWeek',
                    'sameElse',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, 'days', true);
            return diff < -6
                ? 'sameElse'
                : diff < -1
                ? 'lastWeek'
                : diff < 0
                ? 'lastDay'
                : diff < 1
                ? 'sameDay'
                : diff < 2
                ? 'nextDay'
                : diff < 7
                ? 'nextWeek'
                : 'sameElse';
        }

        function calendar$1(time, formats) {
            // Support for single parameter, formats only overload to the calendar function
            if (arguments.length === 1) {
                if (!arguments[0]) {
                    time = undefined;
                    formats = undefined;
                } else if (isMomentInput(arguments[0])) {
                    time = arguments[0];
                    formats = undefined;
                } else if (isCalendarSpec(arguments[0])) {
                    formats = arguments[0];
                    time = undefined;
                }
            }
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
                sod = cloneWithOffset(now, this).startOf('day'),
                format = hooks.calendarFormat(this, sod) || 'sameElse',
                output =
                    formats &&
                    (isFunction(formats[format])
                        ? formats[format].call(this, now)
                        : formats[format]);

            return this.format(
                output || this.localeData().calendar(format, this, createLocal(now))
            );
        }

        function clone() {
            return new Moment(this);
        }

        function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() > localInput.valueOf();
            } else {
                return localInput.valueOf() < this.clone().startOf(units).valueOf();
            }
        }

        function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() < localInput.valueOf();
            } else {
                return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
        }

        function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
                localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                return false;
            }
            inclusivity = inclusivity || '()';
            return (
                (inclusivity[0] === '('
                    ? this.isAfter(localFrom, units)
                    : !this.isBefore(localFrom, units)) &&
                (inclusivity[1] === ')'
                    ? this.isBefore(localTo, units)
                    : !this.isAfter(localTo, units))
            );
        }

        function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
                inputMs;
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() === localInput.valueOf();
            } else {
                inputMs = localInput.valueOf();
                return (
                    this.clone().startOf(units).valueOf() <= inputMs &&
                    inputMs <= this.clone().endOf(units).valueOf()
                );
            }
        }

        function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
                return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
                return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
                case 'year':
                    output = monthDiff(this, that) / 12;
                    break;
                case 'month':
                    output = monthDiff(this, that);
                    break;
                case 'quarter':
                    output = monthDiff(this, that) / 3;
                    break;
                case 'second':
                    output = (this - that) / 1e3;
                    break; // 1000
                case 'minute':
                    output = (this - that) / 6e4;
                    break; // 1000 * 60
                case 'hour':
                    output = (this - that) / 36e5;
                    break; // 1000 * 60 * 60
                case 'day':
                    output = (this - that - zoneDelta) / 864e5;
                    break; // 1000 * 60 * 60 * 24, negate dst
                case 'week':
                    output = (this - that - zoneDelta) / 6048e5;
                    break; // 1000 * 60 * 60 * 24 * 7, negate dst
                default:
                    output = this - that;
            }

            return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
            if (a.date() < b.date()) {
                // end-of-month calculations work correct when the start month has more
                // days than the end month.
                return -monthDiff(b, a);
            }
            // difference in months
            var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                anchor2,
                adjust;

            if (b - anchor < 0) {
                anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor - anchor2);
            } else {
                anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString(keepOffset) {
            if (!this.isValid()) {
                return null;
            }
            var utc = keepOffset !== true,
                m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
                return formatMoment(
                    m,
                    utc
                        ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                        : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
                );
            }
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                if (utc) {
                    return this.toDate().toISOString();
                } else {
                    return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                        .toISOString()
                        .replace('Z', formatMoment(m, 'Z'));
                }
            }
            return formatMoment(
                m,
                utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
            if (!this.isValid()) {
                return 'moment.invalid(/* ' + this._i + ' */)';
            }
            var func = 'moment',
                zone = '',
                prefix,
                year,
                datetime,
                suffix;
            if (!this.isLocal()) {
                func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                zone = 'Z';
            }
            prefix = '[' + func + '("]';
            year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
            datetime = '-MM-DD[T]HH:mm:ss.SSS';
            suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
            if (!inputString) {
                inputString = this.isUtc()
                    ? hooks.defaultFormatUtc
                    : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ to: this, from: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ from: this, to: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = getLocale(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        }

        var lang = deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        );

        function localeData() {
            return this._locale;
        }

        var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
        }

        function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return new Date(y, m, d).valueOf();
            }
        }

        function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return Date.UTC(y, m, d);
            }
        }

        function startOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year(), 0, 1);
                    break;
                case 'quarter':
                    time = startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3),
                        1
                    );
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month(), 1);
                    break;
                case 'week':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday()
                    );
                    break;
                case 'isoWeek':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1)
                    );
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date());
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time -= mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    );
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_MINUTE);
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_SECOND);
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function endOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year() + 1, 0, 1) - 1;
                    break;
                case 'quarter':
                    time =
                        startOfDate(
                            this.year(),
                            this.month() - (this.month() % 3) + 3,
                            1
                        ) - 1;
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                    break;
                case 'week':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - this.weekday() + 7
                        ) - 1;
                    break;
                case 'isoWeek':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - (this.isoWeekday() - 1) + 7
                        ) - 1;
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time +=
                        MS_PER_HOUR -
                        mod$1(
                            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                            MS_PER_HOUR
                        ) -
                        1;
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
            return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
            return new Date(this.valueOf());
        }

        function toArray() {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hour(),
                m.minute(),
                m.second(),
                m.millisecond(),
            ];
        }

        function toObject() {
            var m = this;
            return {
                years: m.year(),
                months: m.month(),
                date: m.date(),
                hours: m.hours(),
                minutes: m.minutes(),
                seconds: m.seconds(),
                milliseconds: m.milliseconds(),
            };
        }

        function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
            return isValid(this);
        }

        function parsingFlags() {
            return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
            return getParsingFlags(this).overflow;
        }

        function creationData() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict,
            };
        }

        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');

        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);

        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
            input,
            array,
            config,
            token
        ) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        });

        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);

        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
            var match;
            if (config._locale._eraYearOrdinalRegex) {
                match = input.match(config._locale._eraYearOrdinalRegex);
            }

            if (config._locale.eraYearOrdinalParse) {
                array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
            } else {
                array[YEAR] = parseInt(input, 10);
            }
        });

        function localeEras(m, format) {
            var i,
                l,
                date,
                eras = this._eras || getLocale('en')._eras;
            for (i = 0, l = eras.length; i < l; ++i) {
                switch (typeof eras[i].since) {
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].since).startOf('day');
                        eras[i].since = date.valueOf();
                        break;
                }

                switch (typeof eras[i].until) {
                    case 'undefined':
                        eras[i].until = +Infinity;
                        break;
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].until).startOf('day').valueOf();
                        eras[i].until = date.valueOf();
                        break;
                }
            }
            return eras;
        }

        function localeErasParse(eraName, format, strict) {
            var i,
                l,
                eras = this.eras(),
                name,
                abbr,
                narrow;
            eraName = eraName.toUpperCase();

            for (i = 0, l = eras.length; i < l; ++i) {
                name = eras[i].name.toUpperCase();
                abbr = eras[i].abbr.toUpperCase();
                narrow = eras[i].narrow.toUpperCase();

                if (strict) {
                    switch (format) {
                        case 'N':
                        case 'NN':
                        case 'NNN':
                            if (abbr === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNN':
                            if (name === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNNN':
                            if (narrow === eraName) {
                                return eras[i];
                            }
                            break;
                    }
                } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                    return eras[i];
                }
            }
        }

        function localeErasConvertYear(era, year) {
            var dir = era.since <= era.until ? +1 : -1;
            if (year === undefined) {
                return hooks(era.since).year();
            } else {
                return hooks(era.since).year() + (year - era.offset) * dir;
            }
        }

        function getEraName() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].name;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].name;
                }
            }

            return '';
        }

        function getEraNarrow() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].narrow;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].narrow;
                }
            }

            return '';
        }

        function getEraAbbr() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].abbr;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].abbr;
                }
            }

            return '';
        }

        function getEraYear() {
            var i,
                l,
                dir,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                dir = eras[i].since <= eras[i].until ? +1 : -1;

                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (
                    (eras[i].since <= val && val <= eras[i].until) ||
                    (eras[i].until <= val && val <= eras[i].since)
                ) {
                    return (
                        (this.year() - hooks(eras[i].since).year()) * dir +
                        eras[i].offset
                    );
                }
            }

            return this.year();
        }

        function erasNameRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNameRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNameRegex : this._erasRegex;
        }

        function erasAbbrRegex(isStrict) {
            if (!hasOwnProp(this, '_erasAbbrRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }

        function erasNarrowRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNarrowRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }

        function matchEraAbbr(isStrict, locale) {
            return locale.erasAbbrRegex(isStrict);
        }

        function matchEraName(isStrict, locale) {
            return locale.erasNameRegex(isStrict);
        }

        function matchEraNarrow(isStrict, locale) {
            return locale.erasNarrowRegex(isStrict);
        }

        function matchEraYearOrdinal(isStrict, locale) {
            return locale._eraYearOrdinalRegex || matchUnsigned;
        }

        function computeErasParse() {
            var abbrPieces = [],
                namePieces = [],
                narrowPieces = [],
                mixedPieces = [],
                i,
                l,
                eras = this.eras();

            for (i = 0, l = eras.length; i < l; ++i) {
                namePieces.push(regexEscape(eras[i].name));
                abbrPieces.push(regexEscape(eras[i].abbr));
                narrowPieces.push(regexEscape(eras[i].narrow));

                mixedPieces.push(regexEscape(eras[i].name));
                mixedPieces.push(regexEscape(eras[i].abbr));
                mixedPieces.push(regexEscape(eras[i].narrow));
            }

            this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
            this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
            this._erasNarrowRegex = new RegExp(
                '^(' + narrowPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
            return this.weekYear() % 100;
        });

        addFormatToken(0, ['GG', 2], 0, function () {
            return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);

        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 2)] = toInt(input);
        });

        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
            week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy
            );
        }

        function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.isoWeek(),
                this.isoWeekday(),
                1,
                4
            );
        }

        function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
        }

        function getISOWeeksInISOWeekYear() {
            return weeksInYear(this.isoWeekYear(), 1, 4);
        }

        function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getWeeksInWeekYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
                return weekOfYear(this, dow, doy).year;
            } else {
                weeksTarget = weeksInYear(input, dow, doy);
                if (week > weeksTarget) {
                    week = weeksTarget;
                }
                return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
            return input == null
                ? Math.ceil((this.month() + 1) / 3)
                : this.month((input - 1) * 3 + (this.month() % 3));
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
                ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
                : locale._dayOfMonthOrdinalParseLenient;
        });

        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
            config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
            var dayOfYear =
                Math.round(
                    (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
                ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
            return ~~(this.millisecond() / 100);
        });

        addFormatToken(0, ['SS', 2], 0, function () {
            return ~~(this.millisecond() / 10);
        });

        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
            return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
            return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
            return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
            return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
            return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
            return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);

        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
            addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
            array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
            addParseToken(token, parseMs);
        }

        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
            return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;

        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
            proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
                return 'Moment<' + this.format() + '>';
            };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
            'dates accessor is deprecated. Use date instead.',
            getSetDayOfMonth
        );
        proto.months = deprecate(
            'months accessor is deprecated. Use month instead',
            getSetMonth
        );
        proto.years = deprecate(
            'years accessor is deprecated. Use year instead',
            getSetYear
        );
        proto.zone = deprecate(
            'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
            getSetZone
        );
        proto.isDSTShifted = deprecate(
            'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
            isDaylightSavingTimeShifted
        );

        function createUnix(input) {
            return createLocal(input * 1000);
        }

        function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
            return string;
        }

        var proto$1 = Locale.prototype;

        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;

        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;

        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;

        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;

        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
            var locale = getLocale(),
                utc = createUTC().set(setter, index);
            return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';

            if (index != null) {
                return get$1(format, index, field, 'month');
            }

            var i,
                out = [];
            for (i = 0; i < 12; i++) {
                out[i] = get$1(format, i, field, 'month');
            }
            return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === 'boolean') {
                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            } else {
                format = localeSorted;
                index = format;
                localeSorted = false;

                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            }

            var locale = getLocale(),
                shift = localeSorted ? locale._week.dow : 0,
                i,
                out = [];

            if (index != null) {
                return get$1(format, (index + shift) % 7, field, 'day');
            }

            for (i = 0; i < 7; i++) {
                out[i] = get$1(format, (i + shift) % 7, field, 'day');
            }
            return out;
        }

        function listMonths(format, index) {
            return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
            eras: [
                {
                    since: '0001-01-01',
                    until: +Infinity,
                    offset: 1,
                    name: 'Anno Domini',
                    narrow: 'AD',
                    abbr: 'AD',
                },
                {
                    since: '0000-12-31',
                    until: -Infinity,
                    offset: 1,
                    name: 'Before Christ',
                    narrow: 'BC',
                    abbr: 'BC',
                },
            ],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        toInt((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
        });

        // Side effect imports

        hooks.lang = deprecate(
            'moment.lang is deprecated. Use moment.locale instead.',
            getSetGlobalLocale
        );
        hooks.langData = deprecate(
            'moment.langData is deprecated. Use moment.localeData instead.',
            getLocale
        );

        var mathAbs = Math.abs;

        function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
        }

        function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
            if (number < 0) {
                return Math.floor(number);
            } else {
                return Math.ceil(number);
            }
        }

        function bubble() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds,
                minutes,
                hours,
                years,
                monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
                !(
                    (milliseconds >= 0 && days >= 0 && months >= 0) ||
                    (milliseconds <= 0 && days <= 0 && months <= 0)
                )
            ) {
                milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                days = 0;
                months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
        }

        function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
        }

        function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
        }

        function as(units) {
            if (!this.isValid()) {
                return NaN;
            }
            var days,
                months,
                milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === 'month' || units === 'quarter' || units === 'year') {
                days = this._days + milliseconds / 864e5;
                months = this._months + daysToMonths(days);
                switch (units) {
                    case 'month':
                        return months;
                    case 'quarter':
                        return months / 3;
                    case 'year':
                        return months / 12;
                }
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(monthsToDays(this._months));
                switch (units) {
                    case 'week':
                        return days / 7 + milliseconds / 6048e5;
                    case 'day':
                        return days + milliseconds / 864e5;
                    case 'hour':
                        return days * 24 + milliseconds / 36e5;
                    case 'minute':
                        return days * 1440 + milliseconds / 6e4;
                    case 'second':
                        return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond':
                        return Math.floor(days * 864e5) + milliseconds;
                    default:
                        throw new Error('Unknown unit ' + units);
                }
            }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
            if (!this.isValid()) {
                return NaN;
            }
            return (
                this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6
            );
        }

        function makeAs(alias) {
            return function () {
                return this.as(alias);
            };
        }

        var asMilliseconds = makeAs('ms'),
            asSeconds = makeAs('s'),
            asMinutes = makeAs('m'),
            asHours = makeAs('h'),
            asDays = makeAs('d'),
            asWeeks = makeAs('w'),
            asMonths = makeAs('M'),
            asQuarters = makeAs('Q'),
            asYears = makeAs('y');

        function clone$1() {
            return createDuration(this);
        }

        function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
            return function () {
                return this.isValid() ? this._data[name] : NaN;
            };
        }

        var milliseconds = makeGetter('milliseconds'),
            seconds = makeGetter('seconds'),
            minutes = makeGetter('minutes'),
            hours = makeGetter('hours'),
            days = makeGetter('days'),
            months = makeGetter('months'),
            years = makeGetter('years');

        function weeks() {
            return absFloor(this.days() / 7);
        }

        var round = Math.round,
            thresholds = {
                ss: 44, // a few seconds to seconds
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month/week
                w: null, // weeks to month
                M: 11, // months to year
            };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
            var duration = createDuration(posNegDuration).abs(),
                seconds = round(duration.as('s')),
                minutes = round(duration.as('m')),
                hours = round(duration.as('h')),
                days = round(duration.as('d')),
                months = round(duration.as('M')),
                weeks = round(duration.as('w')),
                years = round(duration.as('y')),
                a =
                    (seconds <= thresholds.ss && ['s', seconds]) ||
                    (seconds < thresholds.s && ['ss', seconds]) ||
                    (minutes <= 1 && ['m']) ||
                    (minutes < thresholds.m && ['mm', minutes]) ||
                    (hours <= 1 && ['h']) ||
                    (hours < thresholds.h && ['hh', hours]) ||
                    (days <= 1 && ['d']) ||
                    (days < thresholds.d && ['dd', days]);

            if (thresholds.w != null) {
                a =
                    a ||
                    (weeks <= 1 && ['w']) ||
                    (weeks < thresholds.w && ['ww', weeks]);
            }
            a = a ||
                (months <= 1 && ['M']) ||
                (months < thresholds.M && ['MM', months]) ||
                (years <= 1 && ['y']) || ['yy', years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
                return round;
            }
            if (typeof roundingFunction === 'function') {
                round = roundingFunction;
                return true;
            }
            return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
                return false;
            }
            if (limit === undefined) {
                return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === 's') {
                thresholds.ss = limit - 1;
            }
            return true;
        }

        function humanize(argWithSuffix, argThresholds) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var withSuffix = false,
                th = thresholds,
                locale,
                output;

            if (typeof argWithSuffix === 'object') {
                argThresholds = argWithSuffix;
                argWithSuffix = false;
            }
            if (typeof argWithSuffix === 'boolean') {
                withSuffix = argWithSuffix;
            }
            if (typeof argThresholds === 'object') {
                th = Object.assign({}, thresholds, argThresholds);
                if (argThresholds.s != null && argThresholds.ss == null) {
                    th.ss = argThresholds.s - 1;
                }
            }

            locale = this.localeData();
            output = relativeTime$1(this, !withSuffix, th, locale);

            if (withSuffix) {
                output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function sign(x) {
            return (x > 0) - (x < 0) || +x;
        }

        function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000,
                days = abs$1(this._days),
                months = abs$1(this._months),
                minutes,
                hours,
                years,
                s,
                total = this.asSeconds(),
                totalSign,
                ymSign,
                daysSign,
                hmsSign;

            if (!total) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

            totalSign = total < 0 ? '-' : '';
            ymSign = sign(this._months) !== sign(total) ? '-' : '';
            daysSign = sign(this._days) !== sign(total) ? '-' : '';
            hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

            return (
                totalSign +
                'P' +
                (years ? ymSign + years + 'Y' : '') +
                (months ? ymSign + months + 'M' : '') +
                (days ? daysSign + days + 'D' : '') +
                (hours || minutes || seconds ? 'T' : '') +
                (hours ? hmsSign + hours + 'H' : '') +
                (minutes ? hmsSign + minutes + 'M' : '') +
                (seconds ? hmsSign + s + 'S' : '')
            );
        }

        var proto$2 = Duration.prototype;

        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;

        proto$2.toIsoString = deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
            toISOString$1
        );
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
            config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
            config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.1';

        setHookCallback(createLocal);

        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
            DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
            DATE: 'YYYY-MM-DD', // <input type="date" />
            TIME: 'HH:mm', // <input type="time" />
            TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
            TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
            WEEK: 'GGGG-[W]WW', // <input type="week" />
            MONTH: 'YYYY-MM', // <input type="month" />
        };

        return hooks;

    })));
    });

    const THRESHOLD = 3 * 24 * 60 * 60 * 1000;

    function prettyDate(ts) {
      if (Date.now() - ts < THRESHOLD) {
        return moment(ts).fromNow();
      }
      return moment(ts).calendar().toLowerCase();
    }

    function toDateTime(ts) {
      return moment(ts).format();
    }

    function toFullDate(ts) {
      return moment(ts).format("LLLL");
    }

    /* src/components/forum/Posts.svelte generated by Svelte v3.31.0 */
    const file$7 = "src/components/forum/Posts.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (78:0) {:catch error}
    function create_catch_block(ctx) {
    	let t0;
    	let t1_value = /*error*/ ctx[5] + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("something bad happened\n    ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(78:0) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (60:26)      <ol>         {#each values as post}
    function create_then_block(ctx) {
    	let ol;
    	let each_value = /*values*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ol = element("ol");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ol, "class", "svelte-1nv8bcz");
    			add_location(ol, file$7, 60, 4, 1091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ol, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*posts, toFullDate, toDateTime, prettyDate*/ 1) {
    				each_value = /*values*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ol, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(60:26)      <ol>         {#each values as post}",
    		ctx
    	});

    	return block;
    }

    // (62:8) {#each values as post}
    function create_each_block$1(ctx) {
    	let li;
    	let p0;
    	let a;
    	let t0_value = /*post*/ ctx[2].title + "";
    	let t0;
    	let a_href_value;
    	let t1;
    	let p1;
    	let t2_value = /*post*/ ctx[2].name + "";
    	let t2;
    	let t3;
    	let p2;
    	let time;
    	let t4_value = prettyDate(/*post*/ ctx[2].lastTs * 1000) + "";
    	let t4;
    	let time_title_value;
    	let time_datetime_value;
    	let t5;

    	const block = {
    		c: function create() {
    			li = element("li");
    			p0 = element("p");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			p1 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p2 = element("p");
    			time = element("time");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(a, "href", a_href_value = "#/forum/posts/" + /*post*/ ctx[2].id);
    			attr_dev(a, "class", "svelte-1nv8bcz");
    			add_location(a, file$7, 64, 20, 1221);
    			attr_dev(p0, "class", "title svelte-1nv8bcz");
    			add_location(p0, file$7, 63, 16, 1183);
    			attr_dev(p1, "class", "name svelte-1nv8bcz");
    			add_location(p1, file$7, 66, 16, 1309);
    			attr_dev(time, "title", time_title_value = toFullDate(/*post*/ ctx[2].lastTs * 1000));
    			attr_dev(time, "datetime", time_datetime_value = toDateTime(/*post*/ ctx[2].lastTs * 1000));
    			add_location(time, file$7, 68, 20, 1398);
    			attr_dev(p2, "class", "activity svelte-1nv8bcz");
    			add_location(p2, file$7, 67, 16, 1357);
    			attr_dev(li, "class", "svelte-1nv8bcz");
    			toggle_class(li, "new", !/*post*/ ctx[2].seen);
    			add_location(li, file$7, 62, 12, 1139);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, p0);
    			append_dev(p0, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    			append_dev(li, p1);
    			append_dev(p1, t2);
    			append_dev(li, t3);
    			append_dev(li, p2);
    			append_dev(p2, time);
    			append_dev(time, t4);
    			append_dev(li, t5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*posts*/ 1) {
    				toggle_class(li, "new", !/*post*/ ctx[2].seen);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(62:8) {#each values as post}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>     import { getPosts }
    function create_pending_block(ctx) {
    	const block = { c: noop, m: noop, p: noop, d: noop };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(1:0) <script>     import { getPosts }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let await_block_anchor;
    	let promise;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 1,
    		error: 5
    	};

    	handle_promise(promise = /*posts*/ ctx[0], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			{
    				const child_ctx = ctx.slice();
    				child_ctx[1] = child_ctx[5] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Posts", slots, []);
    	let posts = getPosts(0, 1000, 0);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Posts> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		getPosts,
    		prettyDate,
    		toDateTime,
    		toFullDate,
    		posts
    	});

    	$$self.$inject_state = $$props => {
    		if ("posts" in $$props) $$invalidate(0, posts = $$props.posts);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [posts];
    }

    class Posts extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Posts",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src/routes/home/Home.svelte generated by Svelte v3.31.0 */
    const file$8 = "src/routes/home/Home.svelte";

    // (16:0) {:else}
    function create_else_block$2(ctx) {
    	let section0;
    	let pad;
    	let t0;
    	let section1;
    	let h1;
    	let t2;
    	let a;
    	let t4;
    	let posts;
    	let current;

    	pad = new Pad({
    			props: {
    				name: /*$space*/ ctx[0].name,
    				key: /*$space*/ ctx[0].etherpadKey
    			},
    			$$inline: true
    		});

    	posts = new Posts({ $$inline: true });

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			create_component(pad.$$.fragment);
    			t0 = space();
    			section1 = element("section");
    			h1 = element("h1");
    			h1.textContent = "Discussions";
    			t2 = space();
    			a = element("a");
    			a.textContent = "New Post";
    			t4 = space();
    			create_component(posts.$$.fragment);
    			add_location(section0, file$8, 16, 2, 318);
    			add_location(h1, file$8, 20, 4, 413);
    			attr_dev(a, "href", "#/forum/new");
    			attr_dev(a, "class", "button svelte-xth4nm");
    			add_location(a, file$8, 21, 4, 438);
    			add_location(section1, file$8, 19, 2, 399);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			mount_component(pad, section0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, h1);
    			append_dev(section1, t2);
    			append_dev(section1, a);
    			append_dev(section1, t4);
    			mount_component(posts, section1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pad_changes = {};
    			if (dirty & /*$space*/ 1) pad_changes.name = /*$space*/ ctx[0].name;
    			if (dirty & /*$space*/ 1) pad_changes.key = /*$space*/ ctx[0].etherpadKey;
    			pad.$set(pad_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pad.$$.fragment, local);
    			transition_in(posts.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pad.$$.fragment, local);
    			transition_out(posts.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			destroy_component(pad);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(section1);
    			destroy_component(posts);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(16:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:0) {#if $space === false}
    function create_if_block$5(ctx) {
    	let welcome;
    	let current;
    	welcome = new Welcome({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(welcome.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(welcome, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(welcome.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(welcome.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(welcome, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(14:0) {#if $space === false}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$space*/ ctx[0] === false) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $space;
    	validate_store(space$1, "space");
    	component_subscribe($$self, space$1, $$value => $$invalidate(0, $space = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Home", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ space: space$1, Welcome, Pad, Posts, $space });
    	return [$space];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/routes/forum/Index.svelte generated by Svelte v3.31.0 */
    const file$9 = "src/routes/forum/Index.svelte";

    function create_fragment$b(ctx) {
    	let section;
    	let h1;
    	let t1;
    	let a;
    	let t3;
    	let posts;
    	let current;
    	posts = new Posts({ $$inline: true });

    	const block = {
    		c: function create() {
    			section = element("section");
    			h1 = element("h1");
    			h1.textContent = "Forum";
    			t1 = space();
    			a = element("a");
    			a.textContent = "New Post";
    			t3 = space();
    			create_component(posts.$$.fragment);
    			add_location(h1, file$9, 12, 4, 196);
    			attr_dev(a, "href", "#/forum/new");
    			attr_dev(a, "class", "button svelte-1xq8vbi");
    			add_location(a, file$9, 13, 4, 215);
    			add_location(section, file$9, 11, 0, 182);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, h1);
    			append_dev(section, t1);
    			append_dev(section, a);
    			append_dev(section, t3);
    			mount_component(posts, section, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(posts.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(posts.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(posts);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Posts });
    	return [];
    }

    class Index$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */

    var purify = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    }(commonjsGlobal, function () {
      function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

      var hasOwnProperty = Object.hasOwnProperty,
          setPrototypeOf = Object.setPrototypeOf,
          isFrozen = Object.isFrozen;
      var freeze = Object.freeze,
          seal = Object.seal,
          create = Object.create; // eslint-disable-line import/no-mutable-exports

      var _ref = typeof Reflect !== 'undefined' && Reflect,
          apply = _ref.apply,
          construct = _ref.construct;

      if (!apply) {
        apply = function apply(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }

      if (!freeze) {
        freeze = function freeze(x) {
          return x;
        };
      }

      if (!seal) {
        seal = function seal(x) {
          return x;
        };
      }

      if (!construct) {
        construct = function construct(Func, args) {
          return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
        };
      }

      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);

      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);

      var regExpTest = unapply(RegExp.prototype.test);

      var typeErrorCreate = unconstruct(TypeError);

      function unapply(func) {
        return function (thisArg) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return apply(func, thisArg, args);
        };
      }

      function unconstruct(func) {
        return function () {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return construct(func, args);
        };
      }

      /* Add properties to a lookup table */
      function addToSet(set, array) {
        if (setPrototypeOf) {
          // Make 'in' and truthy checks like Boolean(set.constructor)
          // independent of any properties defined on Object.prototype.
          // Prevent prototype setters from intercepting set as a this value.
          setPrototypeOf(set, null);
        }

        var l = array.length;
        while (l--) {
          var element = array[l];
          if (typeof element === 'string') {
            var lcElement = stringToLowerCase(element);
            if (lcElement !== element) {
              // Config presets (e.g. tags.js, attrs.js) are immutable.
              if (!isFrozen(array)) {
                array[l] = lcElement;
              }

              element = lcElement;
            }
          }

          set[element] = true;
        }

        return set;
      }

      /* Shallow clone an object */
      function clone(object) {
        var newObject = create(null);

        var property = void 0;
        for (property in object) {
          if (apply(hasOwnProperty, object, [property])) {
            newObject[property] = object[property];
          }
        }

        return newObject;
      }

      var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

      // SVG
      var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);

      var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

      var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

      var text = freeze(['#text']);

      var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);

      var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

      var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

      var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

      // eslint-disable-next-line unicorn/better-regex
      var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
      var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
      var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
      var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
      );

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

      var getGlobal = function getGlobal() {
        return typeof window === 'undefined' ? null : window;
      };

      /**
       * Creates a no-op policy for internal use only.
       * Don't export this function outside this module!
       * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
       * @param {Document} document The document object (to determine policy name suffix)
       * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
       * are not supported).
       */
      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
        if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
          return null;
        }

        // Allow the callers to control the unique policy name
        // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
        // Policy creation with duplicate names throws in Trusted Types.
        var suffix = null;
        var ATTR_NAME = 'data-tt-policy-suffix';
        if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document.currentScript.getAttribute(ATTR_NAME);
        }

        var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html$$1) {
              return html$$1;
            }
          });
        } catch (_) {
          // Policy creation failed (most likely another DOMPurify script has
          // already run). Skip creating the policy, as this will only cause errors
          // if TT are enforced.
          console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
          return null;
        }
      };

      function createDOMPurify() {
        var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

        var DOMPurify = function DOMPurify(root) {
          return createDOMPurify(root);
        };

        /**
         * Version label, exposed for easier checks
         * if DOMPurify is up to date or not
         */
        DOMPurify.version = '2.2.4';

        /**
         * Array of elements that DOMPurify removed during sanitation.
         * Empty if nothing was removed.
         */
        DOMPurify.removed = [];

        if (!window || !window.document || window.document.nodeType !== 9) {
          // Not running in a browser, provide a factory function
          // so that you can pass your own Window
          DOMPurify.isSupported = false;

          return DOMPurify;
        }

        var originalDocument = window.document;

        var document = window.document;
        var DocumentFragment = window.DocumentFragment,
            HTMLTemplateElement = window.HTMLTemplateElement,
            Node = window.Node,
            NodeFilter = window.NodeFilter,
            _window$NamedNodeMap = window.NamedNodeMap,
            NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
            Text = window.Text,
            Comment = window.Comment,
            DOMParser = window.DOMParser,
            trustedTypes = window.trustedTypes;

        // As per issue #47, the web-components registry is inherited by a
        // new document created via createHTMLDocument. As per the spec
        // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
        // a new empty registry is used when creating a template contents owner
        // document, so we use that as our parent document to ensure nothing
        // is inherited.

        if (typeof HTMLTemplateElement === 'function') {
          var template = document.createElement('template');
          if (template.content && template.content.ownerDocument) {
            document = template.content.ownerDocument;
          }
        }

        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
        var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

        var _document = document,
            implementation = _document.implementation,
            createNodeIterator = _document.createNodeIterator,
            getElementsByTagName = _document.getElementsByTagName,
            createDocumentFragment = _document.createDocumentFragment;
        var importNode = originalDocument.importNode;


        var documentMode = {};
        try {
          documentMode = clone(document).documentMode ? document.documentMode : {};
        } catch (_) {}

        var hooks = {};

        /**
         * Expose whether this browser supports running the full DOMPurify.
         */
        DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

        var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
            ERB_EXPR$$1 = ERB_EXPR,
            DATA_ATTR$$1 = DATA_ATTR,
            ARIA_ATTR$$1 = ARIA_ATTR,
            IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
            ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
        var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

        /**
         * We consider the elements and attributes below to be safe. Ideally
         * don't add any new ones but feel free to remove unwanted ones.
         */

        /* allowed element names */

        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

        /* Allowed attribute names */
        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

        /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
        var FORBID_TAGS = null;

        /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
        var FORBID_ATTR = null;

        /* Decide if ARIA attributes are okay */
        var ALLOW_ARIA_ATTR = true;

        /* Decide if custom data attributes are okay */
        var ALLOW_DATA_ATTR = true;

        /* Decide if unknown protocols are okay */
        var ALLOW_UNKNOWN_PROTOCOLS = false;

        /* Output should be safe for common template engines.
         * This means, DOMPurify removes data attributes, mustaches and ERB
         */
        var SAFE_FOR_TEMPLATES = false;

        /* Decide if document with <html>... should be returned */
        var WHOLE_DOCUMENT = false;

        /* Track whether config is already set on this instance of DOMPurify. */
        var SET_CONFIG = false;

        /* Decide if all elements (e.g. style, script) must be children of
         * document.body. By default, browsers might move them to document.head */
        var FORCE_BODY = false;

        /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
         * string (or a TrustedHTML object if Trusted Types are supported).
         * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
         */
        var RETURN_DOM = false;

        /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
         * string  (or a TrustedHTML object if Trusted Types are supported) */
        var RETURN_DOM_FRAGMENT = false;

        /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
         * `Node` is imported into the current `Document`. If this flag is not enabled the
         * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
         * DOMPurify.
         *
         * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
         * might cause XSS from attacks hidden in closed shadowroots in case the browser
         * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
         */
        var RETURN_DOM_IMPORT = true;

        /* Try to return a Trusted Type object instead of a string, return a string in
         * case Trusted Types are not supported  */
        var RETURN_TRUSTED_TYPE = false;

        /* Output should be free from DOM clobbering attacks? */
        var SANITIZE_DOM = true;

        /* Keep element content when removing element? */
        var KEEP_CONTENT = true;

        /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
         * of importing it into a new Document and returning a sanitized copy */
        var IN_PLACE = false;

        /* Allow usage of profiles like html, svg and mathMl */
        var USE_PROFILES = {};

        /* Tags to ignore content of when KEEP_CONTENT is true */
        var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

        /* Tags that are safe for data: URIs */
        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

        /* Attributes safe for values like "javascript:" */
        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

        /* Keep a reference to config to pass to hooks */
        var CONFIG = null;

        /* Ideally, do not touch anything below this line */
        /* ______________________________________________ */

        var formElement = document.createElement('form');

        /**
         * _parseConfig
         *
         * @param  {Object} cfg optional config literal
         */
        // eslint-disable-next-line complexity
        var _parseConfig = function _parseConfig(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }

          /* Shield configuration object from tampering */
          if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
            cfg = {};
          }

          /* Shield configuration object from prototype pollution */
          cfg = clone(cfg);

          /* Set configuration parameters */
          ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
          URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
          FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
          FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
          USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
          RETURN_DOM = cfg.RETURN_DOM || false; // Default false
          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
          RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
          FORCE_BODY = cfg.FORCE_BODY || false; // Default false
          SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
          KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
          IN_PLACE = cfg.IN_PLACE || false; // Default false
          IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }

          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }

          /* Parse profile info */
          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html);
              addToSet(ALLOWED_ATTR, html$1);
            }

            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg);
              addToSet(ALLOWED_ATTR, svg$1);
              addToSet(ALLOWED_ATTR, xml);
            }

            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg$1);
              addToSet(ALLOWED_ATTR, xml);
            }

            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl);
              addToSet(ALLOWED_ATTR, mathMl$1);
              addToSet(ALLOWED_ATTR, xml);
            }
          }

          /* Merge configuration parameters */
          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }

            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
          }

          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }

            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
          }

          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
          }

          /* Add #text in case KEEP_CONTENT is set to true */
          if (KEEP_CONTENT) {
            ALLOWED_TAGS['#text'] = true;
          }

          /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
          }

          /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ['tbody']);
            delete FORBID_TAGS.tbody;
          }

          // Prevent further manipulation of configuration.
          // Not available in IE8, Safari 5, etc.
          if (freeze) {
            freeze(cfg);
          }

          CONFIG = cfg;
        };

        /**
         * _forceRemove
         *
         * @param  {Node} node a DOM node
         */
        var _forceRemove = function _forceRemove(node) {
          arrayPush(DOMPurify.removed, { element: node });
          try {
            node.parentNode.removeChild(node);
          } catch (_) {
            try {
              node.outerHTML = emptyHTML;
            } catch (_) {
              node.remove();
            }
          }
        };

        /**
         * _removeAttribute
         *
         * @param  {String} name an Attribute name
         * @param  {Node} node a DOM node
         */
        var _removeAttribute = function _removeAttribute(name, node) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node.getAttributeNode(name),
              from: node
            });
          } catch (_) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node
            });
          }

          node.removeAttribute(name);
        };

        /**
         * _initDocument
         *
         * @param  {String} dirty a string of dirty markup
         * @return {Document} a DOM, filled with the dirty markup
         */
        var _initDocument = function _initDocument(dirty) {
          /* Create a HTML document */
          var doc = void 0;
          var leadingWhitespace = void 0;

          if (FORCE_BODY) {
            dirty = '<remove></remove>' + dirty;
          } else {
            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
            var matches = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches && matches[0];
          }

          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          /* Use the DOMParser API by default, fallback later if needs be */
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
          } catch (_) {}

          /* Use createHTMLDocument in case DOMParser is not available */
          if (!doc || !doc.documentElement) {
            doc = implementation.createHTMLDocument('');
            var _doc = doc,
                body = _doc.body;

            body.parentNode.removeChild(body.parentNode.firstElementChild);
            body.outerHTML = dirtyPayload;
          }

          if (dirty && leadingWhitespace) {
            doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
          }

          /* Work on whole document or just its body */
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        };

        /**
         * _createIterator
         *
         * @param  {Document} root document/fragment to create iterator for
         * @return {Iterator} iterator instance
         */
        var _createIterator = function _createIterator(root) {
          return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
            return NodeFilter.FILTER_ACCEPT;
          }, false);
        };

        /**
         * _isClobbered
         *
         * @param  {Node} elm element to check for clobbering attacks
         * @return {Boolean} true if clobbered, false if safe
         */
        var _isClobbered = function _isClobbered(elm) {
          if (elm instanceof Text || elm instanceof Comment) {
            return false;
          }

          if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string') {
            return true;
          }

          return false;
        };

        /**
         * _isNode
         *
         * @param  {Node} obj object to check whether it's a DOM node
         * @return {Boolean} true is object is a DOM node
         */
        var _isNode = function _isNode(object) {
          return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
        };

        /**
         * _executeHook
         * Execute user configurable hooks
         *
         * @param  {String} entryPoint  Name of the hook's entry point
         * @param  {Node} currentNode node to work on with the hook
         * @param  {Object} data additional hook parameters
         */
        var _executeHook = function _executeHook(entryPoint, currentNode, data) {
          if (!hooks[entryPoint]) {
            return;
          }

          arrayForEach(hooks[entryPoint], function (hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        };

        /**
         * _sanitizeElements
         *
         * @protect nodeName
         * @protect textContent
         * @protect removeChild
         *
         * @param   {Node} currentNode to check for permission to exist
         * @return  {Boolean} true if node was killed, false if left alive
         */
        var _sanitizeElements = function _sanitizeElements(currentNode) {
          var content = void 0;

          /* Execute a hook if present */
          _executeHook('beforeSanitizeElements', currentNode, null);

          /* Check if element is clobbered or can clobber */
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }

          /* Check if tagname contains Unicode */
          if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
            _forceRemove(currentNode);
            return true;
          }

          /* Now let's check the element's type and name */
          var tagName = stringToLowerCase(currentNode.nodeName);

          /* Execute a hook if present */
          _executeHook('uponSanitizeElement', currentNode, {
            tagName: tagName,
            allowedTags: ALLOWED_TAGS
          });

          /* Detect mXSS attempts abusing namespace confusion */
          if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
          }

          /* Remove element if anything forbids its presence */
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            /* Keep content except for bad-listed elements */
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
              try {
                var htmlToInsert = currentNode.innerHTML;
                currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);
              } catch (_) {}
            }

            _forceRemove(currentNode);
            return true;
          }

          if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }

          if (tagName === 'math' && _isNode(currentNode.firstElementChild) && currentNode.querySelectorAll(':not(' + mathMl.join('):not(') + ')').length > 0) {
            _forceRemove(currentNode);
            return true;
          }

          /* Take care of an mXSS using HTML inside SVG affecting old Chrome */
          if (tagName === 'svg' && currentNode.querySelectorAll('p, br, table, form, noscript').length > 0) {
            _forceRemove(currentNode);
            return true;
          }

          /* Sanitize element content to be template-safe */
          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            /* Get the element's text content */
            content = currentNode.textContent;
            content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
            content = stringReplace(content, ERB_EXPR$$1, ' ');
            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
              currentNode.textContent = content;
            }
          }

          /* Execute a hook if present */
          _executeHook('afterSanitizeElements', currentNode, null);

          return false;
        };

        /**
         * _isValidAttribute
         *
         * @param  {string} lcTag Lowercase tag name of containing element.
         * @param  {string} lcName Lowercase attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid, otherwise false.
         */
        // eslint-disable-next-line complexity
        var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
          /* Make sure attribute cannot clobber */
          if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
            return false;
          }

          /* Allow valid data-* attributes: At least one character after "-"
              (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
              XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
              We don't need to check the value; it's always URI safe. */
          if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            return false;

            /* Check value is safe. First, is attr inert? If so, is safe */
          } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
            return false;
          }

          return true;
        };

        /**
         * _sanitizeAttributes
         *
         * @protect attributes
         * @protect nodeName
         * @protect removeAttribute
         * @protect setAttribute
         *
         * @param  {Node} currentNode to sanitize
         */
        var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
          var attr = void 0;
          var value = void 0;
          var lcName = void 0;
          var l = void 0;
          /* Execute a hook if present */
          _executeHook('beforeSanitizeAttributes', currentNode, null);

          var attributes = currentNode.attributes;

          /* Check if we have attributes; if not we might have a text node */

          if (!attributes) {
            return;
          }

          var hookEvent = {
            attrName: '',
            attrValue: '',
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l = attributes.length;

          /* Go backwards over all attributes; safely remove bad ones */
          while (l--) {
            attr = attributes[l];
            var _attr = attr,
                name = _attr.name,
                namespaceURI = _attr.namespaceURI;

            value = stringTrim(attr.value);
            lcName = stringToLowerCase(name);

            /* Execute a hook if present */
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
            _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
            value = hookEvent.attrValue;
            /* Did the hooks approve of the attribute? */
            if (hookEvent.forceKeepAttr) {
              continue;
            }

            /* Remove attribute */
            _removeAttribute(name, currentNode);

            /* Did the hooks approve of the attribute? */
            if (!hookEvent.keepAttr) {
              continue;
            }

            /* Work around a security issue in jQuery 3.0 */
            if (regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }

            /* Sanitize attribute content to be template-safe */
            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
              value = stringReplace(value, ERB_EXPR$$1, ' ');
            }

            /* Is `value` valid for this attribute? */
            var lcTag = currentNode.nodeName.toLowerCase();
            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }

            /* Handle invalid data-* attribute set by try-catching it */
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                currentNode.setAttribute(name, value);
              }

              arrayPop(DOMPurify.removed);
            } catch (_) {}
          }

          /* Execute a hook if present */
          _executeHook('afterSanitizeAttributes', currentNode, null);
        };

        /**
         * _sanitizeShadowDOM
         *
         * @param  {DocumentFragment} fragment to iterate over recursively
         */
        var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
          var shadowNode = void 0;
          var shadowIterator = _createIterator(fragment);

          /* Execute a hook if present */
          _executeHook('beforeSanitizeShadowDOM', fragment, null);

          while (shadowNode = shadowIterator.nextNode()) {
            /* Execute a hook if present */
            _executeHook('uponSanitizeShadowNode', shadowNode, null);

            /* Sanitize tags and elements */
            if (_sanitizeElements(shadowNode)) {
              continue;
            }

            /* Deep shadow DOM detected */
            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(shadowNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(shadowNode);
          }

          /* Execute a hook if present */
          _executeHook('afterSanitizeShadowDOM', fragment, null);
        };

        /**
         * Sanitize
         * Public method providing core sanitation functionality
         *
         * @param {String|Node} dirty string or DOM node
         * @param {Object} configuration object
         */
        // eslint-disable-next-line complexity
        DOMPurify.sanitize = function (dirty, cfg) {
          var body = void 0;
          var importedNode = void 0;
          var currentNode = void 0;
          var oldNode = void 0;
          var returnNode = void 0;
          /* Make sure we have a string to sanitize.
            DO NOT return early, as this will return the wrong type if
            the user has requested a DOM object rather than a string */
          if (!dirty) {
            dirty = '<!-->';
          }

          /* Stringify, in case dirty is an object */
          if (typeof dirty !== 'string' && !_isNode(dirty)) {
            // eslint-disable-next-line no-negated-condition
            if (typeof dirty.toString !== 'function') {
              throw typeErrorCreate('toString is not a function');
            } else {
              dirty = dirty.toString();
              if (typeof dirty !== 'string') {
                throw typeErrorCreate('dirty is not a string, aborting');
              }
            }
          }

          /* Check we can run. Otherwise fall back or ignore */
          if (!DOMPurify.isSupported) {
            if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
              if (typeof dirty === 'string') {
                return window.toStaticHTML(dirty);
              }

              if (_isNode(dirty)) {
                return window.toStaticHTML(dirty.outerHTML);
              }
            }

            return dirty;
          }

          /* Assign config vars */
          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }

          /* Clean up removed elements */
          DOMPurify.removed = [];

          /* Check if dirty is correctly typed for IN_PLACE */
          if (typeof dirty === 'string') {
            IN_PLACE = false;
          }

          if (IN_PLACE) ; else if (dirty instanceof Node) {
            /* If dirty is a DOM element, append to an empty document to avoid
               elements being stripped by the parser */
            body = _initDocument('<!---->');
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
              /* Node is already a body, use as is */
              body = importedNode;
            } else if (importedNode.nodeName === 'HTML') {
              body = importedNode;
            } else {
              // eslint-disable-next-line unicorn/prefer-node-append
              body.appendChild(importedNode);
            }
          } else {
            /* Exit directly if we have nothing to do */
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
            // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf('<') === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }

            /* Initialize the document to work on */
            body = _initDocument(dirty);

            /* Check we have a DOM node from the data */
            if (!body) {
              return RETURN_DOM ? null : emptyHTML;
            }
          }

          /* Remove first element node (ours) if FORCE_BODY is set */
          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }

          /* Get node iterator */
          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

          /* Now start iterating over the created document */
          while (currentNode = nodeIterator.nextNode()) {
            /* Fix IE's strange behavior with manipulated textNodes #89 */
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }

            /* Sanitize tags and elements */
            if (_sanitizeElements(currentNode)) {
              continue;
            }

            /* Shadow DOM detected, sanitize it */
            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(currentNode);

            oldNode = currentNode;
          }

          oldNode = null;

          /* If we sanitized `dirty` in-place, return it. */
          if (IN_PLACE) {
            return dirty;
          }

          /* Return sanitized string or DOM */
          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);

              while (body.firstChild) {
                // eslint-disable-next-line unicorn/prefer-node-append
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }

            if (RETURN_DOM_IMPORT) {
              /*
                AdoptNode() is not used because internal state is not reset
                (e.g. the past names map of a HTMLFormElement), this is safe
                in theory but we would rather not risk another attack vector.
                The state that is cloned by importNode() is explicitly defined
                by the specs.
              */
              returnNode = importNode.call(originalDocument, returnNode, true);
            }

            return returnNode;
          }

          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

          /* Sanitize final string template-safe */
          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
          }

          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };

        /**
         * Public method to set the configuration once
         * setConfig
         *
         * @param {Object} cfg configuration object
         */
        DOMPurify.setConfig = function (cfg) {
          _parseConfig(cfg);
          SET_CONFIG = true;
        };

        /**
         * Public method to remove the configuration
         * clearConfig
         *
         */
        DOMPurify.clearConfig = function () {
          CONFIG = null;
          SET_CONFIG = false;
        };

        /**
         * Public method to check if an attribute value is valid.
         * Uses last set config, if any. Otherwise, uses config defaults.
         * isValidAttribute
         *
         * @param  {string} tag Tag name of containing element.
         * @param  {string} attr Attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
         */
        DOMPurify.isValidAttribute = function (tag, attr, value) {
          /* Initialize shared config vars if necessary. */
          if (!CONFIG) {
            _parseConfig({});
          }

          var lcTag = stringToLowerCase(tag);
          var lcName = stringToLowerCase(attr);
          return _isValidAttribute(lcTag, lcName, value);
        };

        /**
         * AddHook
         * Public method to add DOMPurify hooks
         *
         * @param {String} entryPoint entry point for the hook to add
         * @param {Function} hookFunction function to execute
         */
        DOMPurify.addHook = function (entryPoint, hookFunction) {
          if (typeof hookFunction !== 'function') {
            return;
          }

          hooks[entryPoint] = hooks[entryPoint] || [];
          arrayPush(hooks[entryPoint], hookFunction);
        };

        /**
         * RemoveHook
         * Public method to remove a DOMPurify hook at a given entryPoint
         * (pops it from the stack of hooks if more are present)
         *
         * @param {String} entryPoint entry point for the hook to remove
         */
        DOMPurify.removeHook = function (entryPoint) {
          if (hooks[entryPoint]) {
            arrayPop(hooks[entryPoint]);
          }
        };

        /**
         * RemoveHooks
         * Public method to remove all DOMPurify hooks at a given entryPoint
         *
         * @param  {String} entryPoint entry point for the hooks to remove
         */
        DOMPurify.removeHooks = function (entryPoint) {
          if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
          }
        };

        /**
         * RemoveAllHooks
         * Public method to remove all DOMPurify hooks
         *
         */
        DOMPurify.removeAllHooks = function () {
          hooks = {};
        };

        return DOMPurify;
      }

      var purify = createDOMPurify();

      return purify;

    }));

    });

    /**
     * marked - a markdown parser
     * Copyright (c) 2011-2020, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/markedjs/marked
     */

    var marked = createCommonjsModule(function (module, exports) {
    /**
     * DO NOT EDIT THIS FILE
     * The code in this file is generated from files in ./src/
     */

    (function (global, factory) {
       module.exports = factory() ;
    }(commonjsGlobal, (function () {
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it;

        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            return function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        it = o[Symbol.iterator]();
        return it.next.bind(it);
      }

      function createCommonjsModule(fn, module) {
      	return module = { exports: {} }, fn(module, module.exports), module.exports;
      }

      var defaults = createCommonjsModule(function (module) {
        function getDefaults() {
          return {
            baseUrl: null,
            breaks: false,
            gfm: true,
            headerIds: true,
            headerPrefix: '',
            highlight: null,
            langPrefix: 'language-',
            mangle: true,
            pedantic: false,
            renderer: null,
            sanitize: false,
            sanitizer: null,
            silent: false,
            smartLists: false,
            smartypants: false,
            tokenizer: null,
            walkTokens: null,
            xhtml: false
          };
        }

        function changeDefaults(newDefaults) {
          module.exports.defaults = newDefaults;
        }

        module.exports = {
          defaults: getDefaults(),
          getDefaults: getDefaults,
          changeDefaults: changeDefaults
        };
      });
      var defaults_1 = defaults.defaults;
      var defaults_2 = defaults.getDefaults;
      var defaults_3 = defaults.changeDefaults;

      /**
       * Helpers
       */
      var escapeTest = /[&<>"']/;
      var escapeReplace = /[&<>"']/g;
      var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
      var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
      var escapeReplacements = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };

      var getEscapeReplacement = function getEscapeReplacement(ch) {
        return escapeReplacements[ch];
      };

      function escape(html, encode) {
        if (encode) {
          if (escapeTest.test(html)) {
            return html.replace(escapeReplace, getEscapeReplacement);
          }
        } else {
          if (escapeTestNoEncode.test(html)) {
            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
          }
        }

        return html;
      }

      var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

      function unescape(html) {
        // explicitly match decimal, hex, and named HTML entities
        return html.replace(unescapeTest, function (_, n) {
          n = n.toLowerCase();
          if (n === 'colon') return ':';

          if (n.charAt(0) === '#') {
            return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
          }

          return '';
        });
      }

      var caret = /(^|[^\[])\^/g;

      function edit(regex, opt) {
        regex = regex.source || regex;
        opt = opt || '';
        var obj = {
          replace: function replace(name, val) {
            val = val.source || val;
            val = val.replace(caret, '$1');
            regex = regex.replace(name, val);
            return obj;
          },
          getRegex: function getRegex() {
            return new RegExp(regex, opt);
          }
        };
        return obj;
      }

      var nonWordAndColonTest = /[^\w:]/g;
      var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

      function cleanUrl(sanitize, base, href) {
        if (sanitize) {
          var prot;

          try {
            prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
          } catch (e) {
            return null;
          }

          if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
            return null;
          }
        }

        if (base && !originIndependentUrl.test(href)) {
          href = resolveUrl(base, href);
        }

        try {
          href = encodeURI(href).replace(/%25/g, '%');
        } catch (e) {
          return null;
        }

        return href;
      }

      var baseUrls = {};
      var justDomain = /^[^:]+:\/*[^/]*$/;
      var protocol = /^([^:]+:)[\s\S]*$/;
      var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

      function resolveUrl(base, href) {
        if (!baseUrls[' ' + base]) {
          // we can ignore everything in base after the last slash of its path component,
          // but we might need to add _that_
          // https://tools.ietf.org/html/rfc3986#section-3
          if (justDomain.test(base)) {
            baseUrls[' ' + base] = base + '/';
          } else {
            baseUrls[' ' + base] = rtrim(base, '/', true);
          }
        }

        base = baseUrls[' ' + base];
        var relativeBase = base.indexOf(':') === -1;

        if (href.substring(0, 2) === '//') {
          if (relativeBase) {
            return href;
          }

          return base.replace(protocol, '$1') + href;
        } else if (href.charAt(0) === '/') {
          if (relativeBase) {
            return href;
          }

          return base.replace(domain, '$1') + href;
        } else {
          return base + href;
        }
      }

      var noopTest = {
        exec: function noopTest() {}
      };

      function merge(obj) {
        var i = 1,
            target,
            key;

        for (; i < arguments.length; i++) {
          target = arguments[i];

          for (key in target) {
            if (Object.prototype.hasOwnProperty.call(target, key)) {
              obj[key] = target[key];
            }
          }
        }

        return obj;
      }

      function splitCells(tableRow, count) {
        // ensure that every cell-delimiting pipe has a space
        // before it to distinguish it from an escaped pipe
        var row = tableRow.replace(/\|/g, function (match, offset, str) {
          var escaped = false,
              curr = offset;

          while (--curr >= 0 && str[curr] === '\\') {
            escaped = !escaped;
          }

          if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
          } else {
            // add space before unescaped |
            return ' |';
          }
        }),
            cells = row.split(/ \|/);
        var i = 0;

        if (cells.length > count) {
          cells.splice(count);
        } else {
          while (cells.length < count) {
            cells.push('');
          }
        }

        for (; i < cells.length; i++) {
          // leading or trailing whitespace is ignored per the gfm spec
          cells[i] = cells[i].trim().replace(/\\\|/g, '|');
        }

        return cells;
      } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
      // /c*$/ is vulnerable to REDOS.
      // invert: Remove suffix of non-c chars instead. Default falsey.


      function rtrim(str, c, invert) {
        var l = str.length;

        if (l === 0) {
          return '';
        } // Length of suffix matching the invert condition.


        var suffLen = 0; // Step left until we fail to match the invert condition.

        while (suffLen < l) {
          var currChar = str.charAt(l - suffLen - 1);

          if (currChar === c && !invert) {
            suffLen++;
          } else if (currChar !== c && invert) {
            suffLen++;
          } else {
            break;
          }
        }

        return str.substr(0, l - suffLen);
      }

      function findClosingBracket(str, b) {
        if (str.indexOf(b[1]) === -1) {
          return -1;
        }

        var l = str.length;
        var level = 0,
            i = 0;

        for (; i < l; i++) {
          if (str[i] === '\\') {
            i++;
          } else if (str[i] === b[0]) {
            level++;
          } else if (str[i] === b[1]) {
            level--;

            if (level < 0) {
              return i;
            }
          }
        }

        return -1;
      }

      function checkSanitizeDeprecation(opt) {
        if (opt && opt.sanitize && !opt.silent) {
          console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
        }
      } // copied from https://stackoverflow.com/a/5450113/806777


      function repeatString(pattern, count) {
        if (count < 1) {
          return '';
        }

        var result = '';

        while (count > 1) {
          if (count & 1) {
            result += pattern;
          }

          count >>= 1;
          pattern += pattern;
        }

        return result + pattern;
      }

      var helpers = {
        escape: escape,
        unescape: unescape,
        edit: edit,
        cleanUrl: cleanUrl,
        resolveUrl: resolveUrl,
        noopTest: noopTest,
        merge: merge,
        splitCells: splitCells,
        rtrim: rtrim,
        findClosingBracket: findClosingBracket,
        checkSanitizeDeprecation: checkSanitizeDeprecation,
        repeatString: repeatString
      };

      var defaults$1 = defaults.defaults;
      var rtrim$1 = helpers.rtrim,
          splitCells$1 = helpers.splitCells,
          _escape = helpers.escape,
          findClosingBracket$1 = helpers.findClosingBracket;

      function outputLink(cap, link, raw) {
        var href = link.href;
        var title = link.title ? _escape(link.title) : null;
        var text = cap[1].replace(/\\([\[\]])/g, '$1');

        if (cap[0].charAt(0) !== '!') {
          return {
            type: 'link',
            raw: raw,
            href: href,
            title: title,
            text: text
          };
        } else {
          return {
            type: 'image',
            raw: raw,
            href: href,
            title: title,
            text: _escape(text)
          };
        }
      }

      function indentCodeCompensation(raw, text) {
        var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

        if (matchIndentToCode === null) {
          return text;
        }

        var indentToCode = matchIndentToCode[1];
        return text.split('\n').map(function (node) {
          var matchIndentInNode = node.match(/^\s+/);

          if (matchIndentInNode === null) {
            return node;
          }

          var indentInNode = matchIndentInNode[0];

          if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
          }

          return node;
        }).join('\n');
      }
      /**
       * Tokenizer
       */


      var Tokenizer_1 = /*#__PURE__*/function () {
        function Tokenizer(options) {
          this.options = options || defaults$1;
        }

        var _proto = Tokenizer.prototype;

        _proto.space = function space(src) {
          var cap = this.rules.block.newline.exec(src);

          if (cap) {
            if (cap[0].length > 1) {
              return {
                type: 'space',
                raw: cap[0]
              };
            }

            return {
              raw: '\n'
            };
          }
        };

        _proto.code = function code(src, tokens) {
          var cap = this.rules.block.code.exec(src);

          if (cap) {
            var lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

            if (lastToken && lastToken.type === 'paragraph') {
              return {
                raw: cap[0],
                text: cap[0].trimRight()
              };
            }

            var text = cap[0].replace(/^ {4}/gm, '');
            return {
              type: 'code',
              raw: cap[0],
              codeBlockStyle: 'indented',
              text: !this.options.pedantic ? rtrim$1(text, '\n') : text
            };
          }
        };

        _proto.fences = function fences(src) {
          var cap = this.rules.block.fences.exec(src);

          if (cap) {
            var raw = cap[0];
            var text = indentCodeCompensation(raw, cap[3] || '');
            return {
              type: 'code',
              raw: raw,
              lang: cap[2] ? cap[2].trim() : cap[2],
              text: text
            };
          }
        };

        _proto.heading = function heading(src) {
          var cap = this.rules.block.heading.exec(src);

          if (cap) {
            var text = cap[2].trim(); // remove trailing #s

            if (/#$/.test(text)) {
              var trimmed = rtrim$1(text, '#');

              if (this.options.pedantic) {
                text = trimmed.trim();
              } else if (!trimmed || / $/.test(trimmed)) {
                // CommonMark requires space before trailing #s
                text = trimmed.trim();
              }
            }

            return {
              type: 'heading',
              raw: cap[0],
              depth: cap[1].length,
              text: text
            };
          }
        };

        _proto.nptable = function nptable(src) {
          var cap = this.rules.block.nptable.exec(src);

          if (cap) {
            var item = {
              type: 'table',
              header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
              raw: cap[0]
            };

            if (item.header.length === item.align.length) {
              var l = item.align.length;
              var i;

              for (i = 0; i < l; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }

              l = item.cells.length;

              for (i = 0; i < l; i++) {
                item.cells[i] = splitCells$1(item.cells[i], item.header.length);
              }

              return item;
            }
          }
        };

        _proto.hr = function hr(src) {
          var cap = this.rules.block.hr.exec(src);

          if (cap) {
            return {
              type: 'hr',
              raw: cap[0]
            };
          }
        };

        _proto.blockquote = function blockquote(src) {
          var cap = this.rules.block.blockquote.exec(src);

          if (cap) {
            var text = cap[0].replace(/^ *> ?/gm, '');
            return {
              type: 'blockquote',
              raw: cap[0],
              text: text
            };
          }
        };

        _proto.list = function list(src) {
          var cap = this.rules.block.list.exec(src);

          if (cap) {
            var raw = cap[0];
            var bull = cap[2];
            var isordered = bull.length > 1;
            var list = {
              type: 'list',
              raw: raw,
              ordered: isordered,
              start: isordered ? +bull.slice(0, -1) : '',
              loose: false,
              items: []
            }; // Get each top-level item.

            var itemMatch = cap[0].match(this.rules.block.item);
            var next = false,
                item,
                space,
                bcurr,
                bnext,
                addBack,
                loose,
                istask,
                ischecked;
            var l = itemMatch.length;
            bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);

            for (var i = 0; i < l; i++) {
              item = itemMatch[i];
              raw = item; // Determine whether the next list item belongs here.
              // Backpedal if it does not belong in this list.

              if (i !== l - 1) {
                bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);

                if (bnext[1].length > bcurr[0].length || bnext[1].length > 3) {
                  // nested list
                  itemMatch.splice(i, 2, itemMatch[i] + '\n' + itemMatch[i + 1]);
                  i--;
                  l--;
                  continue;
                } else {
                  if ( // different bullet style
                  !this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                    addBack = itemMatch.slice(i + 1).join('\n');
                    list.raw = list.raw.substring(0, list.raw.length - addBack.length);
                    i = l - 1;
                  }
                }

                bcurr = bnext;
              } // Remove the list item's bullet
              // so it is seen as the next token.


              space = item.length;
              item = item.replace(/^ *([*+-]|\d+[.)]) ?/, ''); // Outdent whatever the
              // list item contains. Hacky.

              if (~item.indexOf('\n ')) {
                space -= item.length;
                item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
              } // Determine whether item is loose or not.
              // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
              // for discount behavior.


              loose = next || /\n\n(?!\s*$)/.test(item);

              if (i !== l - 1) {
                next = item.charAt(item.length - 1) === '\n';
                if (!loose) loose = next;
              }

              if (loose) {
                list.loose = true;
              } // Check for task list items


              if (this.options.gfm) {
                istask = /^\[[ xX]\] /.test(item);
                ischecked = undefined;

                if (istask) {
                  ischecked = item[1] !== ' ';
                  item = item.replace(/^\[[ xX]\] +/, '');
                }
              }

              list.items.push({
                type: 'list_item',
                raw: raw,
                task: istask,
                checked: ischecked,
                loose: loose,
                text: item
              });
            }

            return list;
          }
        };

        _proto.html = function html(src) {
          var cap = this.rules.block.html.exec(src);

          if (cap) {
            return {
              type: this.options.sanitize ? 'paragraph' : 'html',
              raw: cap[0],
              pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
            };
          }
        };

        _proto.def = function def(src) {
          var cap = this.rules.block.def.exec(src);

          if (cap) {
            if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
            var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
            return {
              tag: tag,
              raw: cap[0],
              href: cap[2],
              title: cap[3]
            };
          }
        };

        _proto.table = function table(src) {
          var cap = this.rules.block.table.exec(src);

          if (cap) {
            var item = {
              type: 'table',
              header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
            };

            if (item.header.length === item.align.length) {
              item.raw = cap[0];
              var l = item.align.length;
              var i;

              for (i = 0; i < l; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }

              l = item.cells.length;

              for (i = 0; i < l; i++) {
                item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
              }

              return item;
            }
          }
        };

        _proto.lheading = function lheading(src) {
          var cap = this.rules.block.lheading.exec(src);

          if (cap) {
            return {
              type: 'heading',
              raw: cap[0],
              depth: cap[2].charAt(0) === '=' ? 1 : 2,
              text: cap[1]
            };
          }
        };

        _proto.paragraph = function paragraph(src) {
          var cap = this.rules.block.paragraph.exec(src);

          if (cap) {
            return {
              type: 'paragraph',
              raw: cap[0],
              text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
            };
          }
        };

        _proto.text = function text(src, tokens) {
          var cap = this.rules.block.text.exec(src);

          if (cap) {
            var lastToken = tokens[tokens.length - 1];

            if (lastToken && lastToken.type === 'text') {
              return {
                raw: cap[0],
                text: cap[0]
              };
            }

            return {
              type: 'text',
              raw: cap[0],
              text: cap[0]
            };
          }
        };

        _proto.escape = function escape(src) {
          var cap = this.rules.inline.escape.exec(src);

          if (cap) {
            return {
              type: 'escape',
              raw: cap[0],
              text: _escape(cap[1])
            };
          }
        };

        _proto.tag = function tag(src, inLink, inRawBlock) {
          var cap = this.rules.inline.tag.exec(src);

          if (cap) {
            if (!inLink && /^<a /i.test(cap[0])) {
              inLink = true;
            } else if (inLink && /^<\/a>/i.test(cap[0])) {
              inLink = false;
            }

            if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              inRawBlock = true;
            } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              inRawBlock = false;
            }

            return {
              type: this.options.sanitize ? 'text' : 'html',
              raw: cap[0],
              inLink: inLink,
              inRawBlock: inRawBlock,
              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
            };
          }
        };

        _proto.link = function link(src) {
          var cap = this.rules.inline.link.exec(src);

          if (cap) {
            var trimmedUrl = cap[2].trim();

            if (!this.options.pedantic && /^</.test(trimmedUrl)) {
              // commonmark requires matching angle brackets
              if (!/>$/.test(trimmedUrl)) {
                return;
              } // ending angle bracket cannot be escaped


              var rtrimSlash = rtrim$1(trimmedUrl.slice(0, -1), '\\');

              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                return;
              }
            } else {
              // find closing parenthesis
              var lastParenIndex = findClosingBracket$1(cap[2], '()');

              if (lastParenIndex > -1) {
                var start = cap[0].indexOf('!') === 0 ? 5 : 4;
                var linkLen = start + cap[1].length + lastParenIndex;
                cap[2] = cap[2].substring(0, lastParenIndex);
                cap[0] = cap[0].substring(0, linkLen).trim();
                cap[3] = '';
              }
            }

            var href = cap[2];
            var title = '';

            if (this.options.pedantic) {
              // split pedantic href and title
              var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

              if (link) {
                href = link[1];
                title = link[3];
              }
            } else {
              title = cap[3] ? cap[3].slice(1, -1) : '';
            }

            href = href.trim();

            if (/^</.test(href)) {
              if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
                // pedantic allows starting angle bracket without ending angle bracket
                href = href.slice(1);
              } else {
                href = href.slice(1, -1);
              }
            }

            return outputLink(cap, {
              href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
              title: title ? title.replace(this.rules.inline._escapes, '$1') : title
            }, cap[0]);
          }
        };

        _proto.reflink = function reflink(src, links) {
          var cap;

          if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
            var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = links[link.toLowerCase()];

            if (!link || !link.href) {
              var text = cap[0].charAt(0);
              return {
                type: 'text',
                raw: text,
                text: text
              };
            }

            return outputLink(cap, link, cap[0]);
          }
        };

        _proto.strong = function strong(src, maskedSrc, prevChar) {
          if (prevChar === void 0) {
            prevChar = '';
          }

          var match = this.rules.inline.strong.start.exec(src);

          if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
            maskedSrc = maskedSrc.slice(-1 * src.length);
            var endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;
            endReg.lastIndex = 0;
            var cap;

            while ((match = endReg.exec(maskedSrc)) != null) {
              cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));

              if (cap) {
                return {
                  type: 'strong',
                  raw: src.slice(0, cap[0].length),
                  text: src.slice(2, cap[0].length - 2)
                };
              }
            }
          }
        };

        _proto.em = function em(src, maskedSrc, prevChar) {
          if (prevChar === void 0) {
            prevChar = '';
          }

          var match = this.rules.inline.em.start.exec(src);

          if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
            maskedSrc = maskedSrc.slice(-1 * src.length);
            var endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;
            endReg.lastIndex = 0;
            var cap;

            while ((match = endReg.exec(maskedSrc)) != null) {
              cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));

              if (cap) {
                return {
                  type: 'em',
                  raw: src.slice(0, cap[0].length),
                  text: src.slice(1, cap[0].length - 1)
                };
              }
            }
          }
        };

        _proto.codespan = function codespan(src) {
          var cap = this.rules.inline.code.exec(src);

          if (cap) {
            var text = cap[2].replace(/\n/g, ' ');
            var hasNonSpaceChars = /[^ ]/.test(text);
            var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
              text = text.substring(1, text.length - 1);
            }

            text = _escape(text, true);
            return {
              type: 'codespan',
              raw: cap[0],
              text: text
            };
          }
        };

        _proto.br = function br(src) {
          var cap = this.rules.inline.br.exec(src);

          if (cap) {
            return {
              type: 'br',
              raw: cap[0]
            };
          }
        };

        _proto.del = function del(src) {
          var cap = this.rules.inline.del.exec(src);

          if (cap) {
            return {
              type: 'del',
              raw: cap[0],
              text: cap[2]
            };
          }
        };

        _proto.autolink = function autolink(src, mangle) {
          var cap = this.rules.inline.autolink.exec(src);

          if (cap) {
            var text, href;

            if (cap[2] === '@') {
              text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
              href = 'mailto:' + text;
            } else {
              text = _escape(cap[1]);
              href = text;
            }

            return {
              type: 'link',
              raw: cap[0],
              text: text,
              href: href,
              tokens: [{
                type: 'text',
                raw: text,
                text: text
              }]
            };
          }
        };

        _proto.url = function url(src, mangle) {
          var cap;

          if (cap = this.rules.inline.url.exec(src)) {
            var text, href;

            if (cap[2] === '@') {
              text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
              href = 'mailto:' + text;
            } else {
              // do extended autolink path validation
              var prevCapZero;

              do {
                prevCapZero = cap[0];
                cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
              } while (prevCapZero !== cap[0]);

              text = _escape(cap[0]);

              if (cap[1] === 'www.') {
                href = 'http://' + text;
              } else {
                href = text;
              }
            }

            return {
              type: 'link',
              raw: cap[0],
              text: text,
              href: href,
              tokens: [{
                type: 'text',
                raw: text,
                text: text
              }]
            };
          }
        };

        _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {
          var cap = this.rules.inline.text.exec(src);

          if (cap) {
            var text;

            if (inRawBlock) {
              text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
            } else {
              text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
            }

            return {
              type: 'text',
              raw: cap[0],
              text: text
            };
          }
        };

        return Tokenizer;
      }();

      var noopTest$1 = helpers.noopTest,
          edit$1 = helpers.edit,
          merge$1 = helpers.merge;
      /**
       * Block-Level Grammar
       */

      var block = {
        newline: /^\n+/,
        code: /^( {4}[^\n]+\n*)+/,
        fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
        hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
        heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
        blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
        list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
        html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
        + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
        + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
        + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
        + ')',
        def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
        nptable: noopTest$1,
        table: noopTest$1,
        lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
        // regex template, placeholders will be replaced according to different paragraph
        // interruption rules of commonmark and the original markdown spec:
        _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
        text: /^[^\n]+/
      };
      block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
      block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
      block.def = edit$1(block.def).replace('label', block._label).replace('title', block._title).getRegex();
      block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
      block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
      block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();
      block.listItemStart = edit$1(/^( *)(bull)/).replace('bull', block.bullet).getRegex();
      block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
      block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
      block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
      block.html = edit$1(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
      block.paragraph = edit$1(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();
      block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();
      /**
       * Normal Block Grammar
       */

      block.normal = merge$1({}, block);
      /**
       * GFM Block Grammar
       */

      block.gfm = merge$1({}, block.normal, {
        nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
        + ' {0,3}([-:]+ *\\|[-| :]*)' // Align
        + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
        // Cells
        table: '^ *\\|(.+)\\n' // Header
        + ' {0,3}\\|?( *[-:]+[-| :]*)' // Align
        + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

      });
      block.gfm.nptable = edit$1(block.gfm.nptable).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();
      block.gfm.table = edit$1(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();
      /**
       * Pedantic grammar (original John Gruber's loose markdown specification)
       */

      block.pedantic = merge$1({}, block.normal, {
        html: edit$1('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: noopTest$1,
        // fences not supported
        paragraph: edit$1(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
      });
      /**
       * Inline-Level Grammar
       */

      var inline = {
        escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
        autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
        url: noopTest$1,
        tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
        // CDATA section
        link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
        reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
        nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
        reflinkSearch: 'reflink|nolink(?!\\()',
        strong: {
          start: /^(?:(\*\*(?=[*punctuation]))|\*\*)(?![\s])|__/,
          // (1) returns if starts w/ punctuation
          middle: /^\*\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?)__$/,
          endAst: /[^punctuation\s]\*\*(?!\*)|[punctuation]\*\*(?!\*)(?:(?=[punctuation_\s]|$))/,
          // last char can't be punct, or final * must also be followed by punct (or endline)
          endUnd: /[^\s]__(?!_)(?:(?=[punctuation*\s])|$)/ // last char can't be a space, and final _ must preceed punct or \s (or endline)

        },
        em: {
          start: /^(?:(\*(?=[punctuation]))|\*)(?![*\s])|_/,
          // (1) returns if starts w/ punctuation
          middle: /^\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?_$/,
          endAst: /[^punctuation\s]\*(?!\*)|[punctuation]\*(?!\*)(?:(?=[punctuation_\s]|$))/,
          // last char can't be punct, or final * must also be followed by punct (or endline)
          endUnd: /[^\s]_(?!_)(?:(?=[punctuation*\s])|$)/ // last char can't be a space, and final _ must preceed punct or \s (or endline)

        },
        code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
        br: /^( {2,}|\\)\n(?!\s*$)/,
        del: noopTest$1,
        text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n)))/,
        punctuation: /^([\s*punctuation])/
      }; // list of punctuation marks from common mark spec
      // without * and _ to workaround cases with double emphasis

      inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
      inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>

      inline._blockSkip = '\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>';
      inline._overlapSkip = '__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*';
      inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();
      inline.em.start = edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();
      inline.em.middle = edit$1(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
      inline.em.endAst = edit$1(inline.em.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.em.endUnd = edit$1(inline.em.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.strong.start = edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();
      inline.strong.middle = edit$1(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
      inline.strong.endAst = edit$1(inline.strong.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
      inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();
      inline.overlapSkip = edit$1(inline._overlapSkip, 'g').getRegex();
      inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
      inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
      inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
      inline.autolink = edit$1(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
      inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
      inline.tag = edit$1(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
      inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
      inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
      inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
      inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
      inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();
      inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();
      /**
       * Normal Inline Grammar
       */

      inline.normal = merge$1({}, inline);
      /**
       * Pedantic Inline Grammar
       */

      inline.pedantic = merge$1({}, inline.normal, {
        strong: {
          start: /^__|\*\*/,
          middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          endAst: /\*\*(?!\*)/g,
          endUnd: /__(?!_)/g
        },
        em: {
          start: /^_|\*/,
          middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
          endAst: /\*(?!\*)/g,
          endUnd: /_(?!_)/g
        },
        link: edit$1(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
        reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
      });
      /**
       * GFM Inline Grammar
       */

      inline.gfm = merge$1({}, inline.normal, {
        escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
      });
      inline.gfm.url = edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
      /**
       * GFM + Line Breaks Inline Grammar
       */

      inline.breaks = merge$1({}, inline.gfm, {
        br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
        text: edit$1(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
      });
      var rules = {
        block: block,
        inline: inline
      };

      var defaults$2 = defaults.defaults;
      var block$1 = rules.block,
          inline$1 = rules.inline;
      var repeatString$1 = helpers.repeatString;
      /**
       * smartypants text replacement
       */

      function smartypants(text) {
        return text // em-dashes
        .replace(/---/g, "\u2014") // en-dashes
        .replace(/--/g, "\u2013") // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
        .replace(/'/g, "\u2019") // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
        .replace(/"/g, "\u201D") // ellipses
        .replace(/\.{3}/g, "\u2026");
      }
      /**
       * mangle email addresses
       */


      function mangle(text) {
        var out = '',
            i,
            ch;
        var l = text.length;

        for (i = 0; i < l; i++) {
          ch = text.charCodeAt(i);

          if (Math.random() > 0.5) {
            ch = 'x' + ch.toString(16);
          }

          out += '&#' + ch + ';';
        }

        return out;
      }
      /**
       * Block Lexer
       */


      var Lexer_1 = /*#__PURE__*/function () {
        function Lexer(options) {
          this.tokens = [];
          this.tokens.links = Object.create(null);
          this.options = options || defaults$2;
          this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          var rules = {
            block: block$1.normal,
            inline: inline$1.normal
          };

          if (this.options.pedantic) {
            rules.block = block$1.pedantic;
            rules.inline = inline$1.pedantic;
          } else if (this.options.gfm) {
            rules.block = block$1.gfm;

            if (this.options.breaks) {
              rules.inline = inline$1.breaks;
            } else {
              rules.inline = inline$1.gfm;
            }
          }

          this.tokenizer.rules = rules;
        }
        /**
         * Expose Rules
         */


        /**
         * Static Lex Method
         */
        Lexer.lex = function lex(src, options) {
          var lexer = new Lexer(options);
          return lexer.lex(src);
        }
        /**
         * Static Lex Inline Method
         */
        ;

        Lexer.lexInline = function lexInline(src, options) {
          var lexer = new Lexer(options);
          return lexer.inlineTokens(src);
        }
        /**
         * Preprocessing
         */
        ;

        var _proto = Lexer.prototype;

        _proto.lex = function lex(src) {
          src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
          this.blockTokens(src, this.tokens, true);
          this.inline(this.tokens);
          return this.tokens;
        }
        /**
         * Lexing
         */
        ;

        _proto.blockTokens = function blockTokens(src, tokens, top) {
          if (tokens === void 0) {
            tokens = [];
          }

          if (top === void 0) {
            top = true;
          }

          src = src.replace(/^ +$/gm, '');
          var token, i, l, lastToken;

          while (src) {
            // newline
            if (token = this.tokenizer.space(src)) {
              src = src.substring(token.raw.length);

              if (token.type) {
                tokens.push(token);
              }

              continue;
            } // code


            if (token = this.tokenizer.code(src, tokens)) {
              src = src.substring(token.raw.length);

              if (token.type) {
                tokens.push(token);
              } else {
                lastToken = tokens[tokens.length - 1];
                lastToken.raw += '\n' + token.raw;
                lastToken.text += '\n' + token.text;
              }

              continue;
            } // fences


            if (token = this.tokenizer.fences(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // heading


            if (token = this.tokenizer.heading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // table no leading pipe (gfm)


            if (token = this.tokenizer.nptable(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // hr


            if (token = this.tokenizer.hr(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // blockquote


            if (token = this.tokenizer.blockquote(src)) {
              src = src.substring(token.raw.length);
              token.tokens = this.blockTokens(token.text, [], top);
              tokens.push(token);
              continue;
            } // list


            if (token = this.tokenizer.list(src)) {
              src = src.substring(token.raw.length);
              l = token.items.length;

              for (i = 0; i < l; i++) {
                token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
              }

              tokens.push(token);
              continue;
            } // html


            if (token = this.tokenizer.html(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // def


            if (top && (token = this.tokenizer.def(src))) {
              src = src.substring(token.raw.length);

              if (!this.tokens.links[token.tag]) {
                this.tokens.links[token.tag] = {
                  href: token.href,
                  title: token.title
                };
              }

              continue;
            } // table (gfm)


            if (token = this.tokenizer.table(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // lheading


            if (token = this.tokenizer.lheading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // top-level paragraph


            if (top && (token = this.tokenizer.paragraph(src))) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // text


            if (token = this.tokenizer.text(src, tokens)) {
              src = src.substring(token.raw.length);

              if (token.type) {
                tokens.push(token);
              } else {
                lastToken = tokens[tokens.length - 1];
                lastToken.raw += '\n' + token.raw;
                lastToken.text += '\n' + token.text;
              }

              continue;
            }

            if (src) {
              var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }

          return tokens;
        };

        _proto.inline = function inline(tokens) {
          var i, j, k, l2, row, token;
          var l = tokens.length;

          for (i = 0; i < l; i++) {
            token = tokens[i];

            switch (token.type) {
              case 'paragraph':
              case 'text':
              case 'heading':
                {
                  token.tokens = [];
                  this.inlineTokens(token.text, token.tokens);
                  break;
                }

              case 'table':
                {
                  token.tokens = {
                    header: [],
                    cells: []
                  }; // header

                  l2 = token.header.length;

                  for (j = 0; j < l2; j++) {
                    token.tokens.header[j] = [];
                    this.inlineTokens(token.header[j], token.tokens.header[j]);
                  } // cells


                  l2 = token.cells.length;

                  for (j = 0; j < l2; j++) {
                    row = token.cells[j];
                    token.tokens.cells[j] = [];

                    for (k = 0; k < row.length; k++) {
                      token.tokens.cells[j][k] = [];
                      this.inlineTokens(row[k], token.tokens.cells[j][k]);
                    }
                  }

                  break;
                }

              case 'blockquote':
                {
                  this.inline(token.tokens);
                  break;
                }

              case 'list':
                {
                  l2 = token.items.length;

                  for (j = 0; j < l2; j++) {
                    this.inline(token.items[j].tokens);
                  }

                  break;
                }
            }
          }

          return tokens;
        }
        /**
         * Lexing/Compiling
         */
        ;

        _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {
          if (tokens === void 0) {
            tokens = [];
          }

          if (inLink === void 0) {
            inLink = false;
          }

          if (inRawBlock === void 0) {
            inRawBlock = false;
          }

          var token; // String with links masked to avoid interference with em and strong

          var maskedSrc = src;
          var match;
          var keepPrevChar, prevChar; // Mask out reflinks

          if (this.tokens.links) {
            var links = Object.keys(this.tokens.links);

            if (links.length > 0) {
              while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                  maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                }
              }
            }
          } // Mask out other blocks


          while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          }

          while (src) {
            if (!keepPrevChar) {
              prevChar = '';
            }

            keepPrevChar = false; // escape

            if (token = this.tokenizer.escape(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // tag


            if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
              src = src.substring(token.raw.length);
              inLink = token.inLink;
              inRawBlock = token.inRawBlock;
              tokens.push(token);
              continue;
            } // link


            if (token = this.tokenizer.link(src)) {
              src = src.substring(token.raw.length);

              if (token.type === 'link') {
                token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
              }

              tokens.push(token);
              continue;
            } // reflink, nolink


            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
              src = src.substring(token.raw.length);

              if (token.type === 'link') {
                token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
              }

              tokens.push(token);
              continue;
            } // strong


            if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            } // em


            if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            } // code


            if (token = this.tokenizer.codespan(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // br


            if (token = this.tokenizer.br(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // del (gfm)


            if (token = this.tokenizer.del(src)) {
              src = src.substring(token.raw.length);
              token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
              tokens.push(token);
              continue;
            } // autolink


            if (token = this.tokenizer.autolink(src, mangle)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // url (gfm)


            if (!inLink && (token = this.tokenizer.url(src, mangle))) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            } // text


            if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
              src = src.substring(token.raw.length);
              prevChar = token.raw.slice(-1);
              keepPrevChar = true;
              tokens.push(token);
              continue;
            }

            if (src) {
              var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }

          return tokens;
        };

        _createClass(Lexer, null, [{
          key: "rules",
          get: function get() {
            return {
              block: block$1,
              inline: inline$1
            };
          }
        }]);

        return Lexer;
      }();

      var defaults$3 = defaults.defaults;
      var cleanUrl$1 = helpers.cleanUrl,
          escape$1 = helpers.escape;
      /**
       * Renderer
       */

      var Renderer_1 = /*#__PURE__*/function () {
        function Renderer(options) {
          this.options = options || defaults$3;
        }

        var _proto = Renderer.prototype;

        _proto.code = function code(_code, infostring, escaped) {
          var lang = (infostring || '').match(/\S*/)[0];

          if (this.options.highlight) {
            var out = this.options.highlight(_code, lang);

            if (out != null && out !== _code) {
              escaped = true;
              _code = out;
            }
          }

          if (!lang) {
            return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
          }

          return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
        };

        _proto.blockquote = function blockquote(quote) {
          return '<blockquote>\n' + quote + '</blockquote>\n';
        };

        _proto.html = function html(_html) {
          return _html;
        };

        _proto.heading = function heading(text, level, raw, slugger) {
          if (this.options.headerIds) {
            return '<h' + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + '</h' + level + '>\n';
          } // ignore IDs


          return '<h' + level + '>' + text + '</h' + level + '>\n';
        };

        _proto.hr = function hr() {
          return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
        };

        _proto.list = function list(body, ordered, start) {
          var type = ordered ? 'ol' : 'ul',
              startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
          return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
        };

        _proto.listitem = function listitem(text) {
          return '<li>' + text + '</li>\n';
        };

        _proto.checkbox = function checkbox(checked) {
          return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
        };

        _proto.paragraph = function paragraph(text) {
          return '<p>' + text + '</p>\n';
        };

        _proto.table = function table(header, body) {
          if (body) body = '<tbody>' + body + '</tbody>';
          return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
        };

        _proto.tablerow = function tablerow(content) {
          return '<tr>\n' + content + '</tr>\n';
        };

        _proto.tablecell = function tablecell(content, flags) {
          var type = flags.header ? 'th' : 'td';
          var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
          return tag + content + '</' + type + '>\n';
        } // span level renderer
        ;

        _proto.strong = function strong(text) {
          return '<strong>' + text + '</strong>';
        };

        _proto.em = function em(text) {
          return '<em>' + text + '</em>';
        };

        _proto.codespan = function codespan(text) {
          return '<code>' + text + '</code>';
        };

        _proto.br = function br() {
          return this.options.xhtml ? '<br/>' : '<br>';
        };

        _proto.del = function del(text) {
          return '<del>' + text + '</del>';
        };

        _proto.link = function link(href, title, text) {
          href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);

          if (href === null) {
            return text;
          }

          var out = '<a href="' + escape$1(href) + '"';

          if (title) {
            out += ' title="' + title + '"';
          }

          out += '>' + text + '</a>';
          return out;
        };

        _proto.image = function image(href, title, text) {
          href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);

          if (href === null) {
            return text;
          }

          var out = '<img src="' + href + '" alt="' + text + '"';

          if (title) {
            out += ' title="' + title + '"';
          }

          out += this.options.xhtml ? '/>' : '>';
          return out;
        };

        _proto.text = function text(_text) {
          return _text;
        };

        return Renderer;
      }();

      /**
       * TextRenderer
       * returns only the textual part of the token
       */
      var TextRenderer_1 = /*#__PURE__*/function () {
        function TextRenderer() {}

        var _proto = TextRenderer.prototype;

        // no need for block level renderers
        _proto.strong = function strong(text) {
          return text;
        };

        _proto.em = function em(text) {
          return text;
        };

        _proto.codespan = function codespan(text) {
          return text;
        };

        _proto.del = function del(text) {
          return text;
        };

        _proto.html = function html(text) {
          return text;
        };

        _proto.text = function text(_text) {
          return _text;
        };

        _proto.link = function link(href, title, text) {
          return '' + text;
        };

        _proto.image = function image(href, title, text) {
          return '' + text;
        };

        _proto.br = function br() {
          return '';
        };

        return TextRenderer;
      }();

      /**
       * Slugger generates header id
       */
      var Slugger_1 = /*#__PURE__*/function () {
        function Slugger() {
          this.seen = {};
        }

        var _proto = Slugger.prototype;

        _proto.serialize = function serialize(value) {
          return value.toLowerCase().trim() // remove html tags
          .replace(/<[!\/a-z].*?>/ig, '') // remove unwanted chars
          .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
        }
        /**
         * Finds the next safe (unique) slug to use
         */
        ;

        _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
          var slug = originalSlug;
          var occurenceAccumulator = 0;

          if (this.seen.hasOwnProperty(slug)) {
            occurenceAccumulator = this.seen[originalSlug];

            do {
              occurenceAccumulator++;
              slug = originalSlug + '-' + occurenceAccumulator;
            } while (this.seen.hasOwnProperty(slug));
          }

          if (!isDryRun) {
            this.seen[originalSlug] = occurenceAccumulator;
            this.seen[slug] = 0;
          }

          return slug;
        }
        /**
         * Convert string to unique id
         * @param {object} options
         * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
         */
        ;

        _proto.slug = function slug(value, options) {
          if (options === void 0) {
            options = {};
          }

          var slug = this.serialize(value);
          return this.getNextSafeSlug(slug, options.dryrun);
        };

        return Slugger;
      }();

      var defaults$4 = defaults.defaults;
      var unescape$1 = helpers.unescape;
      /**
       * Parsing & Compiling
       */

      var Parser_1 = /*#__PURE__*/function () {
        function Parser(options) {
          this.options = options || defaults$4;
          this.options.renderer = this.options.renderer || new Renderer_1();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.textRenderer = new TextRenderer_1();
          this.slugger = new Slugger_1();
        }
        /**
         * Static Parse Method
         */


        Parser.parse = function parse(tokens, options) {
          var parser = new Parser(options);
          return parser.parse(tokens);
        }
        /**
         * Static Parse Inline Method
         */
        ;

        Parser.parseInline = function parseInline(tokens, options) {
          var parser = new Parser(options);
          return parser.parseInline(tokens);
        }
        /**
         * Parse Loop
         */
        ;

        var _proto = Parser.prototype;

        _proto.parse = function parse(tokens, top) {
          if (top === void 0) {
            top = true;
          }

          var out = '',
              i,
              j,
              k,
              l2,
              l3,
              row,
              cell,
              header,
              body,
              token,
              ordered,
              start,
              loose,
              itemBody,
              item,
              checked,
              task,
              checkbox;
          var l = tokens.length;

          for (i = 0; i < l; i++) {
            token = tokens[i];

            switch (token.type) {
              case 'space':
                {
                  continue;
                }

              case 'hr':
                {
                  out += this.renderer.hr();
                  continue;
                }

              case 'heading':
                {
                  out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
                  continue;
                }

              case 'code':
                {
                  out += this.renderer.code(token.text, token.lang, token.escaped);
                  continue;
                }

              case 'table':
                {
                  header = ''; // header

                  cell = '';
                  l2 = token.header.length;

                  for (j = 0; j < l2; j++) {
                    cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {
                      header: true,
                      align: token.align[j]
                    });
                  }

                  header += this.renderer.tablerow(cell);
                  body = '';
                  l2 = token.cells.length;

                  for (j = 0; j < l2; j++) {
                    row = token.tokens.cells[j];
                    cell = '';
                    l3 = row.length;

                    for (k = 0; k < l3; k++) {
                      cell += this.renderer.tablecell(this.parseInline(row[k]), {
                        header: false,
                        align: token.align[k]
                      });
                    }

                    body += this.renderer.tablerow(cell);
                  }

                  out += this.renderer.table(header, body);
                  continue;
                }

              case 'blockquote':
                {
                  body = this.parse(token.tokens);
                  out += this.renderer.blockquote(body);
                  continue;
                }

              case 'list':
                {
                  ordered = token.ordered;
                  start = token.start;
                  loose = token.loose;
                  l2 = token.items.length;
                  body = '';

                  for (j = 0; j < l2; j++) {
                    item = token.items[j];
                    checked = item.checked;
                    task = item.task;
                    itemBody = '';

                    if (item.task) {
                      checkbox = this.renderer.checkbox(checked);

                      if (loose) {
                        if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                          item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                          }
                        } else {
                          item.tokens.unshift({
                            type: 'text',
                            text: checkbox
                          });
                        }
                      } else {
                        itemBody += checkbox;
                      }
                    }

                    itemBody += this.parse(item.tokens, loose);
                    body += this.renderer.listitem(itemBody, task, checked);
                  }

                  out += this.renderer.list(body, ordered, start);
                  continue;
                }

              case 'html':
                {
                  // TODO parse inline content if parameter markdown=1
                  out += this.renderer.html(token.text);
                  continue;
                }

              case 'paragraph':
                {
                  out += this.renderer.paragraph(this.parseInline(token.tokens));
                  continue;
                }

              case 'text':
                {
                  body = token.tokens ? this.parseInline(token.tokens) : token.text;

                  while (i + 1 < l && tokens[i + 1].type === 'text') {
                    token = tokens[++i];
                    body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
                  }

                  out += top ? this.renderer.paragraph(body) : body;
                  continue;
                }

              default:
                {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';

                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
            }
          }

          return out;
        }
        /**
         * Parse Inline Tokens
         */
        ;

        _proto.parseInline = function parseInline(tokens, renderer) {
          renderer = renderer || this.renderer;
          var out = '',
              i,
              token;
          var l = tokens.length;

          for (i = 0; i < l; i++) {
            token = tokens[i];

            switch (token.type) {
              case 'escape':
                {
                  out += renderer.text(token.text);
                  break;
                }

              case 'html':
                {
                  out += renderer.html(token.text);
                  break;
                }

              case 'link':
                {
                  out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'image':
                {
                  out += renderer.image(token.href, token.title, token.text);
                  break;
                }

              case 'strong':
                {
                  out += renderer.strong(this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'em':
                {
                  out += renderer.em(this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'codespan':
                {
                  out += renderer.codespan(token.text);
                  break;
                }

              case 'br':
                {
                  out += renderer.br();
                  break;
                }

              case 'del':
                {
                  out += renderer.del(this.parseInline(token.tokens, renderer));
                  break;
                }

              case 'text':
                {
                  out += renderer.text(token.text);
                  break;
                }

              default:
                {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';

                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
            }
          }

          return out;
        };

        return Parser;
      }();

      var merge$2 = helpers.merge,
          checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,
          escape$2 = helpers.escape;
      var getDefaults = defaults.getDefaults,
          changeDefaults = defaults.changeDefaults,
          defaults$5 = defaults.defaults;
      /**
       * Marked
       */

      function marked(src, opt, callback) {
        // throw error in case of non string input
        if (typeof src === 'undefined' || src === null) {
          throw new Error('marked(): input parameter is undefined or null');
        }

        if (typeof src !== 'string') {
          throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
        }

        if (typeof opt === 'function') {
          callback = opt;
          opt = null;
        }

        opt = merge$2({}, marked.defaults, opt || {});
        checkSanitizeDeprecation$1(opt);

        if (callback) {
          var highlight = opt.highlight;
          var tokens;

          try {
            tokens = Lexer_1.lex(src, opt);
          } catch (e) {
            return callback(e);
          }

          var done = function done(err) {
            var out;

            if (!err) {
              try {
                out = Parser_1.parse(tokens, opt);
              } catch (e) {
                err = e;
              }
            }

            opt.highlight = highlight;
            return err ? callback(err) : callback(null, out);
          };

          if (!highlight || highlight.length < 3) {
            return done();
          }

          delete opt.highlight;
          if (!tokens.length) return done();
          var pending = 0;
          marked.walkTokens(tokens, function (token) {
            if (token.type === 'code') {
              pending++;
              setTimeout(function () {
                highlight(token.text, token.lang, function (err, code) {
                  if (err) {
                    return done(err);
                  }

                  if (code != null && code !== token.text) {
                    token.text = code;
                    token.escaped = true;
                  }

                  pending--;

                  if (pending === 0) {
                    done();
                  }
                });
              }, 0);
            }
          });

          if (pending === 0) {
            done();
          }

          return;
        }

        try {
          var _tokens = Lexer_1.lex(src, opt);

          if (opt.walkTokens) {
            marked.walkTokens(_tokens, opt.walkTokens);
          }

          return Parser_1.parse(_tokens, opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/markedjs/marked.';

          if (opt.silent) {
            return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
          }

          throw e;
        }
      }
      /**
       * Options
       */


      marked.options = marked.setOptions = function (opt) {
        merge$2(marked.defaults, opt);
        changeDefaults(marked.defaults);
        return marked;
      };

      marked.getDefaults = getDefaults;
      marked.defaults = defaults$5;
      /**
       * Use Extension
       */

      marked.use = function (extension) {
        var opts = merge$2({}, extension);

        if (extension.renderer) {
          (function () {
            var renderer = marked.defaults.renderer || new Renderer_1();

            var _loop = function _loop(prop) {
              var prevRenderer = renderer[prop];

              renderer[prop] = function () {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                var ret = extension.renderer[prop].apply(renderer, args);

                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args);
                }

                return ret;
              };
            };

            for (var prop in extension.renderer) {
              _loop(prop);
            }

            opts.renderer = renderer;
          })();
        }

        if (extension.tokenizer) {
          (function () {
            var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();

            var _loop2 = function _loop2(prop) {
              var prevTokenizer = tokenizer[prop];

              tokenizer[prop] = function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                var ret = extension.tokenizer[prop].apply(tokenizer, args);

                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args);
                }

                return ret;
              };
            };

            for (var prop in extension.tokenizer) {
              _loop2(prop);
            }

            opts.tokenizer = tokenizer;
          })();
        }

        if (extension.walkTokens) {
          var walkTokens = marked.defaults.walkTokens;

          opts.walkTokens = function (token) {
            extension.walkTokens(token);

            if (walkTokens) {
              walkTokens(token);
            }
          };
        }

        marked.setOptions(opts);
      };
      /**
       * Run callback for every token
       */


      marked.walkTokens = function (tokens, callback) {
        for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
          var token = _step.value;
          callback(token);

          switch (token.type) {
            case 'table':
              {
                for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {
                  var cell = _step2.value;
                  marked.walkTokens(cell, callback);
                }

                for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {
                  var row = _step3.value;

                  for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                    var _cell = _step4.value;
                    marked.walkTokens(_cell, callback);
                  }
                }

                break;
              }

            case 'list':
              {
                marked.walkTokens(token.items, callback);
                break;
              }

            default:
              {
                if (token.tokens) {
                  marked.walkTokens(token.tokens, callback);
                }
              }
          }
        }
      };
      /**
       * Parse Inline
       */


      marked.parseInline = function (src, opt) {
        // throw error in case of non string input
        if (typeof src === 'undefined' || src === null) {
          throw new Error('marked.parseInline(): input parameter is undefined or null');
        }

        if (typeof src !== 'string') {
          throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
        }

        opt = merge$2({}, marked.defaults, opt || {});
        checkSanitizeDeprecation$1(opt);

        try {
          var tokens = Lexer_1.lexInline(src, opt);

          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }

          return Parser_1.parseInline(tokens, opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/markedjs/marked.';

          if (opt.silent) {
            return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
          }

          throw e;
        }
      };
      /**
       * Expose
       */


      marked.Parser = Parser_1;
      marked.parser = Parser_1.parse;
      marked.Renderer = Renderer_1;
      marked.TextRenderer = TextRenderer_1;
      marked.Lexer = Lexer_1;
      marked.lexer = Lexer_1.lex;
      marked.Tokenizer = Tokenizer_1;
      marked.Slugger = Slugger_1;
      marked.parse = marked;
      var marked_1 = marked;

      return marked_1;

    })));
    });

    /* src/components/Markdown.svelte generated by Svelte v3.31.0 */

    // (8:0) {#if text && text.length}
    function create_if_block$6(ctx) {
    	let html_tag;
    	let raw_value = purify.sanitize(marked(/*text*/ ctx[0])) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 1 && raw_value !== (raw_value = purify.sanitize(marked(/*text*/ ctx[0])) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(8:0) {#if text && text.length}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let if_block_anchor;
    	let if_block = /*text*/ ctx[0] && /*text*/ ctx[0].length && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*text*/ ctx[0] && /*text*/ ctx[0].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Markdown", slots, []);
    	let { text } = $$props;
    	const writable_props = ["text"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Markdown> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ DOMPurify: purify, marked, text });

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text];
    }

    class Markdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { text: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Markdown",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*text*/ ctx[0] === undefined && !("text" in props)) {
    			console.warn("<Markdown> was created without expected prop 'text'");
    		}
    	}

    	get text() {
    		throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/forum/AddPost.svelte generated by Svelte v3.31.0 */

    const { console: console_1$2 } = globals;
    const file$a = "src/components/forum/AddPost.svelte";

    // (103:4) {#if replyTo === '0'}
    function create_if_block_3$1(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Type a title");
    			input.required = true;
    			attr_dev(input, "class", "svelte-1tw27t");
    			add_location(input, file$a, 103, 8, 2150);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*title*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 2 && input.value !== /*title*/ ctx[1]) {
    				set_input_value(input, /*title*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(103:4) {#if replyTo === '0'}",
    		ctx
    	});

    	return block;
    }

    // (111:4) {#if showPreview}
    function create_if_block_1$2(ctx) {
    	let div;
    	let t;
    	let markdown;
    	let current;
    	let if_block = /*body*/ ctx[2].length === 0 && create_if_block_2$2(ctx);

    	markdown = new Markdown({
    			props: { text: /*body*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			create_component(markdown.$$.fragment);
    			attr_dev(div, "class", "preview");
    			add_location(div, file$a, 111, 8, 2388);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			mount_component(markdown, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*body*/ ctx[2].length === 0) {
    				if (if_block) ; else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const markdown_changes = {};
    			if (dirty & /*body*/ 4) markdown_changes.text = /*body*/ ctx[2];
    			markdown.$set(markdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(markdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(markdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			destroy_component(markdown);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(111:4) {#if showPreview}",
    		ctx
    	});

    	return block;
    }

    // (113:12) {#if body.length === 0}
    function create_if_block_2$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Nothing to preview. Type something in the field above.";
    			attr_dev(p, "class", "svelte-1tw27t");
    			add_location(p, file$a, 113, 16, 2462);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(113:12) {#if body.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (132:4) {#if error}
    function create_if_block$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*error*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 8) set_data_dev(t, /*error*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(132:4) {#if error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let form;
    	let t0;
    	let textarea;
    	let t1;
    	let t2;
    	let div;
    	let p;
    	let t3;
    	let a;
    	let t5;
    	let label;
    	let t6;
    	let input;
    	let t7;
    	let button;
    	let t9;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*replyTo*/ ctx[0] === "0" && create_if_block_3$1(ctx);
    	let if_block1 = /*showPreview*/ ctx[4] && create_if_block_1$2(ctx);
    	let if_block2 = /*error*/ ctx[3] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			textarea = element("textarea");
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div = element("div");
    			p = element("p");
    			t3 = text("Use\n            ");
    			a = element("a");
    			a.textContent = "markdown";
    			t5 = text("\n            to format the message.\n            ");
    			label = element("label");
    			t6 = text("Show preview\n                ");
    			input = element("input");
    			t7 = space();
    			button = element("button");
    			button.textContent = "Post";
    			t9 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(textarea, "placeholder", "Type a message");
    			textarea.required = true;
    			attr_dev(textarea, "class", "svelte-1tw27t");
    			add_location(textarea, file$a, 109, 4, 2289);
    			attr_dev(a, "href", "https://guides.github.com/features/mastering-markdown/#syntax");
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$a, 121, 12, 2671);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "svelte-1tw27t");
    			add_location(input, file$a, 127, 16, 2904);
    			attr_dev(label, "class", "svelte-1tw27t");
    			add_location(label, file$a, 126, 12, 2868);
    			attr_dev(p, "class", "svelte-1tw27t");
    			add_location(p, file$a, 119, 8, 2639);
    			attr_dev(button, "type", "submit");
    			add_location(button, file$a, 129, 8, 2986);
    			attr_dev(div, "class", "commands svelte-1tw27t");
    			add_location(div, file$a, 118, 4, 2608);
    			attr_dev(form, "autocomplete", "off");
    			attr_dev(form, "class", "svelte-1tw27t");
    			add_location(form, file$a, 101, 0, 2050);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			if (if_block0) if_block0.m(form, null);
    			append_dev(form, t0);
    			append_dev(form, textarea);
    			set_input_value(textarea, /*body*/ ctx[2]);
    			append_dev(form, t1);
    			if (if_block1) if_block1.m(form, null);
    			append_dev(form, t2);
    			append_dev(form, div);
    			append_dev(div, p);
    			append_dev(p, t3);
    			append_dev(p, a);
    			append_dev(p, t5);
    			append_dev(p, label);
    			append_dev(label, t6);
    			append_dev(label, input);
    			input.checked = /*showPreview*/ ctx[4];
    			append_dev(div, t7);
    			append_dev(div, button);
    			append_dev(form, t9);
    			if (if_block2) if_block2.m(form, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[8]),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[9]),
    					listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*replyTo*/ ctx[0] === "0") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					if_block0.m(form, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*body*/ 4) {
    				set_input_value(textarea, /*body*/ ctx[2]);
    			}

    			if (/*showPreview*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showPreview*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(form, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*showPreview*/ 16) {
    				input.checked = /*showPreview*/ ctx[4];
    			}

    			if (/*error*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$7(ctx);
    					if_block2.c();
    					if_block2.m(form, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AddPost", slots, []);
    	let { onSuccess } = $$props;
    	let { replyTo = "0" } = $$props;
    	const draftKey = `post-draft:${replyTo}`;
    	let { title, body } = loadDraft();
    	let error;
    	let showPreview;
    	let timerId;

    	function saveDraft() {
    		localStorage.setItem(draftKey, JSON.stringify({ title, body }));
    	}

    	function loadDraft() {
    		let values;

    		try {
    			values = JSON.parse(localStorage.getItem(draftKey));
    		} catch(e) {
    			console.log(e);
    		}

    		values = values || {};

    		return {
    			title: values.title || "",
    			body: values.body || ""
    		};
    	}

    	function clearDraft() {
    		localStorage.removeItem(draftKey);
    	}

    	onMount(() => {
    		timerId = setInterval(saveDraft, 1000);
    		return () => clearInterval(timerId);
    	});

    	function togglePreview() {
    		$$invalidate(4, showPreview = !showPreview);
    	}

    	async function handleSubmit() {
    		try {
    			const postId = await addPost(replyTo, title, body);
    			$$invalidate(1, title = "");
    			$$invalidate(2, body = "");
    			clearInterval(timerId);
    			clearDraft();

    			if (onSuccess) {
    				onSuccess(postId);
    			} else {
    				push("#/forum");
    			}
    		} catch(e) {
    			$$invalidate(3, error = e.message);
    		}
    	}

    	const writable_props = ["onSuccess", "replyTo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<AddPost> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		title = this.value;
    		$$invalidate(1, title);
    	}

    	function textarea_input_handler() {
    		body = this.value;
    		$$invalidate(2, body);
    	}

    	function input_change_handler() {
    		showPreview = this.checked;
    		$$invalidate(4, showPreview);
    	}

    	$$self.$$set = $$props => {
    		if ("onSuccess" in $$props) $$invalidate(6, onSuccess = $$props.onSuccess);
    		if ("replyTo" in $$props) $$invalidate(0, replyTo = $$props.replyTo);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		push,
    		addPost,
    		Markdown,
    		onSuccess,
    		replyTo,
    		draftKey,
    		title,
    		body,
    		error,
    		showPreview,
    		timerId,
    		saveDraft,
    		loadDraft,
    		clearDraft,
    		togglePreview,
    		handleSubmit
    	});

    	$$self.$inject_state = $$props => {
    		if ("onSuccess" in $$props) $$invalidate(6, onSuccess = $$props.onSuccess);
    		if ("replyTo" in $$props) $$invalidate(0, replyTo = $$props.replyTo);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("body" in $$props) $$invalidate(2, body = $$props.body);
    		if ("error" in $$props) $$invalidate(3, error = $$props.error);
    		if ("showPreview" in $$props) $$invalidate(4, showPreview = $$props.showPreview);
    		if ("timerId" in $$props) timerId = $$props.timerId;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		replyTo,
    		title,
    		body,
    		error,
    		showPreview,
    		handleSubmit,
    		onSuccess,
    		input_input_handler,
    		textarea_input_handler,
    		input_change_handler
    	];
    }

    class AddPost extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { onSuccess: 6, replyTo: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddPost",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onSuccess*/ ctx[6] === undefined && !("onSuccess" in props)) {
    			console_1$2.warn("<AddPost> was created without expected prop 'onSuccess'");
    		}
    	}

    	get onSuccess() {
    		throw new Error("<AddPost>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onSuccess(value) {
    		throw new Error("<AddPost>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replyTo() {
    		throw new Error("<AddPost>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replyTo(value) {
    		throw new Error("<AddPost>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/forum/Post.svelte generated by Svelte v3.31.0 */
    const file$b = "src/components/forum/Post.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (127:0) {:catch error}
    function create_catch_block_1(ctx) {
    	let t_value = /*error*/ ctx[10].message + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(127:0) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (67:30)      <div class="post">         <h1>{post.title}
    function create_then_block$1(ctx) {
    	let div2;
    	let h1;
    	let t0_value = /*post*/ ctx[5].title + "";
    	let t0;
    	let t1;
    	let div0;
    	let p0;
    	let strong;
    	let t2_value = /*post*/ ctx[5].name + "";
    	let t2;
    	let t3;
    	let time;
    	let t4_value = prettyDate(/*post*/ ctx[5].ts * 1000) + "";
    	let t4;
    	let time_title_value;
    	let time_datetime_value;
    	let t5;
    	let t6;
    	let div1;
    	let markdown;
    	let t7;
    	let div3;
    	let promise;
    	let t8;
    	let div4;
    	let p1;
    	let t10;
    	let addpost;
    	let current;
    	let if_block = /*post*/ ctx[5].publicKey === /*$publicKey*/ ctx[2] && create_if_block_1$3(ctx);

    	markdown = new Markdown({
    			props: { text: /*post*/ ctx[5].body },
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block$1,
    		value: 6,
    		error: 10,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*repliesPromise*/ ctx[1], info);

    	addpost = new AddPost({
    			props: {
    				replyTo: /*id*/ ctx[0],
    				onSuccess: /*onReply*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			p0 = element("p");
    			strong = element("strong");
    			t2 = text(t2_value);
    			t3 = text("\n                commented\n                ");
    			time = element("time");
    			t4 = text(t4_value);
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			div1 = element("div");
    			create_component(markdown.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			info.block.c();
    			t8 = space();
    			div4 = element("div");
    			p1 = element("p");
    			p1.textContent = "Your reply";
    			t10 = space();
    			create_component(addpost.$$.fragment);
    			attr_dev(h1, "class", "svelte-q7j4s7");
    			add_location(h1, file$b, 68, 8, 1535);
    			add_location(strong, file$b, 71, 16, 1620);
    			attr_dev(time, "title", time_title_value = toFullDate(/*post*/ ctx[5].ts * 1000));
    			attr_dev(time, "datetime", time_datetime_value = toDateTime(/*post*/ ctx[5].ts * 1000));
    			add_location(time, file$b, 73, 16, 1691);
    			attr_dev(p0, "class", "svelte-q7j4s7");
    			add_location(p0, file$b, 70, 12, 1600);
    			attr_dev(div0, "class", "metadata svelte-q7j4s7");
    			add_location(div0, file$b, 69, 8, 1565);
    			attr_dev(div1, "class", "body svelte-q7j4s7");
    			add_location(div1, file$b, 83, 8, 2060);
    			attr_dev(div2, "class", "post svelte-q7j4s7");
    			add_location(div2, file$b, 67, 4, 1508);
    			attr_dev(div3, "class", "replies svelte-q7j4s7");
    			add_location(div3, file$b, 87, 4, 2151);
    			attr_dev(p1, "class", "svelte-q7j4s7");
    			add_location(p1, file$b, 123, 8, 3548);
    			attr_dev(div4, "class", "metadata svelte-q7j4s7");
    			add_location(div4, file$b, 122, 4, 3517);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h1);
    			append_dev(h1, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(p0, strong);
    			append_dev(strong, t2);
    			append_dev(p0, t3);
    			append_dev(p0, time);
    			append_dev(time, t4);
    			append_dev(div0, t5);
    			if (if_block) if_block.m(div0, null);
    			append_dev(div2, t6);
    			append_dev(div2, div1);
    			mount_component(markdown, div1, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div3, anchor);
    			info.block.m(div3, info.anchor = null);
    			info.mount = () => div3;
    			info.anchor = null;
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, p1);
    			insert_dev(target, t10, anchor);
    			mount_component(addpost, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*post*/ ctx[5].publicKey === /*$publicKey*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			info.ctx = ctx;

    			if (dirty & /*repliesPromise*/ 2 && promise !== (promise = /*repliesPromise*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[6] = child_ctx[10] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}

    			const addpost_changes = {};
    			if (dirty & /*id*/ 1) addpost_changes.replyTo = /*id*/ ctx[0];
    			addpost.$set(addpost_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(markdown.$$.fragment, local);
    			transition_in(info.block);
    			transition_in(addpost.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(markdown.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(addpost.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			destroy_component(markdown);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div3);
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t10);
    			destroy_component(addpost, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$1.name,
    		type: "then",
    		source: "(67:30)      <div class=\\\"post\\\">         <h1>{post.title}",
    		ctx
    	});

    	return block;
    }

    // (80:12) {#if post.publicKey === $publicKey}
    function create_if_block_1$3(ctx) {
    	let div;
    	let a0;
    	let t1;
    	let a1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a0 = element("a");
    			a0.textContent = "Edit";
    			t1 = space();
    			a1 = element("a");
    			a1.textContent = "Delete";
    			add_location(a0, file$b, 80, 38, 1987);
    			add_location(a1, file$b, 80, 50, 1999);
    			attr_dev(div, "class", "controls svelte-q7j4s7");
    			add_location(div, file$b, 80, 16, 1965);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a0);
    			append_dev(div, t1);
    			append_dev(div, a1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(80:12) {#if post.publicKey === $publicKey}",
    		ctx
    	});

    	return block;
    }

    // (118:8) {:catch error}
    function create_catch_block$1(ctx) {
    	let t_value = /*error*/ ctx[10].message + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*repliesPromise*/ 2 && t_value !== (t_value = /*error*/ ctx[10].message + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$1.name,
    		type: "catch",
    		source: "(118:8) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (89:44)              <ol>                 {#each replies.reverse() as reply}
    function create_then_block_1(ctx) {
    	let ol;
    	let current;
    	let each_value = /*replies*/ ctx[6].reverse();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ol = element("ol");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ol, "class", "svelte-q7j4s7");
    			add_location(ol, file$b, 89, 12, 2230);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ol, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*repliesPromise, postPromise, $publicKey, toFullDate, toDateTime, prettyDate*/ 14) {
    				each_value = /*replies*/ ctx[6].reverse();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ol, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(89:44)              <ol>                 {#each replies.reverse() as reply}",
    		ctx
    	});

    	return block;
    }

    // (105:28) {#if reply.publicKey === $publicKey}
    function create_if_block$8(ctx) {
    	let div;
    	let a0;
    	let t1;
    	let a1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			a0 = element("a");
    			a0.textContent = "Edit";
    			t1 = space();
    			a1 = element("a");
    			a1.textContent = "Delete";
    			add_location(a0, file$b, 106, 36, 3066);
    			add_location(a1, file$b, 107, 36, 3114);
    			attr_dev(div, "class", "controls svelte-q7j4s7");
    			add_location(div, file$b, 105, 32, 3007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a0);
    			append_dev(div, t1);
    			append_dev(div, a1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(105:28) {#if reply.publicKey === $publicKey}",
    		ctx
    	});

    	return block;
    }

    // (91:16) {#each replies.reverse() as reply}
    function create_each_block$2(ctx) {
    	let li;
    	let div0;
    	let p;
    	let strong;
    	let t0_value = /*reply*/ ctx[7].name + "";
    	let t0;
    	let t1;
    	let time;
    	let t2_value = prettyDate(/*reply*/ ctx[7].ts * 1000) + "";
    	let t2;
    	let time_title_value;
    	let time_datetime_value;
    	let t3;
    	let t4;
    	let div1;
    	let markdown;
    	let t5;
    	let current;
    	let if_block = /*reply*/ ctx[7].publicKey === /*$publicKey*/ ctx[2] && create_if_block$8(ctx);

    	markdown = new Markdown({
    			props: { text: /*reply*/ ctx[7].body },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			div0 = element("div");
    			p = element("p");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = text("\n                                commented\n                                ");
    			time = element("time");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			div1 = element("div");
    			create_component(markdown.$$.fragment);
    			t5 = space();
    			add_location(strong, file$b, 96, 32, 2513);
    			attr_dev(time, "title", time_title_value = toFullDate(/*reply*/ ctx[7].ts * 1000));
    			attr_dev(time, "datetime", time_datetime_value = toDateTime(/*reply*/ ctx[7].ts * 1000));
    			add_location(time, file$b, 98, 32, 2617);
    			attr_dev(p, "class", "svelte-q7j4s7");
    			add_location(p, file$b, 95, 28, 2477);
    			attr_dev(div0, "class", "metadata svelte-q7j4s7");
    			toggle_class(div0, "new", /*reply*/ ctx[7].ts > /*post*/ ctx[5].seenTs);
    			add_location(div0, file$b, 92, 24, 2335);
    			attr_dev(div1, "class", "body svelte-q7j4s7");
    			add_location(div1, file$b, 111, 24, 3256);
    			attr_dev(li, "class", "svelte-q7j4s7");
    			add_location(li, file$b, 91, 20, 2306);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div0);
    			append_dev(div0, p);
    			append_dev(p, strong);
    			append_dev(strong, t0);
    			append_dev(p, t1);
    			append_dev(p, time);
    			append_dev(time, t2);
    			append_dev(div0, t3);
    			if (if_block) if_block.m(div0, null);
    			append_dev(li, t4);
    			append_dev(li, div1);
    			mount_component(markdown, div1, null);
    			append_dev(li, t5);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*repliesPromise*/ 2) && t0_value !== (t0_value = /*reply*/ ctx[7].name + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*repliesPromise*/ 2) && t2_value !== (t2_value = prettyDate(/*reply*/ ctx[7].ts * 1000) + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*repliesPromise*/ 2 && time_title_value !== (time_title_value = toFullDate(/*reply*/ ctx[7].ts * 1000))) {
    				attr_dev(time, "title", time_title_value);
    			}

    			if (!current || dirty & /*repliesPromise*/ 2 && time_datetime_value !== (time_datetime_value = toDateTime(/*reply*/ ctx[7].ts * 1000))) {
    				attr_dev(time, "datetime", time_datetime_value);
    			}

    			if (/*reply*/ ctx[7].publicKey === /*$publicKey*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*repliesPromise, postPromise*/ 10) {
    				toggle_class(div0, "new", /*reply*/ ctx[7].ts > /*post*/ ctx[5].seenTs);
    			}

    			const markdown_changes = {};
    			if (dirty & /*repliesPromise*/ 2) markdown_changes.text = /*reply*/ ctx[7].body;
    			markdown.$set(markdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(markdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(markdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (if_block) if_block.d();
    			destroy_component(markdown);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(91:16) {#each replies.reverse() as reply}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>     import { prettyDate, toDateTime, toFullDate }
    function create_pending_block_1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(1:0) <script>     import { prettyDate, toDateTime, toFullDate }",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>     import { prettyDate, toDateTime, toFullDate }
    function create_pending_block$1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$1.name,
    		type: "pending",
    		source: "(1:0) <script>     import { prettyDate, toDateTime, toFullDate }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block_1,
    		value: 5,
    		error: 10,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*postPromise*/ ctx[3], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			{
    				const child_ctx = ctx.slice();
    				child_ctx[5] = child_ctx[10] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $publicKey;
    	validate_store(publicKey, "publicKey");
    	component_subscribe($$self, publicKey, $$value => $$invalidate(2, $publicKey = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Post", slots, []);
    	let { id } = $$props;
    	let postPromise = getPost(id);
    	let repliesPromise = getPosts(id, 1000, 0);

    	setTimeout(
    		() => {
    			markPostAsSeen(id);
    		},
    		1000
    	);

    	function onReply(replyId) {
    		$$invalidate(1, repliesPromise = getPosts(id, 1000, 0));
    	}

    	const writable_props = ["id"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Post> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    	};

    	$$self.$capture_state = () => ({
    		prettyDate,
    		toDateTime,
    		toFullDate,
    		AddPost,
    		Markdown,
    		getPost,
    		getPosts,
    		markPostAsSeen,
    		publicKey,
    		id,
    		postPromise,
    		repliesPromise,
    		onReply,
    		$publicKey
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("postPromise" in $$props) $$invalidate(3, postPromise = $$props.postPromise);
    		if ("repliesPromise" in $$props) $$invalidate(1, repliesPromise = $$props.repliesPromise);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, repliesPromise, $publicKey, postPromise, onReply];
    }

    class Post extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { id: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Post",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
    			console.warn("<Post> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<Post>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Post>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/forum/GetPost.svelte generated by Svelte v3.31.0 */
    const file$c = "src/routes/forum/GetPost.svelte";

    function create_fragment$f(ctx) {
    	let section;
    	let post;
    	let current;

    	post = new Post({
    			props: { id: /*params*/ ctx[0].id },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(post.$$.fragment);
    			add_location(section, file$c, 6, 0, 103);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(post, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const post_changes = {};
    			if (dirty & /*params*/ 1) post_changes.id = /*params*/ ctx[0].id;
    			post.$set(post_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(post.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(post.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(post);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("GetPost", slots, []);
    	let { params } = $$props;
    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GetPost> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ Post, params });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params];
    }

    class GetPost extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GetPost",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[0] === undefined && !("params" in props)) {
    			console.warn("<GetPost> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<GetPost>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<GetPost>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/forum/AddPost.svelte generated by Svelte v3.31.0 */
    const file$d = "src/routes/forum/AddPost.svelte";

    function create_fragment$g(ctx) {
    	let section;
    	let h1;
    	let t1;
    	let addpost;
    	let current;

    	addpost = new AddPost({
    			props: { onSuccess: /*onSuccess*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			h1 = element("h1");
    			h1.textContent = "New post";
    			t1 = space();
    			create_component(addpost.$$.fragment);
    			add_location(h1, file$d, 10, 4, 225);
    			add_location(section, file$d, 9, 0, 211);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, h1);
    			append_dev(section, t1);
    			mount_component(addpost, section, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addpost.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addpost.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(addpost);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AddPost", slots, []);

    	function onSuccess(postId) {
    		push("/forum/posts/" + postId);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AddPost> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ AddPost, push, onSuccess });
    	return [onSuccess];
    }

    class AddPost_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddPost_1",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    function fade(node, { delay = 0, duration = 400, easing = identity }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* src/routes/home/InviteItem.svelte generated by Svelte v3.31.0 */

    const file$e = "src/routes/home/InviteItem.svelte";

    function create_fragment$h(ctx) {
    	let input_1;
    	let t0;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			t0 = space();
    			button = element("button");
    			button.textContent = "Copy";
    			attr_dev(input_1, "type", "text");
    			input_1.value = /*invite*/ ctx[0];
    			attr_dev(input_1, "class", "svelte-llszvy");
    			toggle_class(input_1, "neutral", /*copied*/ ctx[2]);
    			add_location(input_1, file$e, 19, 0, 235);
    			toggle_class(button, "neutral", /*copied*/ ctx[2]);
    			add_location(button, file$e, 20, 0, 313);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[4](input_1);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*invite*/ 1 && input_1.value !== /*invite*/ ctx[0]) {
    				prop_dev(input_1, "value", /*invite*/ ctx[0]);
    			}

    			if (dirty & /*copied*/ 4) {
    				toggle_class(input_1, "neutral", /*copied*/ ctx[2]);
    			}

    			if (dirty & /*copied*/ 4) {
    				toggle_class(button, "neutral", /*copied*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[4](null);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InviteItem", slots, []);
    	let { invite } = $$props;
    	let input;
    	let copied;

    	function handleCopy() {
    		input.select();
    		document.execCommand("copy");
    		input.blur();
    		$$invalidate(2, copied = true);
    	}

    	const writable_props = ["invite"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InviteItem> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(1, input);
    		});
    	}

    	const click_handler = () => handleCopy();

    	$$self.$$set = $$props => {
    		if ("invite" in $$props) $$invalidate(0, invite = $$props.invite);
    	};

    	$$self.$capture_state = () => ({ invite, input, copied, handleCopy });

    	$$self.$inject_state = $$props => {
    		if ("invite" in $$props) $$invalidate(0, invite = $$props.invite);
    		if ("input" in $$props) $$invalidate(1, input = $$props.input);
    		if ("copied" in $$props) $$invalidate(2, copied = $$props.copied);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [invite, input, copied, handleCopy, input_1_binding, click_handler];
    }

    class InviteItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { invite: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InviteItem",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*invite*/ ctx[0] === undefined && !("invite" in props)) {
    			console.warn("<InviteItem> was created without expected prop 'invite'");
    		}
    	}

    	get invite() {
    		throw new Error("<InviteItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invite(value) {
    		throw new Error("<InviteItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/home/Invite.svelte generated by Svelte v3.31.0 */
    const file$f = "src/routes/home/Invite.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (66:4) {#key invite}
    function create_key_block_1(ctx) {
    	let li;
    	let inviteitem;
    	let t;
    	let li_intro;
    	let current;

    	inviteitem = new InviteItem({
    			props: { invite: /*invite*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(inviteitem.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-tb6ibz");
    			add_location(li, file$f, 66, 6, 1558);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(inviteitem, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const inviteitem_changes = {};
    			if (dirty & /*memberInvites*/ 1) inviteitem_changes.invite = /*invite*/ ctx[8];
    			inviteitem.$set(inviteitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inviteitem.$$.fragment, local);

    			if (!li_intro) {
    				add_render_callback(() => {
    					li_intro = create_in_transition(li, fade, {});
    					li_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inviteitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(inviteitem);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1.name,
    		type: "key",
    		source: "(66:4) {#key invite}",
    		ctx
    	});

    	return block;
    }

    // (65:2) {#each memberInvites as invite}
    function create_each_block_1(ctx) {
    	let previous_key = /*invite*/ ctx[8];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_1(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*memberInvites*/ 1 && safe_not_equal(previous_key, previous_key = /*invite*/ ctx[8])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block_1(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(65:2) {#each memberInvites as invite}",
    		ctx
    	});

    	return block;
    }

    // (82:4) {#key invite}
    function create_key_block(ctx) {
    	let li;
    	let inviteitem;
    	let t;
    	let li_intro;
    	let current;

    	inviteitem = new InviteItem({
    			props: { invite: /*invite*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(inviteitem.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-tb6ibz");
    			add_location(li, file$f, 82, 6, 1877);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(inviteitem, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const inviteitem_changes = {};
    			if (dirty & /*adminInvites*/ 2) inviteitem_changes.invite = /*invite*/ ctx[8];
    			inviteitem.$set(inviteitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inviteitem.$$.fragment, local);

    			if (!li_intro) {
    				add_render_callback(() => {
    					li_intro = create_in_transition(li, fade, {});
    					li_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inviteitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(inviteitem);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(82:4) {#key invite}",
    		ctx
    	});

    	return block;
    }

    // (81:2) {#each adminInvites as invite}
    function create_each_block$3(ctx) {
    	let previous_key = /*invite*/ ctx[8];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*adminInvites*/ 2 && safe_not_equal(previous_key, previous_key = /*invite*/ ctx[8])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(81:2) {#each adminInvites as invite}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let h20;
    	let t5;
    	let p1;
    	let t7;
    	let ul0;
    	let t8;
    	let button0;
    	let t10;
    	let h21;
    	let t12;
    	let p2;
    	let t14;
    	let ul1;
    	let t15;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*memberInvites*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*adminInvites*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Invite people to join this space";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "To invite a new member, copy one of the links below and share it via email or\n  messenger. An invite is valid for 7 days and can be used only once. You can\n  generate as many invites you need.";
    			t3 = space();
    			h20 = element("h2");
    			h20.textContent = "Invite members";
    			t5 = space();
    			p1 = element("p");
    			p1.textContent = "Members can join video calls, edit the shared pad, and post in the forum.";
    			t7 = space();
    			ul0 = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t8 = space();
    			button0 = element("button");
    			button0.textContent = "I need more invites";
    			t10 = space();
    			h21 = element("h2");
    			h21.textContent = "Invite members with admin powers";
    			t12 = space();
    			p2 = element("p");
    			p2.textContent = "Members with admin powers can invite new people.";
    			t14 = space();
    			ul1 = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t15 = space();
    			button1 = element("button");
    			button1.textContent = "I need more invites";
    			add_location(h1, file$f, 51, 0, 1140);
    			add_location(p0, file$f, 53, 0, 1183);
    			add_location(h20, file$f, 59, 0, 1388);
    			add_location(p1, file$f, 61, 0, 1413);
    			attr_dev(ul0, "class", "svelte-tb6ibz");
    			add_location(ul0, file$f, 63, 0, 1495);
    			add_location(button0, file$f, 73, 0, 1643);
    			add_location(h21, file$f, 75, 0, 1715);
    			add_location(p2, file$f, 77, 0, 1758);
    			attr_dev(ul1, "class", "svelte-tb6ibz");
    			add_location(ul1, file$f, 79, 0, 1815);
    			add_location(button1, file$f, 88, 0, 1961);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, ul0, anchor);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul0, null);
    			}

    			insert_dev(target, t8, anchor);
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, ul1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul1, null);
    			}

    			insert_dev(target, t15, anchor);
    			insert_dev(target, button1, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*memberInvites*/ 1) {
    				each_value_1 = /*memberInvites*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(ul0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*adminInvites*/ 2) {
    				each_value = /*adminInvites*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(ul0);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(ul1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $keyPair;
    	validate_store(keyPair, "keyPair");
    	component_subscribe($$self, keyPair, $$value => $$invalidate(6, $keyPair = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Invite", slots, []);
    	let memberInvites = [];
    	let adminInvites = [];
    	generateMember(1);
    	generateAdmin(1);

    	function generate(secretKey, isAdmin, n) {
    		const expiry = new Date();
    		expiry.setDate(expiry.getDate() + 7);
    		const invites = [];

    		for (let i = 0; i < n; i++) {
    			const invitation = invite(secretKey, isAdmin, expiry);
    			const hexInvite = uint8ArrayToHexString(invitation);
    			invites.push(`${window.location.origin}/#/join/${hexInvite}`);
    		}

    		return invites;
    	}

    	function generateAdmin(n = 5) {
    		$$invalidate(1, adminInvites = [...adminInvites, ...generate($keyPair.secretKey, true, n)]);
    	}

    	function generateMember(n = 5) {
    		$$invalidate(0, memberInvites = [...memberInvites, ...generate($keyPair.secretKey, false, n)]);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Invite> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => generateMember();
    	const click_handler_1 = () => generateAdmin();

    	$$self.$capture_state = () => ({
    		fade,
    		invite,
    		uint8ArrayToHexString,
    		keyPair,
    		InviteItem,
    		memberInvites,
    		adminInvites,
    		generate,
    		generateAdmin,
    		generateMember,
    		$keyPair
    	});

    	$$self.$inject_state = $$props => {
    		if ("memberInvites" in $$props) $$invalidate(0, memberInvites = $$props.memberInvites);
    		if ("adminInvites" in $$props) $$invalidate(1, adminInvites = $$props.adminInvites);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		memberInvites,
    		adminInvites,
    		generateAdmin,
    		generateMember,
    		click_handler,
    		click_handler_1
    	];
    }

    class Invite extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Invite",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src/routes/admin/Admin.svelte generated by Svelte v3.31.0 */
    const file$g = "src/routes/admin/Admin.svelte";

    function create_fragment$j(ctx) {
    	let section;
    	let invite;
    	let current;
    	invite = new Invite({ $$inline: true });

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(invite.$$.fragment);
    			add_location(section, file$g, 4, 0, 66);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(invite, section, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(invite.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(invite.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(invite);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Admin", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Admin> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Invite });
    	return [];
    }

    class Admin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Admin",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/routes/join/Join.svelte generated by Svelte v3.31.0 */

    const { console: console_1$3 } = globals;
    const file$h = "src/routes/join/Join.svelte";

    // (92:0) {:else}
    function create_else_block$3(ctx) {
    	let section;
    	let p;
    	let t0;
    	let a;

    	const block = {
    		c: function create() {
    			section = element("section");
    			p = element("p");
    			t0 = text("You cannot use this invite since you are already a member.\n      ");
    			a = element("a");
    			a.textContent = "Go back";
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "button");
    			add_location(a, file$h, 95, 6, 1937);
    			attr_dev(p, "class", "svelte-1bog7mk");
    			add_location(p, file$h, 93, 4, 1862);
    			attr_dev(section, "class", "svelte-1bog7mk");
    			add_location(section, file$h, 92, 2, 1848);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p);
    			append_dev(p, t0);
    			append_dev(p, a);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(92:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (76:0) {#if $space === false}
    function create_if_block$9(ctx) {
    	let section;
    	let h1;
    	let t0;
    	let strong;
    	let t2;

    	function select_block_type_1(ctx, dirty) {
    		if (/*validationStatus*/ ctx[2] === true) return create_if_block_1$4;
    		if (/*validationStatus*/ ctx[2] === false) return create_if_block_3$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			h1 = element("h1");
    			t0 = text("welcome to ");
    			strong = element("strong");
    			strong.textContent = "psst";
    			t2 = space();
    			if (if_block) if_block.c();
    			add_location(strong, file$h, 77, 19, 1423);
    			attr_dev(h1, "class", "svelte-1bog7mk");
    			add_location(h1, file$h, 77, 4, 1408);
    			attr_dev(section, "class", "svelte-1bog7mk");
    			add_location(section, file$h, 76, 2, 1394);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, h1);
    			append_dev(h1, t0);
    			append_dev(h1, strong);
    			append_dev(section, t2);
    			if (if_block) if_block.m(section, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(section, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(76:0) {#if $space === false}",
    		ctx
    	});

    	return block;
    }

    // (90:41) 
    function create_if_block_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*validationError*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*validationError*/ 8) set_data_dev(t, /*validationError*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(90:41) ",
    		ctx
    	});

    	return block;
    }

    // (80:4) {#if validationStatus === true}
    function create_if_block_1$4(ctx) {
    	let form;
    	let label;
    	let t1;
    	let input;
    	let t2;
    	let button;
    	let t4;
    	let if_block_anchor;
    	let mounted;
    	let dispose;
    	let if_block = /*error*/ ctx[0] && create_if_block_2$3(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			label = element("label");
    			label.textContent = "Choose your pseudonym";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			button = element("button");
    			button.textContent = "Next";
    			t4 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(label, "for", "name");
    			attr_dev(label, "class", "svelte-1bog7mk");
    			add_location(label, file$h, 81, 8, 1546);
    			attr_dev(input, "id", "name");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "class", "svelte-1bog7mk");
    			add_location(input, file$h, 82, 8, 1602);
    			add_location(button, file$h, 83, 8, 1671);
    			attr_dev(form, "class", "svelte-1bog7mk");
    			add_location(form, file$h, 80, 6, 1493);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, label);
    			append_dev(form, t1);
    			append_dev(form, input);
    			set_input_value(input, /*userName*/ ctx[1]);
    			append_dev(form, t2);
    			append_dev(form, button);
    			insert_dev(target, t4, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(form, "submit", prevent_default(/*handleJoin*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*userName*/ 2 && input.value !== /*userName*/ ctx[1]) {
    				set_input_value(input, /*userName*/ ctx[1]);
    			}

    			if (/*error*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (detaching) detach_dev(t4);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(80:4) {#if validationStatus === true}",
    		ctx
    	});

    	return block;
    }

    // (87:6) {#if error}
    function create_if_block_2$3(ctx) {
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*error*/ ctx[0]);
    			attr_dev(p, "class", "svelte-1bog7mk");
    			add_location(p, file$h, 87, 8, 1734);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 1) set_data_dev(t, /*error*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(87:6) {#if error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*$space*/ ctx[4] === false) return create_if_block$9;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $space;
    	validate_store(space$1, "space");
    	component_subscribe($$self, space$1, $$value => $$invalidate(4, $space = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Join", slots, []);
    	let { params = {} } = $$props;
    	let error;
    	let userName = "";
    	let signerName = "";
    	let spaceName = "";
    	let validationStatus;
    	let validationError;

    	getInviteDetails(params.invitation).then(d => {
    		signerName = d.userName;
    		spaceName = d.spaceName;
    	});

    	verifyInvite(params.invitation).then(status => {
    		$$invalidate(2, validationStatus = true);
    	}).catch(e => {
    		console.log(e);
    		$$invalidate(2, validationStatus = false);
    		$$invalidate(3, validationError = e.message);
    	});

    	async function handleJoin() {
    		try {
    			await joinSpace(spaceName, userName, params.invitation);
    			console.log("joining");
    			replace("/");
    		} catch(e) {
    			console.log("error", e);

    			if (e.code === -32006) {
    				$$invalidate(0, error = "Pseudonym already taken, try another one.");
    			} else {
    				$$invalidate(0, error = e.message);
    			}
    		}
    	}

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Join> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		userName = this.value;
    		$$invalidate(1, userName);
    	}

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		space: space$1,
    		joinSpace,
    		getInviteDetails,
    		verifyInvite,
    		replace,
    		params,
    		error,
    		userName,
    		signerName,
    		spaceName,
    		validationStatus,
    		validationError,
    		handleJoin,
    		$space
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(6, params = $$props.params);
    		if ("error" in $$props) $$invalidate(0, error = $$props.error);
    		if ("userName" in $$props) $$invalidate(1, userName = $$props.userName);
    		if ("signerName" in $$props) signerName = $$props.signerName;
    		if ("spaceName" in $$props) spaceName = $$props.spaceName;
    		if ("validationStatus" in $$props) $$invalidate(2, validationStatus = $$props.validationStatus);
    		if ("validationError" in $$props) $$invalidate(3, validationError = $$props.validationError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		error,
    		userName,
    		validationStatus,
    		validationError,
    		$space,
    		handleJoin,
    		params,
    		input_input_handler
    	];
    }

    class Join extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { params: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Join",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get params() {
    		throw new Error("<Join>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Join>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/logout/CopyInput.svelte generated by Svelte v3.31.0 */

    const file$i = "src/routes/logout/CopyInput.svelte";

    function create_fragment$l(ctx) {
    	let div;
    	let input_1;
    	let t0;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input_1 = element("input");
    			t0 = space();
    			button = element("button");
    			button.textContent = "Copy";
    			attr_dev(input_1, "type", "text");
    			input_1.value = /*text*/ ctx[0];
    			attr_dev(input_1, "class", "svelte-3l7853");
    			toggle_class(input_1, "neutral", /*copied*/ ctx[2]);
    			add_location(input_1, file$i, 23, 2, 272);
    			toggle_class(button, "neutral", /*copied*/ ctx[2]);
    			add_location(button, file$i, 24, 2, 350);
    			attr_dev(div, "class", "svelte-3l7853");
    			add_location(div, file$i, 22, 0, 264);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input_1);
    			/*input_1_binding*/ ctx[4](input_1);
    			append_dev(div, t0);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*text*/ 1 && input_1.value !== /*text*/ ctx[0]) {
    				prop_dev(input_1, "value", /*text*/ ctx[0]);
    			}

    			if (dirty & /*copied*/ 4) {
    				toggle_class(input_1, "neutral", /*copied*/ ctx[2]);
    			}

    			if (dirty & /*copied*/ 4) {
    				toggle_class(button, "neutral", /*copied*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*input_1_binding*/ ctx[4](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CopyInput", slots, []);
    	let { text } = $$props;
    	let input;
    	let copied;

    	function handleCopy() {
    		input.select();
    		document.execCommand("copy");
    		input.blur();
    		$$invalidate(2, copied = true);
    	}

    	const writable_props = ["text"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CopyInput> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(1, input);
    		});
    	}

    	const click_handler = () => handleCopy();

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ text, input, copied, handleCopy });

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("input" in $$props) $$invalidate(1, input = $$props.input);
    		if ("copied" in $$props) $$invalidate(2, copied = $$props.copied);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text, input, copied, handleCopy, input_1_binding, click_handler];
    }

    class CopyInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { text: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CopyInput",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*text*/ ctx[0] === undefined && !("text" in props)) {
    			console.warn("<CopyInput> was created without expected prop 'text'");
    		}
    	}

    	get text() {
    		throw new Error("<CopyInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<CopyInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/routes/logout/Logout.svelte generated by Svelte v3.31.0 */
    const file$j = "src/routes/logout/Logout.svelte";

    function create_fragment$m(ctx) {
    	let section;
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let copyinput;
    	let t4;
    	let div0;
    	let label;
    	let t5;
    	let input;
    	let t6;
    	let div1;
    	let button;
    	let t7;
    	let button_disabled_value;
    	let t8;
    	let a;
    	let current;
    	let mounted;
    	let dispose;

    	copyinput = new CopyInput({
    			props: { text: /*$mnemonic*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			h1 = element("h1");
    			h1.textContent = "Before you leave";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Save your magic words. If you don't, you won't be able to log in with your\n    user and you'll have to ask for a new invite. Your magic words are:";
    			t3 = space();
    			p1 = element("p");
    			create_component(copyinput.$$.fragment);
    			t4 = space();
    			div0 = element("div");
    			label = element("label");
    			t5 = text("I understand\n      ");
    			input = element("input");
    			t6 = space();
    			div1 = element("div");
    			button = element("button");
    			t7 = text("Exit space");
    			t8 = space();
    			a = element("a");
    			a.textContent = "Go back";
    			add_location(h1, file$j, 29, 2, 474);
    			add_location(p0, file$j, 31, 2, 503);
    			attr_dev(p1, "class", "mnemonic svelte-52deqx");
    			add_location(p1, file$j, 36, 2, 668);
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$j, 43, 6, 777);
    			add_location(label, file$j, 41, 4, 744);
    			attr_dev(div0, "class", "svelte-52deqx");
    			add_location(div0, file$j, 40, 2, 734);
    			button.disabled = button_disabled_value = !/*understand*/ ctx[0];
    			add_location(button, file$j, 47, 4, 863);
    			attr_dev(a, "class", "button neutral");
    			attr_dev(a, "href", "#");
    			add_location(a, file$j, 48, 4, 942);
    			attr_dev(div1, "class", "svelte-52deqx");
    			add_location(div1, file$j, 46, 2, 853);
    			attr_dev(section, "class", "svelte-52deqx");
    			add_location(section, file$j, 28, 0, 462);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, h1);
    			append_dev(section, t1);
    			append_dev(section, p0);
    			append_dev(section, t3);
    			append_dev(section, p1);
    			mount_component(copyinput, p1, null);
    			append_dev(section, t4);
    			append_dev(section, div0);
    			append_dev(div0, label);
    			append_dev(label, t5);
    			append_dev(label, input);
    			input.checked = /*understand*/ ctx[0];
    			append_dev(section, t6);
    			append_dev(section, div1);
    			append_dev(div1, button);
    			append_dev(button, t7);
    			append_dev(div1, t8);
    			append_dev(div1, a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[3]),
    					listen_dev(button, "click", /*handleLogout*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const copyinput_changes = {};
    			if (dirty & /*$mnemonic*/ 2) copyinput_changes.text = /*$mnemonic*/ ctx[1];
    			copyinput.$set(copyinput_changes);

    			if (dirty & /*understand*/ 1) {
    				input.checked = /*understand*/ ctx[0];
    			}

    			if (!current || dirty & /*understand*/ 1 && button_disabled_value !== (button_disabled_value = !/*understand*/ ctx[0])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(copyinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(copyinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(copyinput);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $mnemonic;
    	validate_store(mnemonic, "mnemonic");
    	component_subscribe($$self, mnemonic, $$value => $$invalidate(1, $mnemonic = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Logout", slots, []);
    	let understand;

    	function handleLogout() {
    		logout();
    		push("/");
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Logout> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		understand = this.checked;
    		$$invalidate(0, understand);
    	}

    	$$self.$capture_state = () => ({
    		push,
    		CopyInput,
    		mnemonic,
    		logout,
    		understand,
    		handleLogout,
    		$mnemonic
    	});

    	$$self.$inject_state = $$props => {
    		if ("understand" in $$props) $$invalidate(0, understand = $$props.understand);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [understand, $mnemonic, handleLogout, input_change_handler];
    }

    class Logout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Logout",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.31.0 */
    const file$k = "src/App.svelte";

    // (29:0) {#if $space !== undefined}
    function create_if_block$a(ctx) {
    	let main;
    	let enablenotifications;
    	let t0;
    	let header;
    	let t1;
    	let jitsicontroller;
    	let t2;
    	let router;
    	let current;
    	enablenotifications = new EnableNotifications({ $$inline: true });

    	header = new Header({
    			props: { space: /*$space*/ ctx[0] },
    			$$inline: true
    		});

    	jitsicontroller = new JitsiController({ $$inline: true });

    	router = new Router({
    			props: { routes: /*routes*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(enablenotifications.$$.fragment);
    			t0 = space();
    			create_component(header.$$.fragment);
    			t1 = space();
    			create_component(jitsicontroller.$$.fragment);
    			t2 = space();
    			create_component(router.$$.fragment);
    			add_location(main, file$k, 29, 2, 846);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(enablenotifications, main, null);
    			append_dev(main, t0);
    			mount_component(header, main, null);
    			append_dev(main, t1);
    			mount_component(jitsicontroller, main, null);
    			append_dev(main, t2);
    			mount_component(router, main, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const header_changes = {};
    			if (dirty & /*$space*/ 1) header_changes.space = /*$space*/ ctx[0];
    			header.$set(header_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(enablenotifications.$$.fragment, local);
    			transition_in(header.$$.fragment, local);
    			transition_in(jitsicontroller.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(enablenotifications.$$.fragment, local);
    			transition_out(header.$$.fragment, local);
    			transition_out(jitsicontroller.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(enablenotifications);
    			destroy_component(header);
    			destroy_component(jitsicontroller);
    			destroy_component(router);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(29:0) {#if $space !== undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$space*/ ctx[0] !== undefined && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$space*/ ctx[0] !== undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$space*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $space;
    	validate_store(space$1, "space");
    	component_subscribe($$self, space$1, $$value => $$invalidate(0, $space = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	const routes = {
    		"/": Home,
    		"/forum": Index$1,
    		"/forum/new": AddPost_1,
    		"/forum/posts/:id": GetPost,
    		"/admin": Admin,
    		"/logout": Logout,
    		"/join/:invitation": Join
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Router,
    		space: space$1,
    		EnableNotifications,
    		Header,
    		JitsiController,
    		Home,
    		Forum: Index$1,
    		ForumGetPost: GetPost,
    		ForumAddPost: AddPost_1,
    		Admin,
    		Join,
    		Logout,
    		routes,
    		$space
    	});

    	return [$space, routes];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    const check = () => {
      if (!("serviceWorker" in navigator)) {
        throw new Error("No Service Worker support!");
      }
      if (!("PushManager" in window)) {
        throw new Error("No Push API Support!");
      }
    };

    const registerServiceWorker = async () => {
      const swRegistration = await navigator.serviceWorker.register(
        "service-worker.js"
      );
      return swRegistration;
    };

    async function install () {
      check();
      await registerServiceWorker();
      // FIXME: store the state in a runtime store
      await navigator.serviceWorker.ready;
    }

    const app = new App({
      target: document.body,
    });

    install();

    return app;

}());
//# sourceMappingURL=bundle.js.map
